import PSC::*, PSL::Short_Names::*

class PSC::Translate is
   //////////////// TODO //////////////////////////////////////////////////////
   //  Proved flag
   //    Precondition on Call_Op and Start/Add_Parallel_Call_Op
   //    Postcondition on Return
   //  allow -O and -g together
   //  Runtime stderr messages
   //  differentiate between File not found and code-less interfaces
   ///////////// KNOWN BUGS ///////////////////////////////////////////////////
   ////////////////////////////////////////////////////////////////////////////

   const Indent := 3;
   const Ind := Indent * " ";
   const Virt_Is_Phys : Boolean := #true;
      // Whether virtual addresses are actually identical to physical addresses
   
   const Debug_Strings : Boolean := #false;
   const Debug_Inlining : Boolean := #false;
   const Debug_Call : Boolean := #false;
   const Debug_VM_Reg_Info_Prop : Boolean := #false;
     //  Debug propagation of info about VM registers
     //  such as whether they have known value, or refer to
     //  a local object.

   const Test_Params_In_Regs : Boolean := #true;
      //  Set to #true to test passing parameters in registers

   //  A basic block without a terminating instruction is illegal in llvm.
   //  PSVM doesn't have this requirement, so we need to
   //  be able to know whether an instruction will generate a "terminating"
   //  instruction and if not add in a "noop br" (branch to next line)
   const Terminators : Set<Reflection::Instruction::Opcode_Enum> :=
         #If_Op | #Skip_Op | #Return_Op | #Exit_Op |
         #Call_Nested_Block_Op | #Check_Nested_Block_Op |
         #Wait_For_Parallel_Op | #Prepare_To_Exit_Parallel_Op;

   const Pass_Params_In_Regs :  //  Most conventions expect params in regs
     Array<Boolean, Indexed_By => Reflection::Decl::Convention_Enum> :=
       [for I in Reflection::Decl::Convention_Enum =>
          (case I of [#external_default|#queuing_default] => #false;
                     [..] => Test_Params_In_Regs)];

   const Formal_Param_VM_Num_Base : Reflection::VM_Reg_Num := 1_000_000;
     //  Formal parameters are assigned VM numbers >= this constant

   func Formal_Param_VM_Num (Reflection::Offset_Within_Area)
     -> Reflection::VM_Reg_Num
     is (Formal_Param_VM_Num_Base + [[Offset_Within_Area]]);
     //  Return formal param VM num given offset within Param_Area

   const Pass_Context_Param :   //  Context param gives picothread info
     Array<Boolean, Indexed_By => Reflection::Decl::Convention_Enum> :=
       [for I in Reflection::Decl::Convention_Enum =>
          (case I of [#internal_default ..< #ada] => #true;
                     [..] => not Test_Params_In_Regs)];

   type TLO_Vector is Vector<LLVM_Top_Level_Op>;
      //  Vector of information on each top-level op

   type VM_Reg_Set is Set<Reflection::VM_Reg_Num>;
      //  Set of VM_Reg_Num's

   interface Inline_Info_Type<> is
      //  Information about a particular inlining
      const Unique_Inline_Id : String;  //  Uniquely identifies inlining
      const Type_Desc : optional Reflection::Type_Descriptor;
                                        //  Type desc for inlined routine,
                                        //  if known.
      const Type_Desc_Name : String;    //  LLVM reg containing type desc.
      const Has_Output_Param : Boolean; //  Whether there was an output param
      const Param_Locator : Reflection::Object_Locator;
                                        //  Locator for params to routine

      const VM_Reg_Adjustment : Reflection::VM_Reg_Num;
                                        //  Amount to adjust VM reg #s

      const Stg_Rgn_Is_Available : Boolean;
                                        //  Whether a storage region is
                                        //  available at the point of an inline

      const Min_Adjustment := 100;      //  Minimum amount to adjust reg#

      func Is_Output_Param(Inline_Info: Inline_Info_Type;
                           Reflection::Object_Locator) -> Boolean
        is (Inline_Info.Has_Output_Param
              and then Object_Locator.Base() ==
                Reflection::Object_Locator::Param_Area
              and then Object_Locator.Offset() == 0);

      func Output_Param_Name(Inline_Info: Inline_Info_Type) -> String
        is ("%_output" | Inline_Info.Unique_Inline_Id);

   end interface Inline_Info_Type;

   type Inline_Stack_Type is Stack<Inline_Info_Type>;

   interface Op_Comp_State<> is
      //  Various variables that represent the compilation state
      //  of the ParaSail operation being compiled.

      var VM_Ptr_Regs : VM_Reg_Set := [];
        //  Set of VM regs that are pointers (i64*) rather than words (i64)

      var VM_Reg_Vals : Map<String, Univ_Integer> := [];
        //  Mapping from VM reg name to Integer value, if known

      var VM_Reg_Type_Descs : Map<String, Reflection::Type_Descriptor> := [];
        //  Mapping from VM reg name to Type descriptor, if known

      var VM_Regs_For_Local_Objs : Set<String> := [];
        //  Set of VM regs that are known to hold an object, or to refer to
        //  a variable that holds an object, that is known to be associated
        //  with the the local region (or is small).
        //  These are candidates to have their space allocated on the
        //  stack.  NOTE: Might want to limit this to non-optional objects.

      var Cur_Node : LLVM_Func_Node_Id;
        //  This is updated when we begin a nested block

      var Inline_Stack : Inline_Stack_Type := [];
        //  This is used to stack inline contexts as we expand
        //  short routines inline.
   end interface Op_Comp_State;

   const Recon_Value_Func := "@_psc_reconstruct_value";

   //  Copy the constants here for convenience
   type Code_Index is Reflection::Routine::Code_Index

   const Zero_Base  := Reflection::Object_Locator::Zero_Base;
   const Local_Area := Reflection::Object_Locator::Local_Area;
   const Param_Area := Reflection::Object_Locator::Param_Area;
   const Type_Area  := Reflection::Object_Locator::Type_Area;
   const Const_Area := Reflection::Object_Locator::Const_Area;
   const Enclosing_Param_Areas :=
      Reflection::Object_Locator::Enclosing_Param_Areas;
   const Enclosing_Local_Areas :=
      Reflection::Object_Locator::Enclosing_Local_Areas;
   const Enclosing_Type_Areas :=
      Reflection::Object_Locator::Enclosing_Type_Areas;
   const Base_Registers := Reflection::Object_Locator::Base_Registers;
   const Phys_Base_Registers :=
      Reflection::Object_Locator::Phys_Base_Registers;

   const Type_Formal_Parameter_Offsets :=
      Reflection::Object_Locator::Type_Formal_Parameter_Offsets;
   const Type_Nested_Type_Offsets :=
      Reflection::Object_Locator::Type_Nested_Type_Offsets;
   const Type_Actual_Of_Formal_Offsets :=
      Reflection::Object_Locator::Type_Actual_Of_Formal_Offsets;
   const Type_Operation_Offsets :=
      Reflection::Object_Locator::Type_Operation_Offsets;
   const Corresponding_Polymorphic_Type_Offsets :=
      Reflection::Object_Locator::Corresponding_Polymorphic_Type_Offsets;

   type LLVM_Func_Node_Id is LLVM_Top_Level_Op::LLVM_Func_Node_Id
     //  Node_Id of LLVM_Func within func tree

   const Master_Offset_In_Words := LLVM_Printer::Master_Offset_In_Words;
     //  Offset of Master record in PSVM stack

   func Put_Error (Message : Univ_String;
     Source_Pos : optional Reflection::Source_Position := null;
     Message_Kind : Univ_String := "Internal") is
   //  Put out an error message on the standard error stream
   
      var IO := IO::Get_IO();
      if Source_Pos not null then
         IO.Stderr.Println(Source_Pos | ": `(Message_Kind): " | Message)
         if Msg_File_Name not null then
            //  Append message to Msg_File
            var Msg_File := File_Output_Stream::Append(IO, Msg_File_Name)
            if Msg_File not null then
               Msg_File.Println(Source_Pos | ": " |
                 Message_Kind | ": " | Message)
               Msg_File.Close()
            end if
         end if
      else
         IO.Stderr.Println(Message_Kind | ": " | Message)
      end if
   end func Put_Error

   //  Replace any character in Take with Put
   func Replace(S : String; Take : Set<Char>; Put : Char) -> String is
      var V := S.To_Vector();
      for each Elem of V loop
         if Elem in Take then
            Elem := Put;
         end if
      end loop
      return String::From_Vector(V)
   end func Replace
   
   //  Replace any character in Take with Put
   //  if not surrounded by Toggle_On characters
   func Replace_With_Toggle(S : String; Take : Set<Char>;
      Put, Toggle_On : Char) -> String is
      var V := S.To_Vector();
      var Replacing : Bool := #true;
      for each Elem of V forward loop
         //  The reason the toggling happens in two places is that
         //  if Toggle_On is in Take, then we still want to replace
         //  it on both edges

         if not Replacing and then Elem == Toggle_On then
            //  Begin replacing
            Replacing := #true;
            if Elem in Take then
               Elem := Put;
            end if
         else
            //  Test condition before we update Replacing
            //  but make the replacement later because Elem still
            //  needs to be checked if it equals Toggle_On
            const Will_Replace := (Replacing and then Elem in Take);

            if Replacing and then Elem == Toggle_On then
               //  Stop replacing
               Replacing := #false;
            end if

            //  Make the replacement
            if Will_Replace then
               Elem := Put;
            end if
         end if
      end loop
      return String::From_Vector(V)
   end func Replace_With_Toggle

   func Full_Op_Name(Op_Item : Reflection::Decl) -> String is
     //  Create full name given decl for operation
     //  by prepending module name and "::" if module name not null.
      {Kind(Op_Item) == #operation}

      const Routine := Routine_For_Operation(Op_Item);
      const Module_Name := Reflection::Routine::Module_Name(Routine);

      const Op_Name := Id(Op_Item);
      if Module_Name not null and then Module_Name != "" then
         return Module_Name | "::" | Op_Name;
      else
         return Op_Name;
      end if

   end func Full_Op_Name

   //  Create a quoted link-name based on full name and prior-homonym count
   func Make_Link_Name(Name : String; Homonyms : Int := 0) -> String is
      // Replace '"', '<', or '>' with '$', "::" with '.', and ", " with ".."
      const To_Cash : Set<Char> := '"' | '<' | '>';
      var Replaced := Replace_With_Toggle(Name, Take => To_Cash,
         Put => '$', Toggle_On => '"');
      Replaced := Replace(Replaced, "::", ".");
      Replaced := Replace(Replaced, ", ", "..");
      if Homonyms > 0 then
         //  Is overloaded; add ".XX" where XX is prior homonym count + 1
         return '"' | Replaced | '.' | Homonyms+1 | '"';
      else
         return '"' | Replaced | '"';
      end if
   end func Make_Link_Name

   //  Turn a designator into the corresponding exported built-in function name
   func Builtin_Name(Desig : String) -> String is
      if Desig == "#close_output_file" or Desig == "#close_input_file" then
         return "_psc_close_file";
      elsif Desig[1] == '#' then
         return "_psc_" | Desig[1 <.. Length(Desig)];
      elsif Desig == "\"**\"" then
         return "_psc_int_exponentiate";
      elsif Desig == "\"**=\"" then
         return "_psc_int_assign_exponentiate";
      else
         Put_Error("Can't find builtin for " | Desig);
         {#false};
      end if
   end func Builtin_Name

   //  Construct the LLVM link name (including the @) from a Routine
   func Get_LLVM_Name(R : Reflection::Routine) -> String is
      //  Name known at compile time, indirect not necessary
      var Code_Name := R.Name();
      const Module_Name := R.Module_Name();
      if Module_Name not null and then Module_Name != "" then
         Code_Name := Module_Name | "::" | Code_Name;
      elsif Code_Name == "main" then
         //  Special case, calling main recursively
         Code_Name := "_parasail_main_routine";
      end if

      //  Convert to linking name
      const Desig := R.Built_In_Desig()
      if Desig not null and then Desig != "" then
         Code_Name := '@' | Make_Link_Name(Builtin_Name(Desig));
      else
         const Homonyms := Num_Prior_Homonyms(R);
         Code_Name := '@' | Make_Link_Name(Code_Name, Homonyms);
      end if
      
      return Code_Name;
   end func Get_LLVM_Name

   func LLVM_Param_Type(Param : Reflection::Routine_Param_Info) -> String is
     (Param.Is_Passed_By_Ref? "i64*" : "i64");
     //  Return "i64" or "i64*" based on Param.is-passed-by-ref

   //  Return a declarator for the func, in case it might be external
   //  TLO keeps track of locally defined functions -- they won't
   //  actually get (re)declared.
   func LLVM_Function_Profile
     (Reflection::Routine;
      LLVM_Name : String := "";
      With_Param_Names : Boolean := #false) -> Result : String is
     //  Order of register parameters is:
     //    input params, static link, context, output-param-initial-val
      const Convention := Convention(Routine);
      const Pass_In_Regs := Pass_Params_In_Regs[Convention];

      if Pass_In_Regs then
         const Formal_Params := Parameters(Routine);
         const Num_Outputs := (for each P of Formal_Params
                                 {P.Is_Operation_Output} => <0> + 1)
         const Output_Is_Inited := Num_Outputs > 0 and then
                                 Output_Needs_Init (Conv_Desc (Routine));

         const Result_Type := Num_Outputs == 0? "void" :
            LLVM_Param_Type(Formal_Params[1])

         --  Initialize LLVM func profile
         Result := Result_Type | " `(LLVM_Name)(";
         
         //  Add Input params to func decl
         for (each P of Formal_Params;
              Parm_Num := 0 then Parm_Num+1)
           {not P.Is_Operation_Output} forward loop
            if Is_Null_Locator (P.Type_Info) then
               //  This must be the implicit module parameter (e.g. exponent
               //  of "**" in the units class).
               //  This param should not appear in the profile.
               null;
            elsif With_Param_Names then
               Result |= LLVM_Param_Type(P) | " %_formal_param_" |
                 Parm_Num | ", "
            else
               Result |= LLVM_Param_Type(P) | ", "
            end if
         end loop

         //  add static link and context
         if With_Param_Names then
            Result |= "i64* %_Context, i64* %_Static_Link"
         else
            Result |= "i64*, i64*";
         end if

         // add inited output, if any
         if not Output_Is_Inited then
            Result |= ")"
         elsif With_Param_Names then
            Result |= ", `(Result_Type) %_inited_output)"
         else
            Result |= ", `(Result_Type))"
         end if

      elsif With_Param_Names then
         Result := "void " | LLVM_Name |
           "(i64* %_Context, i64* %_Param_Area, i64* %_Static_Link)"
      elsif LLVM_Name == "" then
         Result := "void(i64*, i64*, i64*)"  // Match default func type
      else
         Result := "void `(LLVM_Name)(i64*, i64*, i64*)"
      end if
   end func LLVM_Function_Profile;

   //  Use the Call Target and Static Link to find the
   //  Routine and Type_Descriptor for the call
   //  returns (null, null) if not compile-time known
   func Routine_And_TDesc_For_Call(
      Target, Static_Link : Reflection::Object_Locator) ->
      Pair<optional Reflection::Routine,
           optional Reflection::Type_Descriptor> is
      const CT_Base   := Base(Target);
      const CT_Offset := Offset(Target);
      const SL_Base   := Base(Static_Link);
      const SL_Offset := Offset(Static_Link);
      var Type_Desc_To_Use :
         optional Reflection::Type_Descriptor := null;
      var Routine : Reflection::Routine;

      if CT_Base == Zero_Base then
         Routine := Routine_At_Locator(Target);

         //  NOTE: In this case, we return with Type_Desc null, but that is
         //        OK since the returned Type_Desc field is only used for a
         //        later call on Load_Type_Desc, which again looks at the
         //        Static_Link locator, and only uses the Type_Desc
         //        returned by this routine if it is non-null.

      else
         //  We can still figure out the routine at compile time if
         //  the static link is pointing to a compile time known type.

         //  TBD: We can also figure it out if CT_Base == Enclosing_Type_Area.

         if SL_Base == Zero_Base
           and then CT_Base == Type_Area
           and then CT_Offset in Type_Operation_Offsets
         then
            //  Dig out the information from the operations table
            Type_Desc_To_Use :=
               Type_Desc_At_Locator(Static_Link);
            const Op_Index := [[CT_Offset - Type_Operation_Offsets.First]];
            const Info := Operations(Type_Desc_To_Use)[Op_Index]

            if Info.Action != #no_action then
               //  Actions are handled by an indirect call
               return (null, null);
            end if

            if not Info.Use_Static_Link_For_Type then
               //  Type descriptor
               Type_Desc_To_Use := Info.Type_Desc;
            end if
            Routine := Routine_At_Index(Info.Index);
         else
            //  Not Compile-Time known
            return (null, null);
         end if
      end if
      return (Routine, Type_Desc_To_Use);
   end func Routine_And_TDesc_For_Call

   func Finalize_If_Needed(var TLO : LLVM_Top_Level_Op;
                           Stg_Rgn_Is_Available : Bool) is
      //  Finalize region if necessary
      if Stg_Rgn_Is_Available then
         const Finalize := "@_psc_finalize_stg_rgn";
         TLO.Declare(Finalize,
           "void `(Finalize)(i64*, i64*)");
         TLO |= "call void " | Finalize |
            "(i64* %_Context, i64* %_Local_Area)";
      end if
   end func Finalize_If_Needed

   func Is_Allowed_In_Inlining (Inlined_Routine : Reflection::Routine;
                                Instr : Reflection::Instruction;
                                Doing_Run_Time_Checks : Bool)
     -> Boolean is
     //  Return #true if instruction is permitted in an inlined call
     //  Doing_Run_Time_Checks indicates whether code is being generated
     //  for Check_... instructions
      case Opcode(Instr) of
         [#Exit_Op] =>
            return #false;

         [#Call_Op] =>
            //  Ok unless is calling a nested block or a locked/qeueud op
            case Instr.Static_Link().Base() of
               [Local_Area |
                Enclosing_Local_Areas.First .. Enclosing_Local_Areas.Last] =>
                  return #false;  //  TBD -- uplevel references
               [..] =>
                  //  OK unless is locked/queued.
                  return Instr.Locked_Param_Info() == 0;
            end case

         [#Indirect_Call_Op] =>
            return #true;  // OK?

         [#Call_Nested_Block_Op] =>
            return #false;  //  TBD -- uplevel references

         [#Check_Nested_Block_Op] =>
            --  Ok if not doing run-time checks
            return not Doing_Run_Time_Checks;
            //  TBD -- could support if can handle uplevel references

         [#Start_Parallel_Op      |
          #Add_Parallel_Op        |
          #Wait_For_Parallel_Op   |
          #Start_Parallel_Call_Op |
          #Add_Parallel_Call_Op   |
          #Create_Tcb_Op          |
          #Prepare_To_Exit_Parallel_Op] =>
            return #false;  //  No parallel blocks

         [#Begin_Nested_Block_Op] =>
            return #false;  //  TBD -- uplevel references

         [#Store_Address_Op] =>
            //  Don't allow storing the address of an input parameter
            //  TBD: We could probably allow it by making a copy
            const Src_Locator := Instr.Source();

            if Src_Locator.Base() != Param_Area then
               //  Not a parameter, should not be a problem
               return #true;
            elsif Src_Locator.Offset() != 0 then
               //  Is an input parameter, definitely a problem
               return #false;
            else
               //  Not a problem if (Param_Area, 0) refers to an output
               return Parameters(Inlined_Routine)[1].Is_Operation_Output;
            end if

         [#Store_Operation_Desc_Op] =>
            //  Creates problems if enclosing frame is inlined
            return #false;

         [..] =>
            return #true;  // Everything else is OK
      end case
   end func Is_Allowed_In_Inlining

   func Compile_One_Instr
     (Operation_Routine : Reflection::Routine;
      var TLO : LLVM_Top_Level_Op;
      Func_Node : LLVM_Func_Node_Id;
      I : Code_Index;
      var Look_Ahead_Count : Int;
      var OCS : Op_Comp_State) is
      //  This function compiles one (or more) PSVM instruction(s) to LLVM
      //  TLO is the LLVM accumulator in use
      //  TLO.TLO_T is the Per_TLO_Table for Type Descriptors
      //  TLO.TLO_S is the Per_TLO_Table for Strings
      //  I is the instruction index
      //  On return, Look_Ahead_Count is the number of additional instructions
      //  that have already had code generated for them due to lookahead.

      Look_Ahead_Count := 0;  //  By default, no lookahead is performed.

      const Num_Instrs_In_Routine := Operation_Routine.Num_Instrs();
      const Instr := Operation_Routine.Nth_Instr(I);

      //  Get type descriptor for current-inst of enclosing module
      //  NOTE that this type descriptor might not be fully instantiated
      //       (that is, "All_Parameters_Known" might be false).
      const Enc_Type_Desc := Operation_Routine.Enc_Type_Desc();

      //  Produce a unique suffix to attach to all LLVM reg names
      const UI : String := OCS.Inline_Stack.Is_Empty()?
                             To_String(I) :
                             OCS.Inline_Stack.Top().Unique_Inline_Id | "." | I;
                           
      const Instr_In_Nested_Block := TLO.In_Nested_Block(I);

      const Stg_Rgn_Is_Available : Boolean :=
         //  #true if there is a storage region associated with the
         //  current routine or nested block, ignoring any inlining.
         OCS.Inline_Stack.Is_Empty()?
           (not Instr_In_Nested_Block
               and then Operation_Routine.Uses_Stg_Rgn())
             or else TLO.Block_Uses_Rgn(I) :
           OCS.Inline_Stack.Top().Stg_Rgn_Is_Available;

      const Formal_Params := Instr_In_Nested_Block? null :
                                Parameters(Operation_Routine);

      const Has_Output_Param := Formal_Params not null
                               and then |Formal_Params| > 0
                               and then Formal_Params[1].Is_Operation_Output;

      const Formal_Params_In_Regs := not Instr_In_Nested_Block
        and then Pass_Params_In_Regs[Convention(Operation_Routine)];
         //  Indicates whether params to current routine were passed in regs

      const Context_Is_Formal_Param := Instr_In_Nested_Block
        or else Pass_Context_Param[Convention(Operation_Routine)];
         //  Indicates whether context passed to current routine

      //  Dereferences the static link N times
      //  Puts code into TLO and returns the llvm identifier
      //  that holds the requested pointer
      func Follow_Static_Link(N : Int; UID : String)
         -> String is
         //  dereference Static Link N times
         var Prev := "%_Static_Link";
         var Ptr  := "%_Static_Link";
         for J in 0 ..< N forward loop
            //  uniques for each loop iteration
            const Ptr_Val := "%_ptr_val`(J)_" | UID;
            Ptr           := "%_ptr"     | J | "_" | UID;

            //  Load then cast to pointer
            TLO |= Ptr_Val | " = load i64, i64* " | Prev;
            TLO |= Ptr | " = inttoptr i64 `(Ptr_Val) to i64*";
            Prev := Ptr;
         end loop
         return Ptr;
      end func Follow_Static_Link

      var Cached_Current_Type_Desc : optional String := null;
        //  Prior result of calling Current_Type_Desc, if any

      func Current_Type_Desc(UID : String) -> String is
         //  Get LLVM register that contains the nearest enclosing
         //  type descriptor for the current instr, taking inlining
         //  into account.

         if Cached_Current_Type_Desc is null then
            //  Not already computed, so re-compute result
            if OCS.Inline_Stack.Is_Empty() then
               //  We are not currently in the middle of an inline
               //  but we might be in a nested context, so
               //  emit code to follow the static link as necessary.
               const Block_Level := TLO.Block_Nested_Level(I);
               const Nested_Level := Block_Level not null?
                  Block_Level : Operation_Routine.Nesting_Level();

               Cached_Current_Type_Desc :=
                 Follow_Static_Link(Nested_Level, UID);
            else
               //  We are inside an inline.  No further nesting
               //  is supported.  Just return the static-link reg
               //  chosen at the time of the inlining.
               Cached_Current_Type_Desc :=
                 OCS.Inline_Stack.Top().Type_Desc_Name;
            end if
         end if;

         //  Return computed result
         return Cached_Current_Type_Desc;
      end func Current_Type_Desc

      func VM_Frame_Offset (Locator : Reflection::Object_Locator)
        -> optional Reflection::Offset_Within_Area is
        //  Return the frame offset where the VM register or reg param
        //  identified in the Locator is stored for up-level access.
        //  Return null if no VM_Frame_Offset available

         const Base_Of_Loc := Base(Locator)

         case Base_Of_Loc of
          [Enclosing_Local_Areas.First .. Enclosing_Local_Areas.Last] =>

            const Level_Diff := Base_Of_Loc - Enclosing_Local_Areas.First;
            const Enclosing_Func_Node :=
              Ancestor(TLO.LLVM_Func_Tree, OCS.Cur_Node, Level_Diff);
            const Num := VM_Num(Locator);

            //  Just retrieve from the VM_Frame_Offsets mapping
            if Enclosing_Func_Node not in TLO.VM_Frame_Offsets
              or else Num not in
                TLO.VM_Frame_Offsets[Enclosing_Func_Node]
            then
               return null
            end if

            return TLO.VM_Frame_Offsets[Enclosing_Func_Node][Num]

          [Enclosing_Param_Areas.First .. Enclosing_Param_Areas.Last] =>
            const Level_Diff := Base_Of_Loc - Enclosing_Param_Areas.First;
            const Enclosing_Func_Node :=
              Ancestor(TLO.LLVM_Func_Tree, OCS.Cur_Node, Level_Diff);
            const Offs := Offset(Locator);

            if Enclosing_Func_Node is null then
               Put_Error("No enclosing node found for" | Locator,
                 Instr.Source_Pos(), Message_Kind => "Warning");
               return null
            end if

            //  Just retrieve from the VM_Param_Frame_Offsets mapping
            if Enclosing_Func_Node not in TLO.VM_Param_Frame_Offsets
              or else Offs not in
                TLO.VM_Param_Frame_Offsets[Enclosing_Func_Node]
            then
               return null
            end if

            return TLO.VM_Param_Frame_Offsets[Enclosing_Func_Node][Offs]

          [Param_Area] =>
            const Offs := Offset(Locator);

            if OCS.Cur_Node not in TLO.VM_Param_Frame_Offsets
              or else Offs not in
                TLO.VM_Param_Frame_Offsets[OCS.Cur_Node]
            then
               return null
            end if

            return TLO.VM_Param_Frame_Offsets[OCS.Cur_Node][Offs]
          [..] => {#false};
         end case
      end func VM_Frame_Offset

      func VM_Reg_Name(RNum : Reflection::VM_Reg_Num) -> String
        is (RNum >= Formal_Param_VM_Num_Base?
              "%_formal_param_" | RNum - Formal_Param_VM_Num_Base :
              "%_loc_" | RNum);
        
      func Adjusted_Reg_Name(RNum : Reflection::VM_Reg_Num;
                             Inline_Info : Inline_Info_Type) -> String
        //  Add in unique-inline ID
        is ("%_loc_`(Inline_Info.Unique_Inline_Id)_" | RNum);

      func Get_Adjusted_VM_Num_And_Name
        (Locator : Reflection::Object_Locator;
         var VM_Num : Reflection::VM_Reg_Num;
         var VM_Name : String) is
        //  Return num and name for VM register, given Locator.
        //  Handle special case of input parameters to inline
        //  and unique numbering/naming for inlined-code VM registers.

         const Num := VM_Num(Locator);

         if OCS.Inline_Stack.Is_Empty() then
            //  Not in an inline; see whether params in registers
            if Locator.Base() == Param_Area
              and then Formal_Params_In_Regs
              and then
                not Formal_Params[Offset(Locator)+1].
                                                Is_Operation_Output
            then
               //  Input formal Parameters in registers
               {*formal_param_VM_Num_not_0* Num == 0}

               VM_Num := Formal_Param_VM_Num (Offset(Locator));
               VM_Name := VM_Reg_Name(VM_Num);
            else
               //  Nothing special, or the output param
               VM_Num := Num;
               VM_Name := VM_Reg_Name(Num);
            end if
         elsif Num == 0 then
            if Locator.Base() == Param_Area
              and then not OCS.Inline_Stack.Top().Is_Output_Param(Locator)
            then
               //  We have an input param, replace with appropriate register.
               const Param_Num := VM_Param_Num
                      (OCS.Inline_Stack.Top().Param_Locator, Locator.Offset());

               if |OCS.Inline_Stack| > 1 then
                  //  Adjust register if in a nested inline
                  VM_Num := Param_Num + OCS.Inline_Stack[1].VM_Reg_Adjustment;
                  VM_Name := Adjusted_Reg_Name(Param_Num, OCS.Inline_Stack[1]);
               else
                  //  Caller was not itself in an inline.
                  VM_Num := Param_Num;
                  VM_Name := VM_Reg_Name(Param_Num);
               end if
            else
               //  Not in a VM register
               VM_Num := 0;
               VM_Name := "";
            end if
         else
            //  Local var of inlined routine
            VM_Num := Num + OCS.Inline_Stack.Top().VM_Reg_Adjustment;
            VM_Name := Adjusted_Reg_Name(Num, OCS.Inline_Stack.Top());
         end if;
      end func Get_Adjusted_VM_Num_And_Name

      func Adjusted_VM_Num(Locator : Reflection::Object_Locator)
        -> Reflection::VM_Reg_Num is
        //  Return num for VM register, given Locator.
        //  Handle special case of input parameters to inline
        //  and unique numbering for inlined-code VM registers.
         var Num : Reflection::VM_Reg_Num := 0;
         var Name : String := "";

         Get_Adjusted_VM_Num_And_Name(Locator, Num, Name);
         return Num;
      end func Adjusted_VM_Num

      func Adjusted_VM_Name(Locator : Reflection::Object_Locator) -> String is
        //  Return name for VM register, given Locator.
        //  Handle special case of input parameters to inline
        //  and unique naming for inlined-code VM registers.
         var Num : Reflection::VM_Reg_Num := 0;
         var Name : String := "";

         Get_Adjusted_VM_Num_And_Name(Locator, Num, Name);
         {Num > 0}

         return Name;
      end func Adjusted_VM_Name

      func Adjusted_VM_Param_Num
        (Locator : Reflection::Object_Locator;
         Param_Offset : Reflection::Offset_Within_Area)
        -> Reflection::VM_Reg_Num is
         const Num := VM_Param_Num(Locator, Param_Offset);
         if Num == 0 or else OCS.Inline_Stack.Is_Empty() then
            return Num;
         else
            return Num + OCS.Inline_Stack.Top().VM_Reg_Adjustment;
         end if;
      end func Adjusted_VM_Param_Num

      func Adjusted_VM_Param_Name
        (Locator : Reflection::Object_Locator;
         Param_Offset : Reflection::Offset_Within_Area) -> String is
         const Num := VM_Param_Num(Locator, Param_Offset);
         {Num > 0}

         if OCS.Inline_Stack.Is_Empty() then
            return VM_Reg_Name(Num);
         else
            return Adjusted_Reg_Name(Num, OCS.Inline_Stack.Top());
         end if;
      end func Adjusted_VM_Param_Name

      func Set_VM_Reg_Is_Ptr (Reg : Reflection::VM_Reg_Num) is
        //  Remember that given VM Reg is a pointer
         OCS.VM_Ptr_Regs |= Reg;
      end func Set_VM_Reg_Is_Ptr;

      func VM_Reg_Is_Ptr (Reg : Reflection::VM_Reg_Num)
        -> Boolean is
        //  Indicate whether given VM Reg is a pointer
         return Reg in OCS.VM_Ptr_Regs;
      end func VM_Reg_Is_Ptr;

      func Set_VM_Reg_Val
        (Reg : String; Val : optional Univ_Integer) is
        //  Record the known value stored in a VM reg name
        //  if non-null.
         if Val not null then
            OCS.VM_Reg_Vals[Reg] := Val;
         end if;
      end func Set_VM_Reg_Val;

      func VM_Reg_Val (Reg : String)
        -> optional Univ_Integer is
        //  Return the known value stored in a VM reg name, if any
         return (if Reg in OCS.VM_Reg_Vals then OCS.VM_Reg_Vals[Reg] else null)
      end func VM_Reg_Val;

      func Set_VM_Reg_Type_Desc
        (Reg : String; Type_Desc : optional Reflection::Type_Descriptor) is
        //  Record the known type descriptor stored in a VM reg name
        //  if non-null.
         if Type_Desc not null then
            OCS.VM_Reg_Type_Descs[Reg] := Type_Desc;
            if Debug_VM_Reg_Info_Prop then
               Put_Error("`(Name(Type_Desc)) now in reg `(Reg)",
                 Instr.Source_Pos(), Message_Kind => "Info");
            end if
         end if;
      end func Set_VM_Reg_Type_Desc;

      func VM_Reg_Type_Desc (Reg : String)
        -> optional Reflection::Type_Descriptor is
        //  Return the known type descriptor stored in a VM reg name, if any
         return (Reg in OCS.VM_Reg_Type_Descs?
                   OCS.VM_Reg_Type_Descs[Reg] : null)
      end func VM_Reg_Type_Desc;

      func Set_VM_Reg_Is_For_Local
        (Reg : String; Is_For_Local : Boolean := #true) is
        //  Specify whether VM Reg name is for a local object.
         if Is_For_Local then
            OCS.VM_Regs_For_Local_Objs |= Reg;
            if TLO.Use_Stack_For_Objects then  //  TBD
               if Debug_VM_Reg_Info_Prop then
                  Put_Error(Reg | " is for local obj",
                    Instr.Source_Pos(), Message_Kind => "Info");
               end if;
            end if;
         else
            if #false and then TLO.Use_Stack_For_Objects then  // TBD
               if Debug_VM_Reg_Info_Prop then
                  Put_Error(Reg | " is *not* for local obj",
                    Instr.Source_Pos(), Message_Kind => "Info");
               end if;
            end if;
         end if;
      end func Set_VM_Reg_Is_For_Local;

      func VM_Reg_Is_For_Local (Reg : String) -> Boolean is
        //  Indicate whether VM Reg name is for a local object.
         return Reg in OCS.VM_Regs_For_Local_Objs;
      end func VM_Reg_Is_For_Local;

      func Is_Inlined_Input_Param (Loc : Reflection::Object_Locator)
        -> Boolean is
         return #false;  //  TBD
      end func Is_Inlined_Input_Param

      //  Get the physical address corresponding to the given locator
      //  If used multiple times in one PSVM instruction,
      //    pass unique UID_Extras for each call
      func Get_Locator_Ptr(Locator : Reflection::Object_Locator;
         Gets : String;
         UID_Extra : Int := 0) is

         func Bad_Locator(Bad_Loc : Reflection::Object_Locator;
                          Msg : String := "Bad Locator") is
            var IO := IO::Get_IO();
            Put_Error("In Get_Locator_Ptr, " |
              Msg | ":" | Bad_Loc, Instr.Source_Pos());
            PSC::Debugging::Dump_One_Instr
              (IO.Stderr, Instr, Indent => 4);
         end func Bad_Locator

         const UID := UI | "_" | UID_Extra;

         const B := Locator.Base()
         const Off := Offset(Locator);

         case B of
            [Zero_Base] =>
               if Offset(Locator) == 0 then
                  TLO |= Gets | " = getelementptr i64, i64* null, i64 0";
               else
                  Bad_Locator(Locator, "Non-null Zero_Base");
                  {#false}
               end if

            [Local_Area] =>
               if Locator.VM_Is_Component() then
                  //  We (probably) have a reference to a component
                  //  of a TCB.  Assume VM_Num() is i64*
                  {not Locator.VM_Is_Indir()}
                  TLO |= Gets | " = getelementptr i64, i64* " |
                    Adjusted_VM_Name(Locator) | ", i64 " |
                    Locator.VM_Component_Offset();
               elsif Locator.VM_Is_Indir() then
                  //  VM_Name is an address
                  const Loc_Reg_Name := Adjusted_VM_Name(Locator);

                  TLO |= Gets | " = bitcast i64* `(Loc_Reg_Name) to i64* ";
                  //  Propagate both ways whether is for a local obj
                  if VM_Reg_Is_For_Local (Loc_Reg_Name) then
                     Set_VM_Reg_Is_For_Local (Gets);
                  elsif VM_Reg_Is_For_Local (Gets) then
                     Set_VM_Reg_Is_For_Local (Loc_Reg_Name);
                  end if;
               elsif Off < Master_Offset_In_Words then
                  //  Up to the master offset, we allow use of the
                  //  original Local_Area addressing scheme.
                  TLO |= Gets |
                    " = getelementptr i64, i64* %_Local_Area, i64 " |
                    Off;
               elsif Off == Master_Offset_In_Words then
                  //  In the PSVM, the master is directly in the stack.
                  //  In the LLVM, it is through a level of indirection.
                  TLO |= Gets | " = bitcast i64* %_Master to i64*"
               else
                  //  No load/store should be performed to this local var.
                  Bad_Locator(Locator, "Load/Store from Local_Area");
                  {#false}
               end if

            [Param_Area] =>
               //  Handle stack, inlined, and reg parameters
               if not OCS.Inline_Stack.Is_Empty() then
                  //  Parameters are handled specially
                  //  when inlining.
                  if OCS.Inline_Stack.Top().Is_Output_Param(Locator) then
                     //  Output parameter has an address
                     const Output_Reg_Name :=
                       OCS.Inline_Stack.Top().Output_Param_Name();

                     TLO |= Gets | " = bitcast i64* " |
                       Output_Reg_Name | " to i64*";

                     //  Propagate both ways whether is for a local obj
                     if VM_Reg_Is_For_Local (Output_Reg_Name) then
                        Set_VM_Reg_Is_For_Local (Gets);
                     elsif VM_Reg_Is_For_Local (Gets) then
                        Set_VM_Reg_Is_For_Local (Output_Reg_Name);
                     end if;
                  else
                     //  Input parameters do not have an address.
                     Bad_Locator(Locator, "Address of Inlined Input Param");
                     {#false}
                  end if
               else
                  if Formal_Params_In_Regs
                    and then (not Has_Output_Param or else Off > 0)
                  then
                     //  Input parameters don't have addresses
                     //  Needs to have been copied into a memory cell.
                     const VM_Off := VM_Frame_Offset(Locator);
                     
                     if VM_Off is null then
                        Bad_Locator(Locator, "Address of Register Param");
                     else
                        //  Reg-param has been copied into Local_Area
                        TLO |= Gets |
                          " = getelementptr i64, i64* %_Local_Area, i64 " |
                            VM_Off;
                     end if;
                  else
                     //  Not a register param
                     TLO |= Gets |
                        " = getelementptr i64, i64* %_Param_Area, i64 " | Off;
                  end if
               end if;

            [Const_Area] =>
               //  Compile time known Constants are streamed 
               //  and rebuilt like type descriptors and strings
               const Info :=
                 Reflection::Const_Info::Const_Info_At_Locator(Locator);
               var Name := Info.Name;
               if Name not null and then Name != "" then
                  //  A named constant
                  Name := Make_Link_Name(Name);  // This surrounds with "..."
                  TLO.Declare_Const(Name[1 <..< |Name|]); // strip the "..."
                  Name := '@' | Name;
               else
                  //  An anonymous constant
                  const Const_Index :=
                    TLO.Decl_Anon_Const(Locator, Info);
                  Name := "@$Anon_Const_`(TLO.TLO_Index)_" | Const_Index
               end if;
               TLO |= Gets | " = getelementptr i64, i64* `(Name), i64 0";

            [Enclosing_Param_Areas.First .. Enclosing_Param_Areas.Last] =>
               //  TBD: Handle up-level parameters more efficiently at
               //       some point?
               //  dereference Static Link (Base - First - 1) times
               //  then follow 1st ptr to param area

               {OCS.Inline_Stack.Is_Empty()}
                 //  Nesting not allowed in an inline

               const Num_Derefs := B - 1 - Enclosing_Param_Areas.First;
               const Ptr := Follow_Static_Link(Num_Derefs, UID);

               const VM_Off := VM_Frame_Offset(Locator);

               if VM_Off is null then
                  //  Param not passed in a register
                  const Encl_Param_Ptr    := "%_encl_param_ptr"    | UID;
                  const Encl_Param        := "%_encl_param"        | UID;
                  const Encl_Param_As_Ptr := "%_encl_param_as_ptr" | UID;
                  TLO |= Encl_Param_Ptr | " = getelementptr i64, i64* " |
                      Ptr | ", i64 1";
                  TLO |= Encl_Param | " = load i64, i64* " | Encl_Param_Ptr;
                  TLO |= Encl_Param_As_Ptr | " = inttoptr i64 " | Encl_Param |
                      " to i64*";
                  TLO |= Gets | " = getelementptr i64, i64* " |
                                      Encl_Param_As_Ptr | ", i64 " | Off;
               else
                  //  Get address of up-level register parameter, stored in
                  //  frame record.
                  TLO |= Gets |
                    " = getelementptr i64, i64* `(Ptr), i64 " | VM_Off;
               end if

            [Enclosing_Local_Areas.First .. Enclosing_Local_Areas.Last] => 
               //  dereference the static link (Base - First - 1) times

               {OCS.Inline_Stack.Is_Empty()}
                  //  Nesting not allowed in an inline

               const Ptr := Follow_Static_Link(B - 1 -
                  Enclosing_Local_Areas.First, UID);

               if Adjusted_VM_Num(Locator) > 0 then
                  const VM_Off := VM_Frame_Offset(Locator);
                  if VM_Off is null then
                     Bad_Locator(Locator, "No VM_Frame_Offset for locator")
                     {#false}
                     return
                  end if
                  if Locator.VM_Is_Indir() then
                     //  Get address of up-level local variable, stored in
                     //  frame record.
                     const Encl_Local_Ptr_Ptr := "%_encl_local_ptr_ptr" | UID;
                     const Encl_Local_Ptr     := "%_encl_local_ptr"     | UID;
                     TLO |= Encl_Local_Ptr |
                       " = getelementptr i64, i64* `(Ptr), i64 " | VM_Off;
                     TLO |= Encl_Local_Ptr_Ptr | " = bitcast i64* " |
                       Encl_Local_Ptr | " to i64**";
                     TLO |= Gets | " = load i64*, i64** " | Encl_Local_Ptr_Ptr;
                  else
                     //  Get address of up-level local constant, stored in
                     //  frame record.
                     TLO |= Gets |
                       " = getelementptr i64, i64* `(Ptr), i64 " | VM_Off;
                  end if
               elsif Off < Master_Offset_In_Words then
                  //  Up to the master offset, we allow use of the
                  //  original Local_Area addressing scheme.
                  TLO |= Gets |
                    " = getelementptr i64, i64* `(Ptr), i64 " | Off;
               elsif Off == Master_Offset_In_Words then
                  //  In the PSVM, the master is directly in the stack.
                  //  In the LLVM, it is through a level of indirection.
                  const Encl_Local_Ptr_Ptr := "%_encl_local_ptr_ptr" | UID;
                  const Encl_Local_Ptr     := "%_encl_local_ptr"     | UID;
                  TLO |= Encl_Local_Ptr |
                    " = getelementptr i64, i64* `(Ptr), i64 " | Off;
                  TLO |= Encl_Local_Ptr_Ptr | " = bitcast i64* " |
                    Encl_Local_Ptr | " to i64**";
                  TLO |= Gets | " = load i64*, i64** " | Encl_Local_Ptr_Ptr;
               else
                  //  Missing a VM_Num
                  Bad_Locator(Locator, "Missing a VM_Num");
                  {#false}
               end if

            [Enclosing_Type_Areas.First .. Enclosing_Type_Areas.Last |
             Type_Area] =>
               //  Get type descriptor, following static link as necessary.
               const TDesc := Current_Type_Desc(UID);

               //  Get Nth item from type descriptor
               Type_Desc_LLVM_Utils::Get_Nth_Type_Area_Item_Physical_Address
                 (TLO, Gets, TDesc, Locator);
            
            [Base_Registers.First .. Base_Registers.Last |
             Phys_Base_Registers.First .. Phys_Base_Registers.Last] => 
               //  Base registers store a virtual address in the local area
               //  Phys do the same thing but with a physical address
               const Reg         := "%_reg"         | UID;

               const Is_Component := Locator.VM_Is_Component();
               const Is_Indir := Locator.VM_Is_Indir();

               //  These should either be a component or be indirect
               if not (Is_Component or Is_Indir) then
                   Println(" ** VM_Is_Component() = " |
                     Is_Component | ", VM_Is_Indir = " |
                     Is_Indir | " in `(Locator) at " |
                     Instr.Source_Pos() | ", Instr #" | I);
               end if

               { Is_Component or Is_Indir }

               const Extra_Indir := Is_Component and Is_Indir;

               const Ptr_Type_Sig := Extra_Indir? "i64**" : "i64*";
               const VM_Off := Is_Component? Locator.VM_Component_Offset() : 0;
               const Locator_VM_Num := Adjusted_VM_Num(Locator);
               const Locator_VM_Name := Adjusted_VM_Name(Locator);

               if B in Phys_Base_Registers then
                  //  VM_Name should already be an i64* for Phys_Base_Register
                  if not VM_Reg_Is_Ptr (Locator_VM_Num) then
                     Bad_Locator(Locator,
                       "VM Reg `(Locator_VM_Num) not a ptr");
                     const Fail := Locator_VM_Num / 0;
                  end if

                  {VM_Reg_Is_Ptr (Locator_VM_Num)}

                  TLO |= Reg | " = bitcast i64* " | Locator_VM_Name |
                    " to " | Ptr_Type_Sig;
               elsif Virt_Is_Phys then
                  //  VM_Name is an i64 for Base_Register; copy and convert
                  if VM_Reg_Is_Ptr (Locator_VM_Num) then
                     Bad_Locator(Locator,
                       "VM Base Reg `(Locator_VM_Num) is a ptr");
                  end if

                  {not VM_Reg_Is_Ptr (Locator_VM_Num)}

                  TLO |= Reg | " = inttoptr i64 " | Locator_VM_Name |
                    " to " | Ptr_Type_Sig;
               else
                  //  VM_Name is an i64, pass to large-obj-addr
                  {not Extra_Indir}  //  TBD: We don't handle this currently
                  const Convert := "@_psc_large_obj_addr";
                  TLO.Declare(Convert, "i64* `(Convert)(i64)");
                  TLO |= Reg | " = call i64* `(Convert)(i64 " |
                     Locator_VM_Name | ")";
               end if

               if Extra_Indir then
                  //  One more level of indirection required
                  const Reg_Ptr := "%_reg_ptr" | UID;

                  TLO |= Reg_Ptr | " = getelementptr i64*, i64** " | Reg |
                    ", i64 " | VM_Off;
                  TLO |= Gets | " = load i64*, i64** " | Reg_Ptr;
               else
                  TLO |= Gets | " = getelementptr i64, i64* " | Reg |
                    ", i64 " | VM_Off;
               end if

            [..] =>
               Bad_Locator(Locator, "Bad locator base");
               {#false}
         end case;
      end func Get_Locator_Ptr

      //  Load from the physical address corresponding to the given locator
      //  Result is in Val register.  Address (after extra indirs) is in Addr.
      //  Addr can be used later in Store_Indir, but only if object is a
      //  variable.  If object is a local constant, Addr will not be defined.
      //  if Num_Indir > 0, then perform that many levels of indirection.
      //  if Ptr_Level > 0, then result should be a pointer rather than an int,
      //    of type "i64*" for Ptr_Level == 1, "i64**" for Ptr_Level == 2, etc.
      //  If Get_Locator_Ptr, Load_Via_Locator, or Store_Via_Locator are
      //    used multiple times in one PSVM instruction,
      //    pass unique UID_Extras for each call
      func Load_Via_Locator(Locator : Reflection::Object_Locator;
         Addr, Val : String;
         Num_Indir : Int := 0;
         Ptr_Level : Int := 0;
         UID_Extra : Int := 0) is

         //  We want to return an object of type "i64" | Ptr_Level * "*"
         const Type_Sig := "i64" | Ptr_Level * "*";

         const Locator_VM_Num := Adjusted_VM_Num(Locator);

         const Is_Local_Const :=
           Locator_VM_Num != 0
             and then not Locator.VM_Is_Indir() 
             and then not Locator.VM_Is_Component()
             and then Locator.Base() not in Enclosing_Local_Areas;

         if Is_Local_Const and then Num_Indir == 0 then
            //  Special case of retrieving the value of a local constant
            //  NOTE: Addr is not initialized!
            const Locator_VM_Name := Adjusted_VM_Name(Locator);

            if Ptr_Level > 0 then
               if not VM_Reg_Is_Ptr (Locator_VM_Num) then
                  //  VM reg not a pointer, use inttoptr to turn it into one.
                  TLO |= Val | " = inttoptr i64 " | Locator_VM_Name |
                    " to " | Type_Sig;
               else
                  //  Reg already a pointer, use bitcast to convert as needed.
                  TLO |= Val | " = bitcast i64* " | Locator_VM_Name |
                    " to " | Type_Sig;
               end if
            elsif VM_Reg_Is_Ptr (Locator_VM_Num) then
               //  Use ptr-to-int to convert and copy from register
               TLO |= Val | " = ptrtoint i64* " | Locator_VM_Name |
                 " to i64";
            else
               //  Use bitcast to copy from register
               TLO |= Val | " = bitcast i64 " | Locator_VM_Name |
                 " to i64";
               //  Propagate known value, if any
               Set_VM_Reg_Val (Val, VM_Reg_Val (Locator_VM_Name));
            end if
            //  Propagate whether is for local obj
            Set_VM_Reg_Is_For_Local (Val,
                                     VM_Reg_Is_For_Local (Locator_VM_Name));
         else
            if Num_Indir > 0 then
               //  Recurse to load all but last level
               Load_Via_Locator(Locator, Addr | "X", Addr,
                 Num_Indir-1, Ptr_Level+1, UID_Extra*10+1)
            elsif Ptr_Level > 0 then
               //  Get address into Addr_Orig
               const Addr_Orig := Addr | "_Orig"
               Get_Locator_Ptr(Locator, Addr_Orig, UID_Extra);
               //  Convert result of Get_Locator_Ptr to proper type
               TLO |= Addr | " = bitcast i64* " |
                 Addr_Orig | " to `(Type_Sig)*";

               //  Propagate whether is for local obj
               Set_VM_Reg_Is_For_Local (Val,
                                        VM_Reg_Is_For_Local (Addr_Orig));
            else
               //  Get address into Addr
               Get_Locator_Ptr(Locator, Addr, UID_Extra);

               //  Propagate whether is for local obj
               Set_VM_Reg_Is_For_Local (Val,
                                        VM_Reg_Is_For_Local (Addr));
            end if

            //  Last load is into "Val" from "Addr"
            TLO |= Val | " = load `(Type_Sig), " |
                Type_Sig | "* " | Addr;
         end if

      end func Load_Via_Locator

      func Load_Call_Param (Param_Offset : Reflection::Offset_Within_Area;
         Val : String;
         Num_Indir : Int := 0;
         Ptr_Level : Int := 0;
         UID_Extra : Int := 0) is
        //  Load the call parameter which has been evaluated into the
        //  appropriate "slot" in the stack, or the appropriate VM reg,
        //  into the VM reg identified by Val.
         const Param_Addr := Instr.Params()

         //  We want to return an object of type "i64" | Ptr_Level * "*"
         const Type_Sig := "i64" | Ptr_Level * "*";

         if Num_Indir == 0 then
            //  Special case of retrieving the value of a local constant
            //  NOTE: Addr is not initialized!
            const Param_Reg_Name := 
              Adjusted_VM_Param_Name(Param_Addr, Param_Offset);

            if Ptr_Level > 0 then
               if not VM_Reg_Is_Ptr
                     (Adjusted_VM_Param_Num(Param_Addr, Param_Offset))
               then
                  //  Use inttoptr to copy from register
                  TLO |= Val | " = inttoptr i64 " |
                    Param_Reg_Name | " to " | Type_Sig;
               else
                  //  Use bitcast to convert to proper ptr type
                  TLO |= Val | " = bitcast i64* " |
                    Param_Reg_Name | " to " | Type_Sig;
               end if
            else
               //  Use bitcast to copy from register
               TLO |= Val | " = bitcast i64 `(Param_Reg_Name) to i64";

               //  Propagate known value, if any
               Set_VM_Reg_Val (Val, VM_Reg_Val (Param_Reg_Name))
            end if
            //  Propagate whether is for local obj
            Set_VM_Reg_Is_For_Local (Val, VM_Reg_Is_For_Local(Param_Reg_Name));
         else
            //  Recurse to load all but last level
            const Addr := Val | "_ptr"
            Load_Call_Param(Param_Offset,
              Val => Addr,
              Num_Indir => Num_Indir-1, Ptr_Level => Ptr_Level+1,
              UID_Extra => UID_Extra*10+1)

            //  Last load is into "Val" from "Addr"
            TLO |= Val | " = load `(Type_Sig), " |
               Type_Sig | "* " | Addr;
         end if

      end func Load_Call_Param

      func Load_Call_Var_Param (Param_Offset : Reflection::Offset_Within_Area;
         Addr, Val : String;
         Ptr_Level : Int := 0;
         UID_Extra : Int := 0) is
        //  Load the call parameter whose address has been stored into the
        //  appropriate "slot" in the stack, or the appropriate VM reg,
        //  into the VM reg identified by Addr, and then fetch its value into
        //  Val.

         Load_Call_Param (Param_Offset, Val => Addr,
           Num_Indir => 0, Ptr_Level => Ptr_Level+1,
           UID_Extra => UID_Extra*10 + 1)
         //  Last load is into "Val" from "Addr"
         TLO |= Val | " = load i64`(Ptr_Level * "*"), i64" |
           (Ptr_Level+1) * "*" | " " | Addr;

         //  Propagate whether is for local obj
         Set_VM_Reg_Is_For_Local (Val, VM_Reg_Is_For_Local(Addr));
      end func Load_Call_Var_Param

      //  Store into the physical address corresponding to the given locator
      //  If Ptr_Level > 0, then Val is presumed to be of
      //    type i64 | Ptr_Level*"*", and Addr needs to be bitcast to
      //    one more level of pointer after calling Get_Locator_Ptr.
      //  If initializing a local-area constant, then it is presumed
      //  that type of constant is i64* if Ptr_Level > 0.
      //  If Get_Locator_Ptr, Load_Via_Locator, or Store_Via_Locator are
      //    used multiple times in one PSVM instruction,
      //    pass unique UID_Extras for each call
      //  Instr_Look_Ahead is used when we are looking ahead at a later instr
      func Store_Via_Locator(Locator : Reflection::Object_Locator;
         Addr, Val : String;
         Ptr_Level : Int := 0;
         UID_Extra : Int := 0;
         Instr_Look_Ahead : Int := 0) is

         const Locator_VM_Num := Adjusted_VM_Num(Locator);

         const Is_Local_Const :=
           (Locator.Base() == Local_Area
             or else Locator.Base() in Base_Registers
             or else Locator.Base() in Phys_Base_Registers)
             and then Locator_VM_Num != 0
             and then not Locator.VM_Is_Indir() 
             and then not Locator.VM_Is_Component();

         const Inst := I + Instr_Look_Ahead;  // Adjusted index

         if Is_Local_Const then
            //  Special case -- initializing a local constant
            const Locator_VM_Name := Adjusted_VM_Name(Locator);

            if Ptr_Level > 0 then
               //  Assume VM_Name is i64*, and Val is one of i64*, i64**, ...
               const Type_Sig := "i64" | Ptr_Level * "*"
               TLO |= Locator_VM_Name |
                  " = bitcast `(Type_Sig) `(Val) to i64*";

               //  Remember that this VM reg is a pointer
               Set_VM_Reg_Is_Ptr (Locator_VM_Num);
            else
               //  No type conversion, just use bitcast
               TLO |= Locator_VM_Name | " = bitcast i64 " | Val |
                  " to i64";
               if Val[1] in '0' .. '9' then
                  //  Remember integer value assigned to VM Reg
                  Set_VM_Reg_Val (Locator_VM_Name,
                    Univ_Integer::From_String(Val));
               end if;
            end if
            //  Propagate whether is for local obj
            Set_VM_Reg_Is_For_Local
              (Locator_VM_Name, VM_Reg_Is_For_Local(Val));

            if OCS.Cur_Node in TLO.Uplevels
              and then Locator_VM_Num in TLO.Uplevels[OCS.Cur_Node]
            then
               //  Save value into frame record
               const Off := TLO.VM_Frame_Offsets[OCS.Cur_Node][Locator_VM_Num]
               if Ptr_Level > 0 then
                  //  Assume VM_Name is i64*
                  TLO |= Addr | "_Orig" |
                    " = getelementptr i64, i64* %_Local_Area, i64 " | Off;
                  TLO |= Addr | " = bitcast i64* `(Addr)_Orig to i64**";
                  TLO |= "store i64* `(Locator_VM_Name), i64** " | Addr;
               else
                  TLO |= Addr |
                    " = getelementptr i64, i64* %_Local_Area, i64 " | Off;
                  TLO |= "store i64 `(Locator_VM_Name), i64* " | Addr;
               end if;
            end if
         elsif Ptr_Level == 0 then
            //  Simple case, just store (we have already excluded locals that
            //  can live in a VN).

            //  Propagate whether is for local obj
            Set_VM_Reg_Is_For_Local
              (Addr, VM_Reg_Is_For_Local(Val));

            Get_Locator_Ptr(Locator, Addr, UID_Extra);
            TLO |= "store i64 `(Val), i64* " | Addr;

         else
            //  Bitcast Addr to proper type and then store Val.
            const Addr_Orig := Addr | "_Orig";
            const Type_Sig := "i64" | Ptr_Level * "*"

            //  Propagate whether is for local obj
            Set_VM_Reg_Is_For_Local
              (Addr_Orig, VM_Reg_Is_For_Local(Val));

            Get_Locator_Ptr(Locator, Addr_Orig, UID_Extra);
            TLO |= Addr | " = bitcast i64* `(Addr_Orig) to " |
                   Type_Sig | "*";
            TLO |= "store `(Type_Sig) `(Val), " |
                    Type_Sig | "* " | Addr;
         end if
      end func Store_Via_Locator

      //  Store Val at address Addr, presuming Val is i64, Addr is i64*
      func Store_Indir(Addr, Val : String) is
         //  Store into Addr
         TLO |= "store i64 `(Val), i64* " | Addr;
         //  Propagate whether is for local object
         Set_VM_Reg_Is_For_Local (Addr, VM_Reg_Is_For_Local (Val));
      end func Store_Indir

      //  Store Ptr_Val at address Addr, presuming Ptr_Val and Addr are i64*
      func Store_Ptr_Indir(Addr, Ptr_Val : String) is
         const Addr_Ptr := Addr | "_ptr";

         TLO |= Addr_Ptr | " = bitcast i64* `(Addr) to i64**";
         TLO |= "store i64* `(Ptr_Val), i64** " | Addr_Ptr;

         //  Propagate whether is for local object
         Set_VM_Reg_Is_For_Local (Addr, VM_Reg_Is_For_Local (Ptr_Val));
      end func Store_Ptr_Indir

      func Store_Call_Result
        (Result : String;
         Ptr_Level : Int := 0;
         UID_Extra : Int := 0) is
        //  Store result of evaluating function call into appropriate
        //  "slot" on stack or appropriate VM register as determined
        //  by Instr.Params()
         Store_Via_Locator (Instr.Params(),
                            Addr => Result | "_ptr",
                            Val => Result,
                            Ptr_Level => Ptr_Level,
                            UID_Extra => UID_Extra);
      end func Store_Call_Result

      func Copy_Word(Source, Target : Reflection::Object_Locator;
                     Ptr_Level : Int := 0) is

         const Source_VM_Num := Adjusted_VM_Num(Source);

         //  Check for self copy (no-op).
         if Source_VM_Num != 0
           and then
             Source_VM_Num == Adjusted_VM_Num(Target)
           and then
             Source.VM_Is_Indir() == Target.VM_Is_Indir()
           and then
             not Source.VM_Is_Component()
           and then
             not Target.VM_Is_Component()
           and then
             Source.Base() not in Enclosing_Local_Areas
           and then
             Target.Base() not in Enclosing_Local_Areas
         then
            //  This is a no-op
            return
         end if

         //  unique local variable names
         const SourceID := "%_source" | UI;
         const Source_ValID := "%_source_val" | UI;
         const DestID := "%_dest" | UI;

         //  Read the value at the source
         Load_Via_Locator
           (Source, SourceID, Source_ValID,
              Ptr_Level => Ptr_Level, UID_Extra => 1);

         //  Store the source value into the destination
         Store_Via_Locator
           (Target, DestID, Source_ValID,
              Ptr_Level => Ptr_Level, UID_Extra => 2);
      end func Copy_Word

      func Load_Known_Type_Desc(Gets : String;
         Type_Desc : Reflection::Type_Descriptor;
         UID_Extra : Int := 0) is
         //  Place a pointer to the fully known type descriptor Type_Desc
         //  in the LLVM identifier Gets

         //  Make sure that all parameters are known before
         //  loading a type descriptor into an LLVM register.

         {Type_Desc.All_Parameters_Known()}

         const UID := UI | (UID_Extra == 0? "" : ("_" | UID_Extra));

         const Desc_Ptr_Ptr := "%_desc_ptr_ptr" | UID;
         const Desc_Ptr     := "%_desc_ptr"     | UID;
         const Type_Index := TLO.TLO_T.Get_Local_Index(Type_Desc);
           //  Index into streamed type descriptors

         TLO |= Desc_Ptr_Ptr | " = load i64**, i64*** @$Types";
         TLO |= Desc_Ptr | " = getelementptr i64*, i64** " | 
            Desc_Ptr_Ptr | ", i64 " | Type_Index-1;
         TLO.Ends_With_Type_Index()  //  Remember we used a type index
         TLO |= Gets | " = load i64*, i64** " | Desc_Ptr;

         //  Remember type descriptor associated with VM Reg
         Set_VM_Reg_Type_Desc (Gets, Type_Desc);
      end func Load_Known_Type_Desc;

      func Get_Known_Type_Desc
        (Cur_Type_Desc : optional Reflection::Type_Descriptor;
         Loc : Reflection::Object_Locator) -> Reflection::Type_Descriptor is
        //  Return type descriptor at given locator relative to
        //  current type descriptor
        //  Cur_Type_Desc may be null only if Base(Loc) is Zero_Base.

         case Base(Loc) of
          [Zero_Base] =>
            //  Statically known
            {Offset(Loc) != 0}
            return Reflection::Type_Descriptor::Type_Desc_At_Locator(Loc);

          [Type_Area | Enclosing_Type_Areas.First] =>
            //  Get immediately enclosing type, or some formal/nested type
            //  thereof.
            {Cur_Type_Desc not null}
            case Offset(Loc) of
             [0] =>
               //  Get immediately enclosing type
               return Cur_Type_Desc;

             [Type_Formal_Parameter_Offsets.First + 1 ..
                Type_Formal_Parameter_Offsets.Last] =>
               const Param_Index :=
                 Offset(Loc) - Type_Formal_Parameter_Offsets.First;

               return Parameters(Cur_Type_Desc)[Param_Index].Data.Type_Desc;

             [Type_Nested_Type_Offsets.First + 1 ..
                Type_Nested_Type_Offsets.Last] =>
               const Nested_Index :=
                 Offset(Loc) - Type_Nested_Type_Offsets.First;

               return Nested_Types(Cur_Type_Desc)[Nested_Index];

             [Type_Actual_Of_Formal_Offsets.First + 1 ..
                Type_Actual_Of_Formal_Offsets.Last] =>
               --  Actual of formal
               const Item_Index :=
                 Offset(Loc) - Type_Actual_Of_Formal_Offsets.First;

               return
                 Actuals_Of_Formals(Cur_Type_Desc)[Item_Index].Data.Type_Desc;

             [Corresponding_Polymorphic_Type_Offsets.First ..
               Corresponding_Polymorphic_Type_Offsets.Last] =>
               --  Polymorphic type; recurse with adjusted locator
               return Corresponding_Polymorphic_Type
                 (Get_Known_Type_Desc (Cur_Type_Desc,
                    Loc =>
                      Create(Base => Base(Loc),
                        Offset => Offset(Loc) -
                          Corresponding_Polymorphic_Type_Offsets.First)));

             [..] =>
               //  Not a proper locator for a type
               {*"Get_Known_Type_Desc: Not a proper type locator"* #false}
               return null;

            end case

          [Enclosing_Type_Areas.First + 1 .. Enclosing_Type_Areas.Last] =>
            //  Recurse to get type associated with enclosing type
            {Cur_Type_Desc not null}
            return Get_Known_Type_Desc (Cur_Type_Desc.Enclosing_Type(),
              Loc => Create(Base => Base(Loc) - 1, Offset => Offset(Loc)));

          [..] =>
            //  Not a proper locator for a type
            {*"Get_Known_Type_Desc: Not a proper type locator"* #false}
            return null;
         end case
      end func Get_Known_Type_Desc;

      func Load_Type_Desc(Loc : Reflection::Object_Locator;
         Gets : String;
         TDesc_To_Use : optional Reflection::Type_Descriptor := null;
         UID_Extra : Int := 0) is
         //  Place a pointer to the type descriptor at Loc
         //  in the LLVM identifier Gets
         //  If TDesc_To_Use is non-null, then it represents the type
         //  descriptor to be loaded into Gets at run-time.

         if TDesc_To_Use not null
           and then TDesc_To_Use.All_Parameters_Known()
         then
            //  Special case where fully-instantiated type descriptor
            //  is provided by caller
            //  NOTE: We *must* use it even if the Loc provided has
            //        a "zero" base, because this TDesc_To_Use
            //        may be different if the operation is defined
            //        by equivalence with an operation defined in
            //        a different module (e.g. ".." on Univ_Integer).
            Load_Known_Type_Desc (Gets, TDesc_To_Use, UID_Extra);
            return;  //  All done
         elsif Base(Loc) == Zero_Base then
            //  Special case of "absolute" locator
            if Offset(Loc) == 0 then
               TLO |= Gets | " = getelementptr i64, i64* null, i64 0";
            else
               //  Statically known
               Load_Known_Type_Desc (Gets,
                  Reflection::Type_Descriptor::Type_Desc_At_Locator(Loc),
                  UID_Extra);
            end if
            return;  //  All done

         elsif TDesc_To_Use not null
           and then TDesc_To_Use.All_Parameters_Known()
         then
            //  Special case where fully-instantiated type descriptor
            //  is provided by caller
            Load_Known_Type_Desc (Gets, TDesc_To_Use, UID_Extra);
            return;  //  All done
         end if;

         const UID := UI | (UID_Extra == 0? "" : ("_" | UID_Extra));

         const Cur_Type_Desc_Reg := Current_Type_Desc(UID);
         const Cur_Type_Desc := VM_Reg_Type_Desc (Cur_Type_Desc_Reg);
           //  Type descriptor if known, or null.

         if Cur_Type_Desc not null
           and then Cur_Type_Desc.All_Parameters_Known()
         then
            //  Handle case where cur type desc is fully known at compile time
            Load_Known_Type_Desc (Gets,
              Get_Known_Type_Desc (Cur_Type_Desc, Loc),
              UID_Extra);
            return;  // All done
         end if;

         func Load_Type_Desc_From_Locator() is
            //  Potentially go out of line to get type descriptor or op map
            Type_Desc_LLVM_Utils::Get_Type_Desc_Or_Op_Map
              (TLO, UI, Cur_Type_Desc_Reg, Loc, Desc => Gets);
         end func Load_Type_Desc_From_Locator

         case Base(Loc) of
          [Zero_Base] => {#false} // Handled above

          [Type_Area] =>
            //  Get immediately enclosing type, or some formal/nested type
            //  thereof.
            case Offset(Loc) of
             [0] =>
               //  Get immediately enclosing type
               const TDesc := Cur_Type_Desc_Reg;
               //  Copy pointer to Type Descriptor into Gets
               TLO |= Gets | " = getelementptr i64, i64* `(TDesc), i64 0";
        
               //  Remember type descriptor associated with VM Reg
               Set_VM_Reg_Type_Desc (Gets, Cur_Type_Desc);

             [Type_Formal_Parameter_Offsets.First + 1 ..
                Type_Formal_Parameter_Offsets.Last] =>
               //  Potentially go out of line to get formal type
               Type_Desc_LLVM_Utils::Get_Formal_Type_Or_Op_Map
                 (TLO, UI, Cur_Type_Desc_Reg, Loc, Desc => Gets)

             [Type_Nested_Type_Offsets.First + 1 ..
                Type_Nested_Type_Offsets.Last] =>
               //  Potentially go out of line to get nested type
               Type_Desc_LLVM_Utils::Get_Nested_Type_Or_Op_Map
                 (TLO, UI, Cur_Type_Desc_Reg, Loc, Desc => Gets)

             [..] =>
               //  Use general-purpose out-of-line routine
               Load_Type_Desc_From_Locator()

            end case

          [..] =>
            //  Go out of line to get type descriptor or op map
            Load_Type_Desc_From_Locator()
         end case
      end func Load_Type_Desc

      func Load_Known_Type_Null
        (Cur_Type_Desc : Reflection::Type_Descriptor;
         Gets : String;
         Loc : Reflection::Object_Locator :=
           Create(Base => Type_Area, Offset => 0);
         In_Same_Region_As : optional Reflection::Object_Locator := null)
        -> Boolean is
         //  Put a Null for the type identified by Cur_Type_Desc and Loc,
         //  in same region as object identified by optional
         //  parameter In_Same_Region_As, into the llvm identifier Gets.
         //  Return #false if we are unable to determine at compile-time
         //  the representation of Null (e.g. because we weren't able
         //  to determine whether the type was small or large).

         if Base(Loc) == Zero_Base then
            //  Statically known type descriptor
            if Offset(Loc) == 0 then
               //  Just load a null address
               TLO |= Gets | " = ptrtoint i64* null to i64"
               return #true;
            end if;
            // Fall through to call Get_Known_Type_Desc
            // even though Cur_Type_Desc might be null.

         elsif Cur_Type_Desc is null then
            //  Current type descriptor isn't known at compile time
            //  and Loc is not an "absolute" type locator.
            return #false;
         end if;

         //  Get type descriptor based on Cur_Type_Desc and Loc
         const Type_Desc := Get_Known_Type_Desc(Cur_Type_Desc, Loc);

         if Is_Small(Type_Desc) then
            const Null_Val := Null_Value_For_Type(Type_Desc);

            if Null_Val is null then
               //  Null value for this type is same as that for
               //  Univ_Integer, which is the most-negative value
               //  (- 2**63)
               TLO |= Gets | " = bitcast i64 shl(i64 1, i64 63) to i64"
            else
               //  Just represent null value of type as an integer
               TLO |= Gets | " = bitcast i64 `(Null_Val) to i64"
            end if
            return #true;  //  All done

         elsif Is_Large(Type_Desc) then
            //  Type is a "large" type
            //  See whether region is specified
            if In_Same_Region_As not null then
               const Source_Ptr := "%_source_ptr" | UI;
               const Source_Val := "%_source" | UI;

               Load_Via_Locator(In_Same_Region_As, Source_Ptr,
                                Source_Val, UID_Extra => 1);

               if not VM_Reg_Is_For_Local (Source_Val) then
                  //  Not known to be local, so must assume the worst
                  Type_Desc_LLVM_Utils::Get_Large_Null_In_Region
                    (TLO, UI, Gets, Source_Val)

                  return #true;  //  All done
               end if;
            end if

            //  Known to be local, or no region specified,
            //  so generate a large local null
            Type_Desc_LLVM_Utils::Get_Large_Local_Null(TLO, UI, Gets);
            Set_VM_Reg_Is_For_Local (Gets);
            return #true;  //  All done

         else
            //  Type descriptor is not known to be small or large
            return #false;
         end if
      end func Load_Known_Type_Null;

      func Load_Null(Type_Loc : Reflection::Object_Locator; Gets : String;
        In_Same_Region_As : optional Reflection::Object_Locator := null) is
         //  Put Null for this type into the llvm identifier Gets
         if Load_Known_Type_Null
              (Cur_Type_Desc =>
                 VM_Reg_Type_Desc(Current_Type_Desc(UI | "_n")),
               Gets => Gets,
               Loc => Type_Loc, In_Same_Region_As => In_Same_Region_As)
         then
            //  Type descriptor at Type_Loc was known.
            return;  //  All done
         end if;

         //  Type descriptor not known at compile time,
         //  so do run-time switch between small and large.
         const Desc := "%_desc" | UI;

         Load_Type_Desc(Type_Loc, Desc);

         if In_Same_Region_As not null then
            //  See whether we can determine if In_Same_Region_As is local
            const Source_Ptr := "%_source_ptr" | UI;
            const Source_Val := "%_source" | UI;

            Load_Via_Locator(In_Same_Region_As, Source_Ptr,
                             Source_Val, UID_Extra => 2);

            if not VM_Reg_Is_For_Local (Source_Val) then
               //  Use LLVM instructions to load the null value
               Type_Desc_LLVM_Utils::Get_Null_In_Region
                                       (TLO, UI, Desc, Gets, Source_Val);
               return;  //  All done
            end if;
         end if;

         //  Get a local null, either big or small
         Type_Desc_LLVM_Utils::Get_Local_Null(TLO, UI, Desc, Gets);
         Set_VM_Reg_Is_For_Local (Gets);

      end func Load_Null

      func Get_Recon_String_Id(Str, Gets : String) is
         //  Place a reconstructed univ string id
         //  in the LLVM identifier Gets
         const Str_Ptr_Ptr := "%_str_ptr_ptr" | UI;
         const Str_Ptr     := "%_str_ptr"     | UI;
         const Orig_Num_Strs    := TLO.TLO_S.Num_Elems();
         const Str_Index := TLO.TLO_S.Get_Local_Index(Str);
         if Debug_Strings and then TLO.TLO_S.Num_Elems() > Orig_Num_Strs then
            Println("Get_Recon_String_Id: #`(Str_Index) is " | Str);
         end if;

         TLO |= Str_Ptr_Ptr | " = load i64*, i64** @$Strings";
         TLO |= Str_Ptr | " = getelementptr i64, i64* " | 
            Str_Ptr_Ptr | ", i64 " | Str_Index-1;
         TLO.Ends_With_String_Index();  //  Remember we used a string index
         TLO |= Gets | " = load i64, i64* " | Str_Ptr;
      end func Get_Recon_String_Id

      func Test_For_Null(Type_Loc : Reflection::Object_Locator;
                         Value_Loc : Reflection::Object_Locator;
                         Result_Bit : String;
                         For_Not_Null : Bool := #false) is
         //  Test whether is null
         //  Put i1 result in Result_Bit
         //  For_Not_Null is #false for Is_Null, is #true for Is_Not_Null
         //  Used by #Is_Null_Op and #Not_Null_Op
         const Arg        := "%_arg"        | UI;
         const Arg_Ptr    := "%_arg_ptr"    | UI;
         const Desc       := "%_desc"       | UI;
         const Eq_Or_Ne   := (For_Not_Null? "ne": "eq")

         var Known_Type_Desc : Reflection::Type_Descriptor := null;

         Load_Via_Locator(Value_Loc, Arg_Ptr, Arg, UID_Extra => 1);

         if Is_Null_Locator (Type_Loc) then
            //  Test for null pointer, as returned by Unwrap_Polymorphic_Obj
            //  as part of polymorphic case statement.
            TLO |= Result_Bit | " = icmp " | Eq_Or_Ne |
                     " i64 `(Arg), 0"
            return  //  All done

         elsif Base (Type_Loc) == Zero_Base then
            Known_Type_Desc :=
              Reflection::Type_Descriptor::Type_Desc_At_Locator(Type_Loc);
         else
            const Cur_Type_Desc_Reg := Current_Type_Desc(UI | "_n");
            const Cur_Type_Desc := VM_Reg_Type_Desc (Cur_Type_Desc_Reg);
              //  Type descriptor if known; otherwise null.

            if Cur_Type_Desc not null then
               //  We know the current type descriptor at compile time
               Known_Type_Desc := Get_Known_Type_Desc(Cur_Type_Desc, Type_Loc);

            elsif Enc_Type_Desc not null
              and then Base(Type_Loc) == Type_Area
              and then Offset(Type_Loc) == 0
            then
               //  We can use the not-fully-instantiated type descriptor
               //  associated with the current routine since
               //  all we care about is the associated null value.
               Known_Type_Desc := Enc_Type_Desc;
            end if;
         end if;

         if Known_Type_Desc not null then
            //  Test for compile-time-known type-specific null value

            if Is_Small(Known_Type_Desc) then
               //  Get appropriate result into Result_Ext
               const Null_Val := Null_Value_For_Type(Known_Type_Desc);

               //  if Null value for this type is same as that for
               //  Univ_Integer then we use the most-negative value
               //  which = 1 << 63
               const Null_Val_Str := (Null_Val is null?
                                        "shl (i64 1, i64 63)":
                                        To_String(Null_Val))

               TLO |= Result_Bit | " = icmp `(Eq_Or_Ne) i64 " | Arg |
                    ", " | Null_Val_Str

               return  //  All done

            elsif Is_Large(Known_Type_Desc) then
               //  Check for large null
               //  Get appropriate result into Result_Bit
               Type_Desc_LLVM_Utils::Test_For_Large_Null
                  (TLO, UI, Arg, Result_Bit, For_Not_Null => For_Not_Null);

               return  //  All done

            //  else fall through because Known_Type_Desc must not
            //  be fully instantiated.
            end if
         end if

         //  Test for dynamic type-specific null value
         Load_Type_Desc(Type_Loc, Desc);

         //  Get appropriate result into Result_Bit
         Type_Desc_LLVM_Utils::Test_For_Null(TLO, UI, Desc, Arg, Result_Bit,
           For_Not_Null => For_Not_Null);

      end func Test_For_Null

      func Return_From_LLVM_Func() is
        //  If parameters passed in registers, and function has an output,
        //  return content of first (and only slot) of %_Param_Area.
         if Formal_Params_In_Regs and then Has_Output_Param then
            //  move contents of %_Param_Area[0] into a register
            const Result_Type := LLVM_Param_Type(Formal_Params[1])

            const Result_Reg := "%_result_reg" | UI
            var Addr_Of_Result := "%_Param_Area"

            if Formal_Params[1].Is_Passed_By_Ref then
               //  Return by reference, so need to cast %_Param_Area to i64**
               Addr_Of_Result := "%_result_reg_ptr" | UI
               TLO |= Addr_Of_Result |
                      " = bitcast i64* %_Param_Area to `(Result_Type)*"
            end if

            TLO |= Result_Reg | " = load `(Result_Type), " |
                        Result_Type | "* " | Addr_Of_Result
            TLO |= "ret `(Result_Type) " | Result_Reg
         else
            //  Not returning anything
            TLO |= "ret void"
         end if
      end func Return_From_LLVM_Func

      func Continue_If_Level_Diff_Zero(Level_Skip : String) is
         //  if Level_Diff != 0 then this function returns as well
         //  with (Level_Diff - 1, Skip_Count) to caller
         //  else Skip

         {OCS.Inline_Stack.Is_Empty()}  //  Not allowed in inlined code

         const Level_Diff32         := "%_level_diff32_"        | UI;
         const Level_Diff           := "%_level_diff"           | UI;
         const Level_Diff_NZ        := "%_level_diff_nz"        | UI;
         const Level_Diff_Minus_One := "%_level_diff_minus_one" | UI;
         const Skip_Count           := "%_skip_count"           | UI;

         //  Label for executing skips
         const Switch               := "_switch"                | UI;

         //  Get top 16 bits
         //  Arithmetic vs logical shift makes no difference
         TLO |= Level_Diff32 | " = ashr i32 `(Level_Skip), 16";
         //  Becuase we then truncate
         TLO |= Level_Diff | " = trunc i32 `(Level_Diff32) to i16";

         //  Skip_Count is bottom 16 bits
         TLO |= Skip_Count | " = trunc i32 `(Level_Skip) to i16";

         //  Compare against zero
         TLO |= Level_Diff_NZ | " = icmp ne i16 " |
            Level_Diff | ", 0";

         //  Exit if Level_Diff != 0
         const Exit := "_exit" | UI;
         TLO |= "br i1 `(Level_Diff_NZ), label %" | Exit |  //  True
                                          ", label %" | Switch; //  False
         TLO |= Exit | ":";

         Finalize_If_Needed(TLO, Stg_Rgn_Is_Available);

         //  Return correct respective types for
         //  blocks and for regular functions
         if Instr_In_Nested_Block then
            const Result     := "%_levelm1_skip" | UI;
            const LD_Zext    := "%_ld_zext"      | UI;
            const LD_Shifted := "%_ld_shifted"   | UI;
            const Skip_Zext  := "%_skip_zext"    | UI;
            TLO |= Level_Diff_Minus_One | " = sub nsw i16 " |
               Level_Diff | ", 1";
            TLO |= LD_Zext | " = zext i16 `(Level_Diff_Minus_One) to i32";
            TLO |= LD_Shifted | " = shl i32 `(LD_Zext), 16";
            TLO |= Skip_Zext | " = zext i16 `(Skip_Count) to i32";
            TLO |= Result | " = or i32 `(LD_Shifted), " | Skip_Zext;
            TLO |= "ret i32 " | Result;
         else
            Return_From_LLVM_Func();
         end if

         //  Level diff not zero --> Skip (possibly 0) instructions
         TLO |= Switch | ":";
         const Default := TLO.Add_Label(0);
         const Skip_Counts := Instr.Skip_Counts();
         if Skip_Counts not null and then Length(Skip_Counts) > 0 then
            var Switch_Statement := "switch i16 `(Skip_Count), label " |
               Default | " [\n";
            for each Skip of Skip_Counts forward loop
               const Lbl := TLO.Add_Label(Skip);
               Switch_Statement |= (2 * Ind) | "i16 " | Skip |
                  ", label `(Lbl)\n";
            end loop
            Switch_Statement |= Ind | "]\n";
            TLO |= Switch_Statement;
         else
            TLO |= "br label " | Default;
         end if
      end func Continue_If_Level_Diff_Zero

      //  Generate code to print Msg at run time
      //  TODO: stdout, stderr
      func Runtime_Message(Msg : String) is
         const Assert_Str      := "%_assert_str"     | UI;
         const Print_Param     := "%_print_param"    | UI;
         Get_Recon_String_Id(Msg, Assert_Str);
         TLO.Declare("_psc_runtime_message",
                     "void @\"_psc_runtime_message\"(i64*, i64*, i64*)");
         TLO |= Print_Param | " = alloca i64";
         TLO |= "store i64 `(Assert_Str), i64* " | Print_Param;
         TLO |= "call void @_psc_runtime_message(i64* %_Context, i64* " | 
            Print_Param | ", i64* null)";
      end func Runtime_Message

      func Convention_For_Call
        (Reflection::Routine;
         Is_Parallel : Boolean := #false)
        -> Reflection::Decl::Convention_Enum is
         return Is_Parallel? #queuing_default :   //  TBD: use convention?
                Routine is null? #external_default : Convention(Routine);
      end func Convention_For_Call

      func Setup_Params_For_Call
        (Reflection::Routine;
         Call_Param_Area : String;
         Is_Parallel : Boolean := #false;
         UID_Extra : Int := 0) is
         //  This function loads up the parameter list before the call

         const Is_Parallel_Or_Indir := Is_Parallel or else Routine is null;
         const Convention := Convention_For_Call(Routine, Is_Parallel);
         const Pass_In_Regs := Pass_Params_In_Regs[Convention];

         {Is_Parallel ==> OCS.Inline_Stack.Is_Empty()}
            //  Nothing parallel in an inlining

         const Formals_For_Call := Routine is null? null : Parameters(Routine);
         const Param_Loc := Is_Parallel?
                              Instr.Parallel_Control() : Instr.Params();

         //  Parameters are (potentially) stored in LLVM registers
         //  Use "alloca" to allocate space for parameters, and
         //  then assign values from Call_Param_Area into the newly
         //  allocated space.
         //  NOTE: 0th parameter might not be initialized, so only
         //        want to copy it if is initialized.
         //  NOTE2: After call, need to copy value from 0th parameter
         //        slot back into proper place in "stack"

         const Copy_Outputs := Instr.Output_Inited_Null()

         const Param_Base := Is_Parallel? Reflection::Tcb_Size: 0

         const Num_Outputs := (Formals_For_Call is null?
                               Instr.Num_Out_Params() :
                               (for each P of Formals_For_Call
                                 {P.Is_Operation_Output} => <0> + 1))
         const Num_Params :=
           (Formals_For_Call not null?
              |Formals_For_Call| :
              [[Instr.Num_In_Params() + Num_Outputs]])

         if not Is_Parallel
           or else Base(Instr.Parallel_Control()) == Local_Area
         then
            //  Allocate new parameter area (unless allocated by earlier
            //  Create_Tcb_Op)
            TLO |= Call_Param_Area | " = alloca i64, i64 " |
              (Param_Base + Num_Params)

            if Is_Parallel then
               //  VM register for Call_Param_Area is a pointer.
               Set_VM_Reg_Is_Ptr (Adjusted_VM_Num(Instr.Parallel_Control()))
            end if

         //  else Call_Param_Area already points at TCB/param area

         end if

         //  Copy the inputs (and perhaps outputs as well) into the 
         //  newly allocated parameter area.
         for J in 1 .. Num_Params
          {Copy_Outputs or else J > Num_Outputs}
          forward loop
            const Par_Offs := Param_Base + J-1
            var Orig_Arg : Univ_String;

            if Formals_For_Call not null
              and then Is_Null_Locator (Formals_For_Call[J].Type_Info)
            then
               //  This must be an implicit-module parameter which
               //  has been hoisted to the enclosing module (e.g. the
               //  Right operand of "**" in a units package).
             
               if Debug then
                  Println(" Null type_info for Param `(J-1) of " |
                    (Routine not null? Routine.Name() : "indirect call"));
               end if

               continue loop;
            end if

            const New_Arg_Addr :=
              "%_new_arg_addr`(UI)_" | Par_Offs
            TLO |= New_Arg_Addr | " = getelementptr i64, i64* " |
              Call_Param_Area | ", i64 " | Par_Offs

            //  PSVM param locator has First_Param_Call_Num
            //  from which we can compute name of param at offset J-1
            Orig_Arg := Adjusted_VM_Param_Name(Param_Loc, J-1)

            if VM_Reg_Is_Ptr (Adjusted_VM_Param_Num(Param_Loc, J-1)) then
               //  Parameter is an address
               Store_Ptr_Indir (New_Arg_Addr, Orig_Arg)
            else
               Store_Indir (New_Arg_Addr, Orig_Arg)
            end if

         end loop

      end func Setup_Params_For_Call

      func Emit_LLVM_Call
        (Reflection::Routine;
         LLVM_Name : String;
         Call_Param_Area, Static_Link_Reg : String)
      is
        //  Emit the actual call, passing the Call_Param_Area
        //   or the actual
        //  parameters in registers.
        //  Order of register parameters is:
        //    input params, static link, context, output-param-initial-val
         const Convention := Convention_For_Call
                                (Routine, Is_Parallel => #false);
         const Pass_In_Regs := Pass_Params_In_Regs[Convention];

         TLO |= "call void " | LLVM_Name |
                "(i64* %_Context, i64* " |
                Call_Param_Area | ", i64* `(Static_Link_Reg))";
      end func Emit_LLVM_Call;

      func Finish_Params_After_Call
        (Reflection::Routine;
         Call_Param_Area : String;
         Is_Parallel : Boolean := #false)
       is
         //  This function moves the result to where it is expected,
         //  after the call

         const Is_Parallel_Or_Indir := Is_Parallel or else Routine is null;
         const Convention := Convention_For_Call(Routine, Is_Parallel);
         const Pass_In_Regs := Pass_Params_In_Regs[Convention];

         const Formals_For_Call := Routine is null? null : Parameters(Routine)
         const Param_Loc := Is_Parallel?
                              Instr.Parallel_Control() : Instr.Params();

         const Num_Outputs := (Formals_For_Call is null?
                               [[Instr.Num_Out_Params()]] :
                               (for each P of Formals_For_Call
                                 {P.Is_Operation_Output} => <0> + 1))
         const Num_Params :=
           (Formals_For_Call not null?
              |Formals_For_Call| :
              [[Instr.Num_In_Params()]] + Num_Outputs)

         //  After call, need to copy value from 0th parameter
         //  slot back into proper place in "stack"

         const Param_Base := Is_Parallel? Reflection::Tcb_Size: 0

         //  Look at outputs
         for J in 1 .. Num_Outputs forward loop
            const Par_Offs := Param_Base + J-1
            const New_Result_Addr :=
              "%_new_result_addr`(UI)_" | Par_Offs
            TLO |= New_Result_Addr | " = getelementptr i64, i64* " |
              Call_Param_Area | ", i64 " | Par_Offs

            if not Is_Parallel then
               //  Not parallel, do the load now
               const Output_Is_By_Ref := Formals_For_Call is null? #false:
                                         Formals_For_Call[J].Is_Passed_By_Ref;
                                    //  TBD this is not right!
               const New_Result := "%_new_result`(UI)_" | Par_Offs
               const Orig_Result_Addr :=
                 "%_result_addr`(UI)_" | Par_Offs

               if Output_Is_By_Ref then
                  //  Result is an address
                  const New_Result_Addr_Ind :=
                    "%_new_result_addr_ind`(UI)_" | Par_Offs
                  TLO |= New_Result_Addr_Ind | " = bitcast i64* " |
                     New_Result_Addr | " to i64**";
                  TLO |= New_Result | " = load i64*, i64** " |
                     New_Result_Addr_Ind
               else
                  TLO |= New_Result | " = load i64, i64* " | New_Result_Addr 
               end if

               //  TBD: We don't support multiple outputs yet
               {Par_Offs == 0}
               //  Param locator of call has target for call
               Store_Via_Locator (Param_Loc, Orig_Result_Addr, New_Result,
                 Ptr_Level => (Output_Is_By_Ref? 1 : 0))
            end if
         end loop

      end func Finish_Params_After_Call

      func Emit_LLVM_Reg_Call
        (Reflection::Routine;
         LLVM_Name : String;
         Static_Link_Reg : String) is
        //  Call Routine with parameters in registers
        //  Presume Routine not null, and not a locked call.
         {Routine not null};

         //  TBD: If Pass_In_Regs and Instr.Locked_Param_Info() > 0
         //       get a lock around the call
         {Instr.Locked_Param_Info() == 0};

         const Convention := Convention_For_Call
                                (Routine, Is_Parallel => #false);
         const Pass_In_Regs := Pass_Params_In_Regs[Convention];

         {Pass_In_Regs}  //  This presumes we are passing parameters in regs

         const Formals_For_Call := Parameters(Routine);
         const Param_Loc := Instr.Params();

         //  Parameters are (potentially) stored in LLVM registers
         //  NOTE: 0th parameter might not be initialized, so only
         //        want to copy it if is initialized.
         //  NOTE2: After call, need to copy value from 0th parameter
         //        back into proper place in "stack"

         const Copy_Outputs := Instr.Output_Inited_Null();

         const Num_Outputs := (for each P of Formals_For_Call
                                 {P.Is_Operation_Output} => <0> + 1);
         const Num_Params := |Formals_For_Call|;

         var Param_List : String := "(";  // Build up the param list here

         //  Copy the inputs into the Param list.
         for J in Num_Outputs <.. Num_Params forward loop

            if Is_Null_Locator (Formals_For_Call[J].Type_Info) then
               //  This must be an implicit-module parameter which
               //  has been hoisted to the enclosing module (e.g. the
               //  Right operand of "**" in a units package).
             
               if Debug then
                  Println(" Null type_info for Param `(J-1) of " |
                    Routine.Name());
               end if

               continue loop;
            end if

            //  PSVM param locator has First_Param_Call_Num
            //  from which we can compute name of param at offset J-1
            const Orig_Arg := Adjusted_VM_Param_Name(Param_Loc, J-1);

            if VM_Reg_Is_Ptr (Adjusted_VM_Param_Num(Param_Loc, J-1)) then
               //  Parameter is an address
               Param_List |= "i64* `(Orig_Arg), ";
            else
               Param_List |= "i64 `(Orig_Arg), ";
            end if;

         end loop

         Param_List |= "i64* %_Context, i64* " | Static_Link_Reg

         var Output_Is_By_Ref : Boolean := #false
         var Result_Type := ""  // Result returned by the call
         const New_Result := "%_new_result`(UI)_0"

         if Num_Outputs > 0 then
            {Num_Outputs == 1}  //  TBD: Only handling one output
            //  Determine type of output
            Output_Is_By_Ref := Formals_For_Call[1].Is_Passed_By_Ref;

            if Output_Is_By_Ref then
               Result_Type := "i64*"
               Set_VM_Reg_Is_Ptr (Adjusted_VM_Param_Num(Param_Loc, 0));
            else
               Result_Type := "i64"
            end if

            if Copy_Outputs then
               //  Tack on the initialization of the output */
               const Output_Init_Reg := Adjusted_VM_Param_Name(Param_Loc, 0);

               Param_List |= ", `(Result_Type) " | Output_Init_Reg;

               //  Propagate whether output is for local region
               Set_VM_Reg_Is_For_Local
                 (New_Result, VM_Reg_Is_For_Local (Output_Init_Reg));

               if TLO.Use_Stack_For_Objects then
                  if VM_Reg_Is_For_Local (New_Result) then
                     if Debug_VM_Reg_Info_Prop then
                        Put_Error ("result object " | New_Result |
                          " could be on stack",
                          Instr.Source_Pos(), Message_Kind => "Info");
                     end if;
                  end if;
               end if;
            end if
         else
            //  No output
            Result_Type := "void"
         end if

         //  Finish up the parameter list
         Param_List |= ")"

         //  Now emit the call
         if Num_Outputs > 0 then
            const Orig_Result_Addr := "%_result_addr`(UI)_0"

            //  Param locator of call has target for call
            TLO |= New_Result | " = call `(Result_Type) " |
                        LLVM_Name | Param_List

            //  Store the result of the call as specified in the instr
            Store_Via_Locator (Param_Loc, Orig_Result_Addr, New_Result,
              Ptr_Level => (Output_Is_By_Ref? 1 : 0))
         else
            TLO |= "call void " | LLVM_Name | Param_List
         end if

      end func Emit_LLVM_Reg_Call

      func Is_Optimizable_If
        (If_Instr : Reflection::Instruction;
         Result_Locator : Reflection::Object_Locator;
         If_Offs : Int) -> Boolean is
        //  Return #true if can combine "if" into test instruction,
        //  which requires that If_Instr takes Result_Locator as its
        //  (non-indirect) source, and its condition is "Boolean_Is_True"
        //  and it does not have a label on it.
         return Opcode(If_Instr) == #If_Op
           and then Base(Result_Locator) == Base(If_Source(If_Instr))
           and then Offset(Result_Locator) == Offset(If_Source(If_Instr))
           and then not VM_Is_Indir(Result_Locator)
           and then If_Condition(If_Instr) ==
                      Reflection::Instruction::Boolean_Is_True
           and then not TLO.Has_Label(I+If_Offs .. I+If_Offs);
      end func Is_Optimizable_If;

      func Emit_If_Branch
        (Result : String;
         If_Instr : Reflection::Instruction;
         If_Offs : Int) is
        //  Emit an LLVM conditional branch, where:
        //  * Result contains a 1-bit value, with 1 = True and 0 = False;
        //  * Instr is original PSVM "if" instruction;
        //  * If_Offs is offset of "if" instruction relative to I
         const True := TLO.Add_Label(If_Offs);  // After if_op
         const False :=
           TLO.Add_Label(If_Instr.Skip_If_False() + If_Offs);  

         TLO |= "br i1 `(Result), label " | True |
                                         ", label " | False;
      end func Emit_If_Branch

      //  begin: Compile_One_Instr

      //  If "-g" is supplied, set the current line and column for the
      //  debugging information.
      //  Not for Begin_Nested_Block_Op though because that just ends up being
      //  a new function
      const Source_Pos := Source_Pos(Instr);
      if TLO.LLVM_Debug and then Opcode(Instr) != #Begin_Nested_Block_Op then
         TLO.Set_Debug(Source_Pos.Line(), Source_Pos.Col());
      end if

      //  llvm comments to help the debugging process
      //  Not gdb/dwarf debug information, just comments
      TLO |= "; `(To_String(Opcode(Instr))) at " |
         Source_Pos.Line() | ":" | Source_Pos.Col();

      case Opcode(Instr) of
         [#Skip_Op] =>
            //  Skip_Count is in units of PSVM instructions
            const To : String := TLO.Add_Label(Instr.Skip_Count());
            TLO |= "br label " | To;
         [#Call_Op | #Indirect_Call_Op] =>
            //  TODO: Precondition proved

            const Static_Link_Loc := Instr.Static_Link();
            const Call_Target := Instr.Call_Target();
            const SL_Base   := Base(Static_Link_Loc);
            const CT_Base   := Base(Call_Target);
            const SL_Offset := Offset(Static_Link_Loc);
            const CT_Offset := Offset(Call_Target);
            const Locked_Param_Info := Instr.Locked_Param_Info();
            const Targ_Index := Instr.Target_Index();

            const Is_Indir := Targ_Index == 0
                                or else
                              Opcode (Instr) == #Indirect_Call_Op;

            const Routine_TDesc := Routine_And_TDesc_For_Call
               (Instr.Call_Target(), Static_Link_Loc);
            const Routine_To_Call := Routine_TDesc.First;
            const Routine := Routine_To_Call not null?
                              Routine_To_Call :
                             not Is_Indir?
                              Routine_At_Index(Targ_Index) : null;
            const Conv_Desc := Routine not null?
                                 Conv_Desc(Routine) : Null_Conv_Desc();
            const Type_Desc_To_Use := Routine_TDesc.Second;
            const Convention := Convention_For_Call(Routine,
                                                    Is_Parallel => #false);
            const Pass_In_Regs := Pass_Params_In_Regs[Convention];
            const Pass_Context := Pass_Context_Param[Convention];

            //  This function makes an indirect call
            func Indirect_Call() is
               if Debug_Call then
                  Println("  [Indirect call]")
               end if
               //  Not known at compile time
               const Static_Link_Reg := "%_call`(UI)_Static_Link";
               const Call_Param_Area  := "%_call`(UI)_Param_Area";

               //  0 is Null_Object_Virtual_Address
               //  Should pass null if we're not calling through an Op_Desc
               var Op_Desc := "0";

               func Do_Slow_Path() is
                  //  This is the "slow" path which handles any indirect call.
                  const Execute :=
                    "@_psc_execute_compiled_indirect_call_op_conv";
                  const Func_Type := "void(i64*, i64*, i64*)*";
                  TLO.Declare(Execute, "void " | Execute |
                     "(i64*, i64*, i64*, i16, i16, " |
                     "i16, i16, i64, void(i64*, i64*, i64*)*, i8, i32)");
                  TLO |= "call void `(Execute)(i64* %_Context, i64* " |
                     Call_Param_Area | ", i64* " | Static_Link_Reg |
                     ", i16 `(SL_Base), i16 " | SL_Offset |
                     ", i16 `(CT_Base), i16 " | CT_Offset |
                     ", i64 " | Op_Desc |
                     ", `(Func_Type) null, i8 " |
                     Locked_Param_Info | ", i32 `(Conv_Desc.Encoding))";
               end func Do_Slow_Path

               if SL_Base == Zero_Base or else SL_Base == Type_Area
                 or else SL_Base in Enclosing_Type_Areas
               then
                  Load_Type_Desc(Static_Link_Loc, Static_Link_Reg);
               elsif SL_Base == Param_Area
                 or else SL_Base in Enclosing_Param_Areas
               then
                  //  This is a polymorphic call; no static link
                  TLO |= Static_Link_Reg | " = inttoptr i64 0 to i64*";
               else
                  Get_Locator_Ptr(Static_Link_Loc, Static_Link_Reg);
               end if

               Setup_Params_For_Call(Routine, Call_Param_Area, UID_Extra => 1);
               
               case CT_Base of
                [Zero_Base | Const_Area] =>
                  //  Should not occur
                  {#false}

                [Type_Area|
                 Enclosing_Type_Areas.First .. Enclosing_Type_Areas.Last] =>
                  if SL_Base != Param_Area
                    and then SL_Base not in Enclosing_Param_Areas
                    and then CT_Offset in Type_Operation_Offsets
                    and then CT_Base not in Enclosing_Type_Areas
                    and then Locked_Param_Info == 0
                      //  TBD: Handle this case in execute_compiled_nth...
                  then
                     //  This is the "fast" path.
                     const Execute_Nth_Op :=
                       "@_psc_execute_compiled_nth_op_of_type";
                     TLO.Declare(Execute_Nth_Op, "void " | Execute_Nth_Op |
                        "(i64*, i64*, i64*, i16, i16)");
                     TLO |= "call void " | Execute_Nth_Op |
                        "(i64* %_Context, i64* " |
                        Call_Param_Area | ", i64* " | Static_Link_Reg |
                        ", i16 " | CT_Base |
                        ", i16 " | CT_Offset - Type_Operation_Offsets.First |
                        ")";

                  else
                     //  We don't have a fast path for polymorphic calls yet.
                     Do_Slow_Path();
                  end if;

                [..] =>
                  //  Calling through an Operation_Descriptor
                  const Op_Desc_Ptr := "%_op_desc_ptr" | UI;
                  Op_Desc           := "%_op_desc"     | UI;
                  Load_Via_Locator
                    (Call_Target, Op_Desc_Ptr, Op_Desc, UID_Extra => 2);
                  //  Op_Desc is an object virtual address

                  if Locked_Param_Info > 0 then
                     //  If we are locking, use the "slow" path.
                     Do_Slow_Path();
                  else
                     //  Simple level of indirection, use the "fast" path.
                     const Op_Desc_Call :=
                       "@_psc_call_through_operation_desc";
                     TLO.Declare(Op_Desc_Call,
                       "void `(Op_Desc_Call)(i64*, i64, i64*)");
                     TLO |= "call void " | Op_Desc_Call |
                       "(i64* %_Context, i64 " |
                       Op_Desc | ", i64* `(Call_Param_Area))";
                  end if
               end case

               Finish_Params_After_Call(Routine, Call_Param_Area)

            end func Indirect_Call

            if Routine_To_Call is null then
               Indirect_Call();

               //  Return from caller as well so, 
               //  don't forget to tell the LLVM accumulator
               TLO.Next_PSIR_Instr();
               return;
            end if

            const Desig := Routine.Built_In_Desig();
            //  Some subset of the built-ins can be implemented
            //  Directly in llvm, if not able, just call it

            func Inline_Call() -> Boolean is
               //  Attempts to expand call inline.
               //  Returns #true if successfully does the inlining.

               func Preceded_By_Terminator(Loc : Int) -> Boolean is
                 //  Return #true if instruction preceding instruction Loc
                 //  will produce a terminating LLVM instruction.
                  return Loc > 1
                    and then Opcode(Routine.Nth_Instr(Loc-1)) in Terminators;
               end func Preceded_By_Terminator;

               //  Check whether all instructions are OK in an inline
               const Safe_For_Inlining :=
                 (for all Inline_Index in 1 .. Routine.Num_Instrs() =>
                    Is_Allowed_In_Inlining
                      (Routine, Routine.Nth_Instr(Inline_Index),
                       TLO.Doing_Run_Time_Checks))

               if not Safe_For_Inlining then
                  if Debug_Inlining then
                     Println("** NOT inlining call to " | Routine.Name() |
                       " at " | Source_Pos);
                  end if

                  return #false;
               end if

               //  Now actually inline the call.
               if Debug_Call then
                  Println("  [inlining]")
               end if

               const Static_Link_Reg := "%_call`(UI)_Static_Link";

               //  Set up info on this inlining
               TLO.Num_Inlines += 1;

               const Formals_For_Call := Parameters(Routine);
               const Param_Loc := Instr.Params();

               var New_Inline_Info : optional Inline_Info_Type :=
                 (Unique_Inline_Id =>
                   (not OCS.Inline_Stack.Is_Empty()?
                      OCS.Inline_Stack.Top().Unique_Inline_Id : "") | ".I" | I,
                  Type_Desc => Type_Desc_To_Use,
                  Type_Desc_Name => Static_Link_Reg,
                  Has_Output_Param =>
                   (for some P of Formals_For_Call =>
                     P.Is_Operation_Output),
                  Param_Locator => Param_Loc,
                  VM_Reg_Adjustment => TLO.Inlining_Reg_Adjustment,
                  Stg_Rgn_Is_Available => Stg_Rgn_Is_Available);

               //  We are now committed to doing the inline
               TLO |= "; inlining call on " | Routine.Name();

               const Num_Regs := Routine.Num_VM_Regs();

               //  Bump reg-num starting point for next inlining, on
               //  multiple of Min_Adjustment.
               TLO.Inlining_Reg_Adjustment +=
                  (Num_Regs/Inline_Info_Type::Min_Adjustment + 1) *
                   Inline_Info_Type::Min_Adjustment;

               const Output_Param_Addr := New_Inline_Info.Output_Param_Name();

               if New_Inline_Info.Has_Output_Param then
                  //  Allocate space for output
                  const Init_Output := Instr.Output_Inited_Null();
                  //  const Output_Is_By_Ref :=
                  //    Formals_For_Call[1].Is_Passed_By_Ref;
                  TLO |= Output_Param_Addr | " = alloca i64";

                  if Init_Output then
                     //  PSVM param locator has First_Param_Call_Num
                     //  which is presumed to be the one and only output.
                     const Output_Arg := Adjusted_VM_Param_Name(Param_Loc, 0);

                     if VM_Reg_Is_Ptr (Adjusted_VM_Param_Num(Param_Loc, 0))
                     then
                        //  Parameter is an address
                        Store_Ptr_Indir (Output_Param_Addr, Output_Arg)
                     else
                        Store_Indir (Output_Param_Addr, Output_Arg)
                     end if
                  end if
               end if

               Load_Type_Desc(Static_Link_Loc, Static_Link_Reg,
                 TDesc_To_Use => Type_Desc_To_Use);

               TLO.Begin_Inlined_Call(New_Inline_Info.Unique_Inline_Id);

               //  Push new inline-info onto the stack
               OCS.Inline_Stack <|= New_Inline_Info;

               if Debug_Inlining then
                  Println("** inlining call to " | Routine.Name() |
                    " at " | Source_Pos);
               end if

               //  Remember current limit for inlining
               const Old_Max_Instrs := TLO.Max_Instrs_For_Inlining

               //  and divide the limit by two, to prevent recursive
               //  inlining happening without bound.
               TLO.Max_Instrs_For_Inlining /= 2;

               //  Set up the output parameter, if any  ** TBD **

               //  inline intructions from this routine
               var Inline_Look_Ahead_Count := 0;

               for Inline_Index in 1 .. Routine.Num_Instrs() forward loop
                  if Inline_Look_Ahead_Count > 0 then
                     //  Skipping this instruction, because code for it was
                     //  generated when processing a prior instruction
                     Inline_Look_Ahead_Count -= 1;
                  else
                     //  No look-ahead was performed
                     Compile_One_Instr
                       (Routine, TLO, Func_Node,
                        Inline_Index,
                        Inline_Look_Ahead_Count, OCS);
                  end if;
               end loop

               //  Restore the inlining instr limit
               TLO.Max_Instrs_For_Inlining := Old_Max_Instrs;

               //  Pop inline info off the stack
               New_Inline_Info := OCS.Inline_Stack.Pop();

               TLO.End_Inlined_Call(Preceded_By_Terminator);

               if New_Inline_Info.Has_Output_Param then
                  //  Copy back the output parameter
                  const Output_Is_By_Ref :=
                    Formals_For_Call[1].Is_Passed_By_Ref;
                  const New_Result := "%_new_result" | UI;
                  const Orig_Result_Addr := "%_result_addr" | UI;

                  if Output_Is_By_Ref then
                     //  Result is an address
                     const New_Result_Addr_Ind := "%_new_result_addr_ind" | UI;

                     TLO |= New_Result_Addr_Ind | " = bitcast i64* " |
                        Output_Param_Addr | " to i64**";
                     TLO |= New_Result | " = load i64*, i64** " |
                        New_Result_Addr_Ind;
                  else
                     TLO |= New_Result |
                                " = load i64, i64* " | Output_Param_Addr;
                  end if
                  Set_VM_Reg_Is_For_Local (New_Result,
                    VM_Reg_Is_For_Local (Output_Param_Addr));

                  //  Param locator of call has target for call
                  Store_Via_Locator (Param_Loc, Orig_Result_Addr, New_Result,
                    Ptr_Level => (Output_Is_By_Ref? 1 : 0));

               end if

               if Debug_Call then
                  Println("  [end inlining]");
               end if
               return #true;  //  We actually inlined the call
            end func Inline_Call

            func Call() is
              //  Emit an LLVM call instruction

               if Debug_Call then
                  Println ("conv_desc(`(Name(Routine))) = " |
                    Conv_Desc(Routine))
               end if

               if Desig is null and then Num_Instrs(Routine) == 0 then
                  //  Presume this is an "optional" routine
                  //  that has no definition, so it is treated
                  //  as a no-op.
                  //  We will have already initialized the output(s), if any,
                  //  to null.
                  //  TBD:Pass_In_Regs -- copy initial output into register
                  TLO |= "; No-Op: optional routine with no definition";
                  return;
               end if;

               if Desig is null
                 and then Num_Instrs(Routine) <= TLO.Max_Instrs_For_Inlining
                 and then
                   (Stg_Rgn_Is_Available or else not Uses_Stg_Rgn(Routine))
                 and then Is_Allowed_In_Inlining(Operation_Routine, Instr,
                            TLO.Doing_Run_Time_Checks)
                            //  TBD: Should probably have a different check
               then
                  --  Try to expand the instructions in line
                  if Inline_Call() then
                     --  We were able to inline the call
                     return;
                  end if;
               end if;

               const LLVM_Name : String := Get_LLVM_Name(Routine);

               //  Declare the func, in case it might be external.
               const LLVM_Func_Profile :=
                 LLVM_Function_Profile (Routine, LLVM_Name);
               TLO.Declare (LLVM_Name, LLVM_Func_Profile);

               //  Get Static_Link and Param_Area addresses for this call
               const Static_Link_Reg := "%_call`(UI)_Static_Link";
               if SL_Base == Zero_Base or SL_Base == Type_Area or
                  SL_Base in Enclosing_Type_Areas then
                  //  Static link refers to a type descriptor
                  Load_Type_Desc(Static_Link_Loc, Static_Link_Reg,
                     TDesc_To_Use => Type_Desc_To_Use);
               else
                  //  Static link refers to an enclosing stack frame
                  Get_Locator_Ptr(Static_Link_Loc, Static_Link_Reg,
                     UID_Extra => 1);
               end if

               if not Pass_In_Regs or else Locked_Param_Info > 0 then
                  //  Pass parameters in parameter block
                  const Call_Param_Area  := "%_call`(UI)_Param_Area";

                  Setup_Params_For_Call
                    (Routine, Call_Param_Area, UID_Extra => 2);

                  if Locked_Param_Info > 0 then

                     //  Call indirectly but with a pointer to the function
                     //  Because it needs a lock
                     const Execute :=
                        "@_psc_execute_compiled_indirect_call_op_conv";
                     const Func_Type := "void(i64*, i64*, i64*)*";
                     const LLVM_Name_Type :=
                       LLVM_Function_Profile (Routine, "") | "*"
                     const LLVM_Name_Converted :=  //  Convert if necessary
                        (LLVM_Name_Type == Func_Type)? LLVM_Name :
                          "bitcast(`(LLVM_Name_Type) " |
                            LLVM_Name | " to `(Func_Type))"

                     TLO.Declare(Execute, "void " | Execute |
                        "(i64*, i64*, i64*, i16, i16, " |
                        "i16, i16, i64, `(Func_Type), i8, i32)");

                     TLO |= "call void `(Execute)(i64* %_Context, i64* " |
                        Call_Param_Area | ", i64* " | Static_Link_Reg |
                        ", i16 `(SL_Base), i16 " | SL_Offset |
                        ", i16 `(CT_Base), i16 " | CT_Offset |
                        ", i64 0" |
                        ", " |
                        Func_Type | " " | LLVM_Name_Converted |
                        ", i8 " | Locked_Param_Info |
                        ", i32 `(Conv_Desc.Encoding))";

                     Finish_Params_After_Call (Routine, Call_Param_Area);
                     return;
                  end if;

                  Emit_LLVM_Call (Routine, LLVM_Name => LLVM_Name,
                    Call_Param_Area => Call_Param_Area,
                    Static_Link_Reg => Static_Link_Reg);

                  Finish_Params_After_Call (Routine, Call_Param_Area);
               else
                  //  Pass parameters in registers

                  Emit_LLVM_Reg_Call (Routine, LLVM_Name => LLVM_Name,
                    Static_Link_Reg => Static_Link_Reg);

               end if
                    
            end func Call

            func Binary_Op(Name : String;
                           Type : String := "i64";
                           Cast_Arg2 : String := "bitcast") is
               {|Parameters(Routine)| == 3}
               //  Name llvm identifiers
               const Arg1       := "%_first_arg" | UI;
               const Arg2       := "%_secon_arg" | UI;
               const Result     := "%_resul"     | UI;

               //  get arguments
               Load_Call_Param (1, Arg1, UID_Extra => 3);
               Load_Call_Param (2, Arg2, UID_Extra => 4);

               //  perform operation with correct type
               if Type != "i64" then
                  const Arg1c := Arg1 | "c";
                  const Arg2c := Arg2 | "c";
                  const Resultc := Result | "c";
                  //  cast to Type
                  TLO |= Arg1c | " = bitcast i64 " |
                        Arg1 | " to " | Type;
                  TLO |= Arg2c | " = `(Cast_Arg2) i64 " |
                        Arg2 | " to " | Type;

                  //  perform operation in that type
                  TLO |= Resultc | " = `(Name) `(Type) " 
                        | Arg1c | ", " | Arg2c;

                  //  cast back to i64
                  TLO |= Result | " = bitcast `(Type) " |
                        Resultc | " to i64"
               elsif Name == "#ordering_to_bool" then
                  //  Not a real LLVM operator;
                  //  Computation is "(Arg2 >> Arg1) and 1"
                  //  where Arg1 is a value of type Ordering,
                  //  and Arg2 is a mask indicating which values of Ordering
                  //  should contribute to the Boolean being true.
                  var Known_Arg2_Value := VM_Reg_Val(Arg2); 

                  if Known_Arg2_Value not null then
                     //  Value of Arg2 known at compile time, so can optimize:
                     //  Arg1 is assumed to be a value of type ordering:
                     //    0 is "<", 1 is "==", 2 is ">", 3 is #unordered.
                     const Result_Bit := "%_result_bit" | UI;

                     case Known_Arg2_Value of
                      [2#0010#] => // "=="
                        TLO |= Result_Bit |
                          " = icmp eq i64 `(Arg1), 1";

                      [2#1101#] => // "!="
                        TLO |= Result_Bit |
                          " = icmp ne i64 `(Arg1), 1";

                      [2#0001#] => // "<"
                        TLO |= Result_Bit |
                          " = icmp eq i64 `(Arg1), 0";

                      [2#0011#] => // "<="
                        TLO |= Result_Bit |
                          " = icmp ule i64 `(Arg1), 1";

                      [2#0100#] => // ">"
                        TLO |= Result_Bit |
                          " = icmp eq i64 `(Arg1), 2";

                      [2#0110#] => // ">="
                        const Sub_One := "%_ord_minus_one" | UI;

                        //  Subtract one and then use unsigned <= 1
                        TLO |= Sub_One | " = sub i64 `(Arg1), 1";
                        TLO |= Result_Bit |
                          " = icmp ule i64 `(Sub_One), 1";

                      [..] =>
                        //  Not a recognizable mask, so fall through
                        //  to do the standard shift/and of mask
                        Known_Arg2_Value := null;
                     end case;

                     if Known_Arg2_Value not null then
                        //  Check whether call on #ordering_to_bool is
                        //  followed by an "if" statement.
                        {I + 1 <= Num_Instrs_In_Routine}  // at least one more
                        const Next := Operation_Routine.Nth_Instr(I + 1);

                        //  Check that output of call matches input to "if"
                        if Is_Optimizable_If
                            (Next, Params(Instr), If_Offs => 1)
                        then
                           TLO |= "; to-bool + if-op optimization";
                           Emit_If_Branch(Result_Bit, Next, If_Offs => 1);

                           //  We generated code for one extra instruction
                           Look_Ahead_Count := 1;
                           return;  //  No need to store Result
                        else
                           //  Need to extend Result_Bit into Result
                           TLO |= Result |
                             " = zext i1 "| Result_Bit | " to i64";
                        end if;
                     end if;
                  end if;

                  if Known_Arg2_Value is null then
                     //  Mask value not known or not recognized;
                     //  Do the default shift/and of mask by ordering value.
                     const Mask_Shifted_By_Arg1 := "%_mask_shifted" | UI;

                     TLO |= Mask_Shifted_By_Arg1 | " = lshr i64 " |
                       Arg2 | ", " | Arg1;
                     TLO |= Result | " = and i64 1, " | Mask_Shifted_By_Arg1;
                  end if;
               else  
                  //  No need to cast
                  TLO |= Result | " = `(Name) i64 " 
                        | Arg1 | ", " | Arg2;
               end if

               //  Store result
               Store_Call_Result (Result, UID_Extra => 5);
            end func Binary_Op

            func Assign_Binary_Op(Name : String;
                        Type : String := "i64") is
               //  this is for +=, -=, etc
               //  assign unique llvm names
               const Left_Ptr     := "%_left_ptr"     | UI;
               const Left         := "%_left"         | UI;
               const Right        := "%_right"        | UI;
               const Result       := "%_result"       | UI;

               //  Get pointers and values for Left and Right
               Load_Call_Var_Param(0, Left_Ptr, Left, UID_Extra => 1);
               Load_Call_Param(1, Right, UID_Extra => 2);

               //  perform operation with correct type
               if Type != "i64" then
                  const Leftc := Left | "c";
                  const Rightc := Right | "c";
                  const Resultc := Result | "c";
                  //  cast to Type
                  TLO |= Leftc | " = bitcast i64 " |
                        Left | " to " | Type;
                  TLO |= Rightc | " = bitcast i64 " |
                        Right | " to " | Type;

                  //  perform operation in that type
                  TLO |= Resultc | " = `(Name) `(Type) " 
                        | Leftc | ", " | Rightc;

                  //  cast back to i64
                  TLO |= Result | " = bitcast `(Type) " |
                        Resultc | " to i64"
               else  
                  TLO |= Result | " = `(Name) i64 " 
                        | Left | ", " | Right;
               end if

               //  Store result
               Store_Indir(Left_Ptr, Result);
            end func Assign_Binary_Op

            func Unary_Op(Op_Name : String;
               Type : String := "") is
               //  Assign unique llvm identifiers
               //  Type is the llvm type of values that Op_Name
               //  operates on.
               //    Possible values are, "double"
               //    or the empty string, which assumes i64
               const N          := "%_n"          | UI;
               const Result     := "%_result"     | UI;

               //  Get arguments
               Load_Call_Param(1, N, UID_Extra => 1);

               if Op_Name == "fptosi" then
                  const Nc := N | 'c';
                  TLO |= Nc | " = bitcast i64 `(N) to double";
                  TLO |= Result | " = fptosi double `(Nc) to i64";
               elsif Op_Name[1] == '@' then
                  TLO.Declare(Op_Name,
                    "double `(Op_Name)(double)");
                  const Nc := N | 'c';
                  const Ni := N | 'i';
                  TLO |= Nc | " = bitcast i64 `(N) to double";
                  TLO |= Ni | " = call double " | Op_Name |
                     "(double `(Nc))";
                  if Type == "double" then
                     TLO |= Result | " = bitcast double `(Ni) to i64";
                  else
                     TLO |= Result | " = fptosi double `(Ni) to i64";
                  end if
               elsif Op_Name == "sitofp" then
                  const Resultc := Result | 'c';
                  TLO |= Resultc | " = sitofp i64 `(N) to double";
                  TLO |= Result | " = bitcast double `(Resultc) to i64";
               elsif Type == "double" then
                  const Nc      := N      | 'c';
                  const Resultc := Result | 'c';
                  TLO |= Nc | " = bitcast i64 `(N) to double";
                  TLO |= Resultc | " = `(Op_Name) " | Nc;
                  TLO |= Result | " = bitcast double `(Resultc) to i64";
               else
                  //  Perform Operation
                  TLO |= Result | " = `(Op_Name) " | N;
               end if

               //  Store result
               Store_Call_Result (Result, UID_Extra => 2);
            end func Unary_Op

            func Intrinsic_Double_Int(Name : String;
               Cast_Arg1 : String := "bitcast";
               Cast_Res : String := "bitcast") is
               //  Calls llvm intrinsics with the signature
               //  Double, int -> Double
               //  Cast_Arg1 specifies how to cast Arg1 from i64 to Double
               //    Use 'bitcast' if Arg1 is a double
               //      (this is necessary because stored on Stack as i64)
               //    Use 'sitofp' if Arg1 is a signed int
               //  Same story for Cast_Res for
               //  casting the result to i64 to be stored

               //  Assign unique llvm identifiers
               const Arg1i      := "%_first_arg_i"  | UI;
               const Arg1       := "%_first_arg"    | UI;
               const Arg2       := "%_secon_arg"    | UI;
               const Arg2_64    := "%_secon_arg_64" | UI;
               const Result     := "%_resul"        | UI;
               const Resulti    := "%_resul_i"      | UI;

               //  get arguments
               Load_Call_Param (1, Arg1i, UID_Extra => 1);
               Load_Call_Param (2, Arg2_64, UID_Extra => 2);

               //  cast first argument to double
               TLO |= Arg1 | " = `(Cast_Arg1) i64 " |
                  Arg1i | " to double"

               //  Call intrinsic
               TLO.Declare("llvm.`(Name).f64",
                           "double @llvm.`(Name).f64(double, i32)");
               TLO |= Arg2 | " = trunc i64 `(Arg2_64) to i32"
               TLO |= Result | " = call double @llvm." | Name |
                     ".f64(double `(Arg1), i32 `(Arg2))";

               //  cast back to int to be stored in Local_Area
               if Cast_Res[1] == '@' then
                  TLO.Declare(Cast_Res,
                              "double `(Cast_Res)(double)");
                  const Result_Double := "%_resul_double" | UI;
                  TLO |= Result_Double | " = call double " | Cast_Res |
                     "(double `(Result))";
                  TLO |= Resulti | " = fptosi double " | Result_Double |
                     " to i64";
               else
                  TLO |= Resulti | " = `(Cast_Res) double " |
                     Result | " to i64"
               end if
               
               //  Store result
               Store_Call_Result (Resulti, UID_Extra => 3);
            end func Intrinsic_Double_Int

            func Assign_Intrinsic_Double_Int(Name : String;
               Cast_Arg1 : String := "bitcast";
               Cast_Res : String := "bitcast") is
               //  See the comment for Intrinsic_Double_Int
               //  The only difference is that this
               //  takes a 'var' left parameter

               //  Assign unique llvm identifiers
               const Arg1_Ptr     := "%_first_ptr"     | UI;
               const Arg1_Int     := "%_first_arg_i"   | UI;
               const Arg1         := "%_first_arg"     | UI;
               const Arg2         := "%_secon_arg"     | UI;
               const Arg2_64      := "%_secon_arg_64"  | UI;
               const Result       := "%_resul"         | UI;
               const Resulti      := "%_resul_i"       | UI;

               //  get arguments
               Load_Call_Var_Param (0, Arg1_Ptr, Arg1_Int, UID_Extra => 1);
               Load_Call_Param (1, Arg2_64, UID_Extra => 2);

               //  cast first argument to double
               TLO |= Arg1 | " = `(Cast_Arg1) i64 " |
                  Arg1_Int | " to double"

               //  Call intrinsic
               TLO.Declare("llvm.`(Name).f64",
                           "double @llvm.`(Name).f64(double, i32)");
               TLO |= Arg2 | " = trunc i64 `(Arg2_64) to i32"
               TLO |= Result | " = call double @llvm." | Name |
                     ".f64(double `(Arg1), i32 `(Arg2))";

               //  Store result
               if Cast_Res[1] == '@' then
                  TLO.Declare(Cast_Res,
                              "double `(Cast_Res)(double)");
                  const Result_Double := "%_result_double" | UI;
                  TLO |= Result_Double | " = call double " | Cast_Res |
                     "(double `(Result))";
                  TLO |= Resulti | " = fptosi double " | Result_Double |
                     " to i64";
               else
                  TLO |= Resulti | " = `(Cast_Res) double " |
                     Result | " to i64"
               end if
               Store_Indir(Arg1_Ptr, Resulti);
            end func Assign_Intrinsic_Double_Int

            func Call_Builtin_Op(Name : String;
               In_Is_i64 : Bool := #true;
               Out_Is_i64 : Bool := #true) is
               //  In and Out are true for i64 and false for double
               //  Name llvm identifiers
               const Arg1_Ptr   := "%_first_ptr" | UI;
               const Arg1       := "%_first_arg" | UI;
               const Arg2_Ptr   := "%_secon_ptr" | UI;
               const Arg2       := "%_secon_arg" | UI;
               const Result     := "%_resul"     | UI;
               const Result_Ptr := "%_resul_ptr" | UI;

               //  get arguments
               Load_Call_Param (1, Arg1, UID_Extra => 1);
               Load_Call_Param (2, Arg2, UID_Extra => 2);

               if In_Is_i64 and Out_Is_i64 then
                  //  int compare, min, max
                  TLO.Declare(Name, "i64 `(Name)(i64, i64)");
                  TLO |= Result | " = call i64 `(Name)(i64 " | Arg1 |
                     ", i64 `(Arg2))";
               elsif not In_Is_i64 and Out_Is_i64 then
                  //  real compare
                  const Arg1c := Arg1 | 'c';
                  const Arg2c := Arg2 | 'c';
                  TLO.Declare(Name, "i64 `(Name)(double, double)");
                  TLO |= Arg1c | " = bitcast i64 `(Arg1) to double";
                  TLO |= Arg2c | " = bitcast i64 `(Arg2) to double";
                  TLO |= Result | " = call i64 `(Name)(double " |
                     Arg1c | ", double `(Arg2c))";
               elsif not In_Is_i64 and not Out_Is_i64 then
                  //  real min, max
                  const Arg1c := Arg1 | 'c';
                  const Arg2c := Arg2 | 'c';
                  const Resultc := Result | 'c';
                  TLO.Declare(Name, "double `(Name)(double, double)");
                  TLO |= Arg1c | " = bitcast i64 `(Arg1) to double";
                  TLO |= Arg2c | " = bitcast i64 `(Arg2) to double";
                  TLO |= Resultc | " = call double `(Name)(double " |
                     Arg1c | ", double `(Arg2c))";
                  TLO |= Result | " = bitcast double `(Resultc) to i64";
               else
                  //  i64, i64 -> double
                  //  Not needed at the moment
                  {#false};
               end if

               //  Store result
               Store_Call_Result (Result, UID_Extra => 3);
            end func Call_Builtin_Op

            func Call_Compare_Op(Name : String;
               Is_Real_Op : Bool := #false) is
              //  We are calling a "=?" (compare) operation.
              //  Check to see if we immediately perform a "to_bool" on
              //  the result.  If so, replace with the appropriate
              //  llvm comparison.

              //  TBD: Handle case where "=?" is followed immediately
              //       by an "if_op," as in range membership tests,
              //       and do the appropriate compare/conditional branch.
              //       Also handle case where an "if_op" follows
              //       the "to_bool" immediately, and do a simple
              //       conditional branch.

               func Do_Inline_Compare(Ordering_Mask : Int)
                 -> String is
                 //  Emit the appropriate LLVM compare operation
                 //  and return the string name for the LLVM register
                 //  holding the i1 result.

                  var Cmp_Type : String;
                  const Is_Int : Bool := not Is_Real_Op;
                  if Is_Int then
                     //  0th bit is less
                     //  1st bit is equal
                     //  2nd bit is greater
                     //  3rd bit is unordered (ignored)
                     case Ordering_Mask of
                        //  integer compare (icmp) op codes
                        [0 |  8] => Cmp_Type := "false";
                        [1 |  9] => Cmp_Type := "slt"; //  signed <
                        [2 | 10] => Cmp_Type := "eq";  //  ==
                        [3 | 11] => Cmp_Type := "sle"; //  signed <=
                        [4 | 12] => Cmp_Type := "sgt"; //  signed >
                        [5 | 13] => Cmp_Type := "ne";  //  !=
                        [6 | 14] => Cmp_Type := "sge"; //  signed >=
                        [7 | 15] => Cmp_Type := "true";
                        [..] => {#false}
                     end case;
                  else
                     case Ordering_Mask of
                        //  float compare (fcmp) op codes
                        [0 |  8] => Cmp_Type := "false";
                        [1 |  9] => Cmp_Type := "olt"; //  ordered <
                        [2 | 10] => Cmp_Type := "oeq"; //  ordered ==
                        [3 | 11] => Cmp_Type := "ole"; //  ordered <=
                        [4 | 12] => Cmp_Type := "ogt"; //  ordered >
                        [5 | 13] => Cmp_Type := "one"; //  ordered !=
                        [6 | 14] => Cmp_Type := "oge"; //  ordered >=
                        [7 | 15] => Cmp_Type := "true";
                        [..] => {#false}
                     end case;
                  end if
                  //  Assign llvm identifiers
                  const Left_Ptr   := "%_left_ptr"   | UI;
                  const Right_Ptr  := "%_right_ptr"  | UI;
                  const Result_Ptr := "%_result_ptr" | UI;
                  const Left       := "%_left"       | UI;
                  const Right      := "%_right"      | UI;
                  const Result     := "%_result"     | UI;

                  //  Get Operands
                  Load_Call_Param(1, Left);
                  Load_Call_Param(2, Right);

                  if Is_Int then
                     //  make Comparison
                     TLO |= Result | " = icmp " | Cmp_Type |
                        " i64 `(Left), " | Right;
                  else
                     //  cast to double then compare
                     const Leftc := Left | "c";
                     const Rightc := Right | "c";
                     TLO |= Leftc | " = bitcast i64 " |
                        Left | " to double";
                     TLO |= Rightc | " = bitcast i64 " |
                        Right | " to double";
                     TLO |= Result | " = fcmp " | Cmp_Type |
                        " double `(Leftc), " | Rightc;
                  end if
                  //  Result now holds an i1 that is the result
                  //  of the comparison (for floats or ints)

                  return Result;
               end func Do_Inline_Compare

               if I + 2 > Num_Instrs_In_Routine then
                  //  Compare cannot be optimized
                  Call_Builtin_Op(Name, In_Is_i64 => not Is_Real_Op);
                  return;
               end if

               const Next := Operation_Routine.Nth_Instr(I + 1);
               //  NNex is the Next Next instruction
               const NNex := Operation_Routine.Nth_Instr(I + 2);

               //  Get the designator of the Next Next instruction
               //  if it's a Call_Op
               var Desig_NNex : optional String;
               var Params_NNex : optional Reflection::Object_Locator;

               if Opcode(NNex) == #Call_Op then
                  Params_NNex := Params(NNex);
                  if NNex.Call_Target() not null
                   and then Base(NNex.Call_Target()) == Zero_Base
                  then
                     Desig_NNex := Built_In_Desig(
                        Reflection::Routine::Routine_At_Locator(
                        NNex.Call_Target()));
                  end if;
               end if

               //  Check for the correct sequence of instructions

               //  Either followed directly by an "if_op" or by
               //  a store-int-lit and a "call" on "to_bool."

               //  Check that output of compare matches input to "if"
               if Is_Optimizable_If (Next, Params(Instr), If_Offs => 1) then
                  //  The compare is followed by an "if"
                  TLO |= "; =? + if-op optimization";
                  const Result :=
                    Do_Inline_Compare(To_Rep(If_Condition(Next)));

                  Emit_If_Branch(Result, Next, If_Offs => 1);

                  //  We generated code for one extra instruction
                  Look_Ahead_Count := 1;

                  return;  //  All done  //

               elsif Opcode(Next) == #Store_Int_Lit_Op
                  //  See if we have call on store-int-lit and to_bool
                 and then Opcode(NNex) == #Call_Op
                 and then Desig_NNex not null
                 and then Desig_NNex == "#ordering_to_bool"
                 and then
                   //  And make sure parameters match up
                   //  =?'s output is input to to_bool
                   Base(Params(Instr)) == Base(Params_NNex)
                 and then
                   Offset(Params(Instr)) == Offset(Params_NNex) + 1
                   //  Store Int is input to to_bool
                 and then
                   Base(Destination(Next)) == Base(Params_NNex)
                 and then
                   Offset(Destination(Next)) == Offset(Params_NNex) + 2
                   //  No intervening labels
                 and then
                   not TLO.Has_Label(I <.. I + 2)
               then
                  //  All the conditions are satisfied, we can use the
                  //  icmp or fcmp instruction instead of the compare.
                  TLO |= "; =? + to-bool optimization";
                  const Result := Do_Inline_Compare(Next.Int_Value())
                  //  Result now holds an i1 that is the result
                  //  of the comparison (for floats or ints)

                  func Store_Comparison_Result() is
                     //  Zero extend and store comparison result
                     const Result_Ext := Result | "_zext";
                     const Result_Ptr  := "%_result_ptr" | UI;

                     TLO |= Result_Ext | " = zext i1 "| Result | " to i64";
                     Store_Via_Locator(Params_NNex, Result_Ptr, Result_Ext,
                                       Instr_Look_Ahead => 2)
                  end func Store_Comparison_Result

                  //  See whether next instruction is an "if_op"
                  const If_Offs := 3
                  if I + If_Offs <= Num_Instrs_In_Routine then
                     const If_Instr :=
                       Operation_Routine.Nth_Instr(I + If_Offs);
                     if Is_Optimizable_If (If_Instr, Params_NNex, If_Offs) then
                        //  We are followed by an if_op; incorporate that
                        //  into the generated code
                        Emit_If_Branch(Result, If_Instr, If_Offs);

                        //  We generated code for three extra instructions
                        Look_Ahead_Count := If_Offs;

                        return;  //  All done  //
                     end if
                  end if

                  //  Zero extend and store
                  Store_Comparison_Result()

                  //  We generated code for two extra instructions
                  Look_Ahead_Count := 2;

               else
                  //  Compare cannot be optimized
                  Call_Builtin_Op(Name, In_Is_i64 => not Is_Real_Op);
               end if
            end func Call_Compare_Op

            //  If we are using locking, then don't try to inline the call.

            if Locked_Param_Info > 0 then
               Call();
               TLO.Next_PSIR_Instr();
               return;
            end if

            if Desig is null then
               Call(); //  Not a built-in
            else
               //  A non-null designator means it's a builtin
               //  Some builtins are simple enough to be inlined in llvm

               case Desig of
                  ["\"+\""] =>
                     //  nsw = "no signed wrap"
                     //  it means treat them as signed numbers and
                     //  overflow results in an llvm poison value
                     Binary_Op("add nsw");
                  ["\"-\""] =>
                     Binary_Op("sub nsw");
                  ["\"*\""] =>
                     Binary_Op("mul nsw");
                  ["\"/\""] =>
                     Binary_Op("sdiv");
                  ["\"<<\""] =>
                     //  shift left
                     Binary_Op("shl");
                  ["\">>\""] =>
                     //  arithmetic shift right
                     Binary_Op("ashr");
                  ["\"mod\""] =>
                     //  using this equivalence
                     //  a mod n == ((a rem n) + n) rem n

                     //  Assign unique llvm identifiers
                     const A              := "%_a"              | UI;
                     const N              := "%_n"              | UI;
                     const A_Rem_N        := "%_a_rem_n"        | UI;
                     const A_Rem_N_Plus_N := "%_a_rem_n_plus_n" | UI;
                     const Result         := "%_result"         | UI;

                     //  Get arguments
                     Load_Call_Param (1, A, UID_Extra => 1);
                     Load_Call_Param (2, N, UID_Extra => 2);

                     //  Result := ((a rem n) + n) rem n
                     TLO |= A_Rem_N | " = srem i64 `(A), " | N;
                     TLO |= A_Rem_N_Plus_N | " = add nsw i64 " | A_Rem_N |
                           ", " | N;
                     TLO |= Result | " = srem i64 " | A_Rem_N_Plus_N |
                           ", " | N;

                     //  Store Result
                     Store_Call_Result(Result, UID_Extra => 3);
                  ["\"rem\""] =>
                     Binary_Op("srem");
                  ["\"and\"" | "#bit_and"] =>
                     Binary_Op("and");
                  ["\"or\"" | "#bit_or"] =>
                     Binary_Op("or");
                  ["\"xor\"" | "#bit_xor"] =>
                     Binary_Op("xor");
                  ["\"+=\""] =>
                     //  nsw = 'no signed wrap'
                     //  overflow results in llvm 'poison'
                     Assign_Binary_Op("add nsw");
                  ["\"-=\""] =>
                     Assign_Binary_Op("sub nsw");
                  ["\"*=\""] =>
                     Assign_Binary_Op("mul nsw");
                  ["\"/=\""] =>
                     Assign_Binary_Op("sdiv");
                  ["#real_add"] =>
                     Binary_Op("fadd", "double");
                  ["#real_subtract"] =>
                     Binary_Op("fsub", "double");
                  ["#real_multiply"] =>
                     Binary_Op("fmul", "double");
                  ["#real_int_multiply"] =>
                     //  convert second arg by signed int to floating point
                     //  Instead of the usual bitcast
                     Binary_Op("fmul", "double", "sitofp");
                  ["#real_int_divide"] =>
                     Binary_Op("fdiv", "double", "sitofp");
                  ["#real_divide"] =>
                     Binary_Op("fdiv", "double");
                  ["#real_exp"] => 
                     Intrinsic_Double_Int("powi");
                  ["#real_assign_exp"] =>
                     Assign_Intrinsic_Double_Int("powi");
                  ["\"**\""] => 
                     //  TBD: Check for "2 ** X" and use "1 << X"
                     Call();  //  Use out-of-line exponentiation
                  ["\"**=\""] =>
                     Call();  //  Use out-of-line exponentiation
                  ["#real_assign_add"] =>
                     Assign_Binary_Op("fadd", "double");
                  ["#real_assign_subtract"] =>
                     Assign_Binary_Op("fsub", "double");
                  ["#real_assign_multiply"] =>
                     Assign_Binary_Op("fmul", "double");
                  ["#real_assign_divide"] =>
                     Assign_Binary_Op("fdiv", "double");
                  ["#identity`("#integer_from_univ")#integer_to_univ"] =>
                     //  Copy from Params[1] to Params[0]
                     const Result := "%_result" | UI;
                     const Output_Is_By_Ref :=
                       Parameters(Routine)[1].Is_Passed_By_Ref;
                     const Ptr_Level := Output_Is_By_Ref? 1 : 0;

                     Load_Call_Param(1, Result,
                       Ptr_Level => Ptr_Level);
                     Store_Call_Result(Result, Ptr_Level => Ptr_Level);
                  ["#negate"] =>
                     //  -x == 0 - x
                     Unary_Op("sub i64 0,");
                  ["#real_negate"] =>
                     Unary_Op("fsub double 0.0,",
                        Type => "double");
                  ["#bit_not"] =>
                     //  llvm doesn't have 'not'
                     //  bit-not X == xor X, -1
                     Unary_Op("xor i64 -1,");
                  ["\"not\""] =>
                     //  llvm doesn't have 'not'
                     //  not X == xor X, 1 
                     Unary_Op("xor i64 1,");
                  ["#round_to_int"] =>
                     //  floating point to signed int
                     Unary_Op("@llvm.round.f64");
                  ["#int_to_real"] =>
                     //  signed int to floating point
                     Unary_Op("sitofp");
                  ["\"abs\""] =>
                     //  http://graphics.stanford.edu/~seander/
                     //  bithacks.html#IntegerAbs

                     //  func abs(n : i64) -> i64 is
                     //     mask := n >> 63
                     //     return (mask + n) xor mask

                     //  Assign unique llvm identifiers
                     const Mask        := "%_mask"       | UI;
                     const Mask_Plus_N := "%_mask_n"     | UI;
                     const N           := "%_n"          | UI;
                     const Result      := "%_result"     | UI;

                     //  Compute absolute value
                     Load_Call_Param (1, N, UID_Extra => 1);
                     TLO |= Mask | " = ashr i64 `(N), 63";
                     TLO |= Mask_Plus_N | " = add i64 `(Mask), " | N;
                     TLO |= Result | " = xor i64 `(Mask_Plus_N), " | Mask;

                     //  Store result
                     Store_Call_Result(Result, UID_Extra => 2);
                  ["#real_abs"] =>
                     Unary_Op("@llvm.fabs.f64",
                        Type => "double");
                  ["#real_compare"] =>
                     Call_Compare_Op("@_psc_real_compare_op",
                        Is_Real_Op  => #true);
                  ["#real_min"] =>
                     Call_Builtin_Op("@_psc_univ_real_min_op",
                        In_Is_i64  => #false,
                        Out_Is_i64 => #false);
                  ["#real_max"] =>
                     Call_Builtin_Op("@_psc_univ_real_max_op",
                        In_Is_i64  => #false,
                        Out_Is_i64 => #false);
                  ["\"=?\""] => Call_Compare_Op("@_psc_word_compare_op");
                  ["#ordering_to_bool"] =>
                     //  Pretend is an LLVM op (special cased in Binary_Op)
                     Binary_Op(Desig);
                  ["#min"] => Call_Builtin_Op("@_psc_word_type_min_op");
                  ["#max"] => Call_Builtin_Op("@_psc_word_type_max_op");
                  ["\"null\""] => null;
                  ["#basic_array_length"] =>
                     //  func Length(V : Basic_Array) -> Univ_Integer<>
                     if not Virt_Is_Phys then
                        //  Call basic_array_length out of line.
                        Call();
                     else
                        //  Emit basic_array_length inline.
                        //  TBD: Doesn't check for null.

                        //  Assign unique llvm identifiers
                        const Arr_Ptr     := "%_arr_ptr"   | UI;
                        const Len_Addr    := "%_arr_base"  | UI;
                        const Result      := "%_resul"     | UI;

                        //  get argument
                        Load_Call_Param(1, Arr_Ptr,
                           Ptr_Level => 1,
                           UID_Extra => 1);

                        //  Len_Addr := Arr_Ptr + 1
                        TLO |= Len_Addr | " = getelementptr i64, i64* " |
                           Arr_Ptr | ", i64 1";

                        TLO |= Result | " = load i64, i64* " | Len_Addr;

                        Store_Call_Result(Result, UID_Extra => 2);
                     end if

                  ["#basic_array_indexing"] =>
                     //  op "indexing"
                     //     (ref V : Basic_Array; Index : Univ_Integer<>)
                     //      -> ref Element_Type
                     if not Virt_Is_Phys then
                        //  Call basic_array_indexing out of line.
                        Call();
                     else
                        //  Emit basic_array_indexing inline.
                        //  TBD: Doesn't do any array bounds checking!

                        //  Assign unique llvm identifiers
                        const Arr_Ptr     := "%_arr_ptr"   | UI;
                        const Arr_Base    := "%_arr_base"  | UI;
                        const Index       := "%_index_arg" | UI;
                        const Result_Addr := "%_resul_addr"| UI;

                        //  get array argument
                        Load_Call_Param (1, Arr_Ptr,
                           Num_Indir => 1,
                           Ptr_Level => 1,
                           UID_Extra => 1);

                        //  Arr_Base := Obj + 1
                        TLO |= Arr_Base | " = getelementptr i64, i64* " |
                          Arr_Ptr | ", i64 1";

                        // get index argument
                        Load_Call_Param(2, Index,
                          UID_Extra => 2);

                        //  Result_Addr := Arr_Base + Index
                        TLO |= Result_Addr | " = getelementptr i64, i64* " |
                          Arr_Base | ", i64 " | Index;
                        Store_Call_Result(Result_Addr,
                             Ptr_Level => 1,
                             UID_Extra => 3);
                     end if

                  [..] => Call(); //  Built-ins that aren't llvm inlined
               end case
            end if

         [#Return_Op | #Exit_Op] =>
            //  TODO Return_Op postcondition proved
            const Is_Return := Opcode(Instr) == #Return_Op;
            const Is_Exit := not Is_Return;

            if not OCS.Inline_Stack.Is_Empty() then
               //  Exit's not permitted in inlined code, so must be a return.
               {Is_Return}

               if I < Num_Instrs_In_Routine then
                  //  Not the last instruction, so jump to the last instruction
                  const Inline_Ret := TLO.Add_Label
                                         (Num_Instrs_In_Routine - I - 1);
                  TLO |= "br label " | Inline_Ret;
               end if
               TLO.Next_PSIR_Instr();
               return;
            end if

            Finalize_If_Needed(TLO, Stg_Rgn_Is_Available);
            
            if Is_Exit then
               {Instr.Level_Diff() - 1 >= 0}
               {Instr.Skip_Count() >= 0}
               const LD : Int := Instr.Level_Diff() - 1;
               const SC : Int := Instr.Skip_Count();
               //  Build the 32 bit result with the level diff as
               //  the high 16 bits and the skip count as the low 16 bits
               const Result : Int := 2**16 * LD + SC;
               TLO |= "ret i32 " | Result;
            elsif Instr_In_Nested_Block then
               //  Want to return from enclosing function
               //  Pass a level diff that will never reach zero by subtraction
               //  (Level_Diff => -1, Skip => 0) == 0xFFFF0000
               TLO |= "ret i32 " | 0xFFFF0000;
            else
               //  Not in block, no llvm return value
               Return_From_LLVM_Func()
            end if

         [#Copy_Word_Op] =>
            Copy_Word(Instr.Source(), Instr.Destination());

         [#Copy_Address_Op] =>
            Copy_Word(Instr.Source(), Instr.Destination(), Ptr_Level => 1);

         [#Store_Address_Op] =>
            //  Assign unique llvm identifiers
            const Addr := "%_addr" | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;
            const Dest_Ptr_Ptr := "%_dest_ptr_Ptr" | UI;

            //  Get source address
            Get_Locator_Ptr(Instr.Source(), Addr, UID_Extra => 1);

            //  Store source address into destination
            Store_Via_Locator
              (Instr.Destination(), Dest_Ptr, Addr,
               Ptr_Level => 1, UID_Extra => 2);

         [#Declare_Obj_Op] =>
            // Allocate local variable if appropriate
            const Dest_Loc := Instr.Destination()

            if Base(Dest_Loc) == Local_Area
              and then VM_Is_Indir (Dest_Loc)
            then
               //  Allocate a variable
               const Dest_Loc_Num := Adjusted_VM_Num(Dest_Loc);
               const Dest_Loc_Name := Adjusted_VM_Name(Dest_Loc);
                
               TLO |= Dest_Loc_Name | " = alloca i64";
               Set_VM_Reg_Is_Ptr (Dest_Loc_Num);

               if Dest_Loc_Num in TLO.Uplevels[OCS.Cur_Node] then
                  //  Save address into frame record
                  const Off :=
                    TLO.VM_Frame_Offsets[OCS.Cur_Node][Dest_Loc_Num]
                  const Val := "%_val" | UI;
                  const Addr := "%_addr" | UI;
                  TLO |= Val | " = ptrtoint i64* " | Dest_Loc_Name |
                     " to i64;"
                  TLO |= Addr |
                    " = getelementptr i64, i64* %_Local_Area, i64 " | Off;
                  TLO |= "store i64 `(Val), i64* " | Addr;
               end if
            end if

         [#Create_Obj_Op] =>
            //  Assign unique llvm identifiers
            const Dest_Addr := "%_dest_addr" | UI;
            const Dest_Val  := "%_dest"      | UI;
            const Desc      := "%_desc"      | UI;
            const Src_Addr  := "%_src_addr"  | UI;
            const Src_Val   := "%_src"       | UI;

            //  Get arguments
            Load_Type_Desc(Instr.Type_Info(), Desc);
            const Source_Loc := Instr.Source()

            if Source_Loc.Base() == Zero_Base then
               TLO |= Src_Val | " = bitcast i64 0 to i64"
               //  Created object is for the local region
               Set_VM_Reg_Is_For_Local (Dest_Val);
            else
               Load_Via_Locator(Source_Loc, Src_Addr, Src_Val, UID_Extra => 2);
               //  Propagate whether object is for the local region
               Set_VM_Reg_Is_For_Local (Dest_Val,
                                        VM_Reg_Is_For_Local(Src_Val));
            end if

            //  Call run time system builtin
            if TLO.Use_Stack_For_Objects then
               if VM_Reg_Is_For_Local (Dest_Val) then
                  if Debug_VM_Reg_Info_Prop then
                     Put_Error ("new object " | Dest_Val |
                       " could be on stack",
                       Instr.Source_Pos(), Message_Kind => "Info");
                  end if;
               end if;
            end if;
            const Func := "@_psc_new_object";
            TLO.Declare(Func, "i64 `(Func)(i64*, i64*, i64)");
            TLO |= Dest_Val | " = call i64" | Func |
              "(i64* %_Context, i64* `(Desc), i64 `(Src_Val))";
            Store_Via_Locator(Instr.Destination(), Dest_Addr, Dest_Val,
              UID_Extra => 1)

         [#Assign_Word_Op] =>
            //  Assign llvm identifiers
            const Desc       := "%_desc"       | UI;
            const Dest_Ptr   := "%_dest_ptr"   | UI;
            const Source     := "%_source"     | UI;
            const Source_Ptr := "%_source_ptr" | UI;

            //  Get arguments
            Load_Type_Desc(Instr.Type_Info(), Desc);
            Load_Via_Locator
              (Instr.Source(), Source_Ptr, Source, UID_Extra => 1);
            Get_Locator_Ptr(Instr.Destination(), Dest_Ptr, UID_Extra => 2);

            //  Call _psc_assign_word
            TLO.Declare("_psc_assign_word",
              "void @_psc_assign_word(i64*, i64*, i64*, i64)");
            TLO |= "call void @_psc_assign_word(i64* %_Context, i64* " |
               Desc | ", i64* `(Dest_Ptr), i64 `(Source))";

         [#Swap_Obj_Op] =>
            //  Assign llvm identifiers
            const Desc := "%_desc" | UI;
            const Source_Ptr := "%_source_ptr" | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;

            //  Get arguments
            Get_Locator_Ptr(Instr.Source(), Source_Ptr, UID_Extra => 1);
            Get_Locator_Ptr(Instr.Destination(), Dest_Ptr, UID_Extra => 2);
            Load_Type_Desc(Instr.Type_Info(), Desc);

            //  Call _psc_swap_object
            TLO.Declare("_psc_swap_object",
                        "void @_psc_swap_object(i64*, i64*, i64*, i64*)");
            TLO |= "call void @_psc_swap_object(i64* %_Context, i64* " | Desc |
               ", i64* `(Dest_Ptr), i64* `(Source_Ptr))";

         [#Move_Obj_Op] =>
            //  Assign unique llvm identifiers
            const Source_Ptr := "%_source_ptr" | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;
            const Desc := "%_desc" | UI;

            //  Get arguments
            Get_Locator_Ptr(Instr.Source(), Source_Ptr, UID_Extra => 1);
            Get_Locator_Ptr(Instr.Destination(), Dest_Ptr, UID_Extra => 2);
            Load_Type_Desc(Instr.Type_Info(), Desc);

            //  call _psc_move_object
            TLO.Declare("_psc_move_object",
                        "void @_psc_move_object(i64*, i64*, i64*, i64*)");
            TLO |= "call void @_psc_move_object(i64* %_Context, i64* " | Desc |
               ", i64* `(Dest_Ptr), i64* `(Source_Ptr))";

         [#Make_Copy_In_Stg_Rgn_Op] =>
            //  Assign identifers and get arguments
            const Source_Ptr   := "%_source_ptr"   | UI;
            const Source       := "%_source"       | UI;
            const Result       := "%_result"       | UI;
            const Dest_Ptr     := "%_dest_ptr"     | UI;
            const Existing_Ptr := "%_existing_ptr" | UI;
            const Existing_Obj := "%_existing_obj" | UI;
            const Desc         := "%_desc"         | UI;

            Load_Type_Desc(Instr.Type_Info(), Desc);

            Load_Via_Locator
              (Instr.Source(), Source_Ptr, Source, UID_Extra => 2)
            Load_Via_Locator
              (Instr.Existing_Obj_In_Stg_Rgn(), Existing_Ptr, Existing_Obj,
               UID_Extra => 3);

            //  Call _psc_copy_object
            if TLO.Use_Stack_For_Objects then
               if VM_Reg_Is_For_Local (Existing_Obj) then
                  if Debug_VM_Reg_Info_Prop then
                     Put_Error ("copied object " | Result |
                       " could be on stack",
                       Instr.Source_Pos(), Message_Kind => "Info");
                  end if;
               end if;
            end if;
            const Fn_Name := "@_psc_copy_object";
            TLO.Declare(Fn_Name, "i64 `(Fn_Name)(i64*, i64*, i64, i64)");
            TLO |= Result | " = call i64 " | Fn_Name |
                      "(i64* %_Context, i64* " | Desc |
                      ", i64 `(Source), i64 `(Existing_Obj))";

            //  Propagate whether is for local obj
            Set_VM_Reg_Is_For_Local (Result,
                                     VM_Reg_Is_For_Local (Existing_Obj));

            Store_Via_Locator
              (Instr.Destination(), Dest_Ptr, Result, UID_Extra => 1);

         [#Store_Local_Null_Op] =>
            //  Assign identifiers and get arguments
            const Null     := "%_null"     | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;
            const Null_Type_Loc := Null_Type_Info(Instr);

            Load_Null(Null_Type_Loc, Null);

            //  Store null into destination
            Store_Via_Locator
              (Instr.Destination(), Dest_Ptr, Null, UID_Extra => 1);

         [#Store_Large_Local_Null_Op] =>
            const Null     := "%_null"     | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;

            if Instr.Local_Addr().Base() == Local_Area then
               //  In local area of current routine
               Type_Desc_LLVM_Utils::Get_Large_Local_Null(TLO, UI, Null);
               Set_VM_Reg_Is_For_Local (Null);
            else
               //  In local area of enclosing routine
               const Local    := "%_Local"    | UI;
               TLO.Declare("_psc_large_local_null",
                           "i64 @_psc_large_local_null(i64*)");
               Get_Locator_Ptr(Instr.Local_Addr(), Local,
                             UID_Extra => 2);
               TLO |= Null | 
                  " = call i64 @_psc_large_local_null(i64* `(Local))";
            end if

            //  Store null into destination
            Store_Via_Locator
              (Instr.Destination(), Dest_Ptr, Null, UID_Extra => 1);

         [#Store_Null_Of_Same_Stg_Rgn_Op] =>
            //  Assign identifiers and get arguments
            const Null_Type_Loc := Instr.Type_Info()
            const Null := "%_null" | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;

            //  Get null in same region as Source
            Load_Null(Null_Type_Loc, Null, In_Same_Region_As => Instr.Source())

//             const Desc := "%_desc" | UI;
//             const Source_Ptr := "%_source_ptr" | UI;
//             const Source_Val := "%_source" | UI;
// 
//             Load_Type_Desc(Instr.Type_Info(), Desc);
//             Load_Via_Locator(Instr.Source(), Source_Ptr, Source_Val,
//                              UID_Extra => 1);
// 
//             // call RTS builtin
//             const Func := "@_psc_null_of_same_stg_rgn";
//             TLO.Declare(Func, "i64 `(Func)(i64*, i64)");
//             TLO |= Null | " = call i64 `(Func)(i64* " |
//                      Desc | ", i64 `(Source_Val))";

            //  Store null into destination
            Store_Via_Locator
              (Instr.Destination(), Dest_Ptr, Null, UID_Extra => 2);

         [#Is_Null_Op | #Not_Null_Op] =>
            const Result_Bit := "%_result_bit" | UI;

            Test_For_Null(Type_Loc => Instr.Type_Info(),
              Value_Loc => Instr.Source(),
              Result_Bit => Result_Bit,
              For_Not_Null => Opcode(Instr) == #Not_Null_Op);

            //  Check whether next PSVM instruction is an "if"
            const Next := Operation_Routine.Nth_Instr(I + 1);

            if Is_Optimizable_If(Next, Instr.Destination(), If_Offs => 1) then
               //  No need to extend to 64 bits nor to store result
               TLO |= "; null-test + if-op optimization";
               Emit_If_Branch (Result_Bit, Next, If_Offs => 1);

               //  We generated code for one extra instruction
               Look_Ahead_Count := 1;
            else
               //  Extend to 64 bits and store into destination
               const Result_Ext := "%_result_ext" | UI;
               const Result_Ptr := "%_result_ptr" | UI;

               TLO |= Result_Ext | " = zext i1 `(Result_Bit) to i64"
               Store_Via_Locator
                 (Instr.Destination(), Result_Ptr, Result_Ext, UID_Extra => 2);
            end if;

         [#Store_Int_Lit_Op] =>
            const DestID := "%_dest" | UI;

            //  Store the source value into the destination
            Store_Via_Locator
              (Instr.Destination(), DestID, To_String(Instr.Int_Value()),
               UID_Extra => 1);

         [#Store_Real_Lit_Op] =>
            const DestID := "%_dest" | UI;
            const Val    := "%_val"  | UI;

            //  bitcast from double to i64
            TLO |= Val | " = bitcast double `(Instr.Real_Value()) to i64";

            //  Store the source value into the destination
            Store_Via_Locator
              (Instr.Destination(), DestID, Val, UID_Extra => 1);

         [#Store_Char_Lit_Op] =>
            const DestID := "%_dest" | UI;

            //  Store the character as unicode into the destination
            Store_Via_Locator
              (Instr.Destination(), DestID,
               To_String(Instr.Char_Value() - Char::First()), UID_Extra => 1);

         [#Store_Enum_Lit_Op] =>
            const DestID := "%_dest" | UI;

            //  Store the reconstructed enum into the destination
            const Enum_Val := "%_enum_val" | UI
            //  Note that univ-string and univ-enum use the same string table.
            Get_Recon_String_Id
              (To_String(Instr.Enum_Value()), Gets => Enum_Val);

            Store_Via_Locator
              (Instr.Destination(), DestID, Enum_Val, UID_Extra => 1);

         [#Store_Str_Lit_Op] =>
            const DestID := "%_dest" | UI;

            //  Store the reconstructed string into the destination
            const Str_Id_Val := "%_str_id_val" | UI
            const Str_Val := "%_str_val" | UI

            Get_Recon_String_Id(Instr.Str_Value(), Gets => Str_Id_Val);
            if not Is_Null_Locator(Instr.Existing_Str_In_Stg_Rgn()) then
               //  Region was specified
               const ExistingID := "%_existing" | UI;
               const Existing_ValID := "%_existing_val" | UI;

               //  Read the value of the existing obj
               Load_Via_Locator
                 (Instr.Existing_Str_In_Stg_Rgn(), ExistingID, Existing_ValID,
                  UID_Extra => 2);
               //  Create a string value in Str_Val based on Str_Id_Val
               //  and region of Existing_ValID
               Type_Desc_LLVM_Utils::Get_Str(TLO, UI, Str_Id_Val, Str_Val,
                  In_Same_Region_As => Existing_ValID);
            else
               //  Create a string value in Str_Val based on Str_Id_Val
               //  implicitly in local region
               Type_Desc_LLVM_Utils::Get_Str(TLO, UI, Str_Id_Val, Str_Val);
            end if;

            Store_Via_Locator
              (Instr.Destination(), DestID, Str_Val, UID_Extra => 1);

         [#Store_Operation_Desc_Op] =>
            const Operation_Static_Link := "%_operation_static_link" | UI;
            const Op_Desc               := "%_op_desc"               | UI;
            var Target_Func             := "null";
            const Default_Func_Type     := "void(i64*, i64*, i64*)*";
            var Func_Type               := Default_Func_Type;
            var Conv_Desc : Reflection::Routine::Convention_Descriptor :=
              (Encoding => 0);

            //  Get locators for convenience
            const Op_Loc := Instr.Operation_Locator();
            const SL_Loc := Instr.Operation_Static_Link()
            const SL_Base := Base(SL_Loc);

            const Routine_TDesc := Routine_And_TDesc_For_Call(Op_Loc, SL_Loc);
            const Target_Routine := Routine_TDesc.First;
            //  Don't find the name if it's Type_Area because there are
            //  some builtins without exported names. Those need to be
            //  called indirectly
            if Target_Routine not null and Base(Op_Loc) != Type_Area then
               Target_Func := Get_LLVM_Name(Target_Routine);
               Func_Type := LLVM_Function_Profile (Target_Routine, "") | "*";
               Conv_Desc := Target_Routine.Conv_Desc();
            end if

            if SL_Base == Zero_Base or SL_Base == Type_Area or
               SL_Base in Enclosing_Type_Areas then
               Load_Type_Desc(SL_Loc, Operation_Static_Link,
                  Routine_TDesc.Second);
            else
               Get_Locator_Ptr(SL_Loc, Operation_Static_Link);
            end if

            //  Call out-of-line function
            const Create := "@_psc_create_operation_desc";
            TLO.Declare(Create,
                        "i64 `(Create)(i64*, i16, i16, i16, i16, i32, " |
               "i64*, void(i64*, i64*, i64*)*)");
            TLO |= Op_Desc | " = call i64 " | Create |
               "(i64* %_Context, i16 " |
               Base(Op_Loc) | ", i16 `(Offset(Op_Loc)), i16 " |
               SL_Base | ", i16 " | Offset(SL_Loc) |
               ", i32 " | Conv_Desc.Encoding |
               ", i64* " | Operation_Static_Link |
               ", `(Default_Func_Type) bitcast(`(Func_Type) " |
               Target_Func | " to `(Default_Func_Type)))";

            //  Store Operation Descriptor into the Destination
            const Dest_Ptr := "%_dest_ptr" | UI;
            Store_Via_Locator
              (Instr.Destination(), Dest_Ptr, Op_Desc, UID_Extra => 1);

         [#Store_Type_Related_Const_Op] =>
            const TDesc    := "%_tdesc"    | UI;
            const Val      := "%_val"      | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;

            //  Get inputs to out-of-line function
            Load_Type_Desc(Instr.Source_Type_Info(), TDesc);

            //  Note: it's Offset then Base here
            const Nth := "@_psc_nth_type_area_word";
            TLO.Declare(Nth, "i64 `(Nth)(i64*, i16, i16)");
            TLO |= Val | " = call i64 `(Nth)(i64* `(TDesc), i16 " |
               Offset(Instr.Source()) | ", i16 `(Base(Instr.Source())))";

            //  Store output from out-of-line function
            Store_Via_Locator(Instr.Destination(), Dest_Ptr, Val);

         [#Start_Parallel_Op | #Add_Parallel_Op |
          #Start_Parallel_Call_Op | #Add_Parallel_Call_Op] =>
            //  TODO: Precond Proved

            {OCS.Inline_Stack.Is_Empty()}  //  Not allowed in an inlining

            const Op := Opcode(Instr);
            const Is_Start_Op := (Op == #Start_Parallel_Op or
               Op == #Start_Parallel_Call_Op);
            const Is_Block_Op := (Op == #Start_Parallel_Op or
               Op == #Add_Parallel_Op);
            const Tcb_Is_Local :=
               Base(Instr.Parallel_Control()) == Local_Area;

            //  llvm identifiers
            const Master      := "%_master"      | UI;
            const Control     := VM_Name(Instr.Parallel_Control())
            const Static_Link_Reg := "%_static_Link" | UI;

            Get_Locator_Ptr(Instr.Parallel_Master(), Master, UID_Extra => 1);

            const Instr_PSL := Instr.Parallel_Static_Link();
            const SL_Base := Base(Instr_PSL);
            const SL_Offset := Offset(Instr_PSL);

            //  TBD: We don't support uplevel references to TCB register
            {OCS.Cur_Node not in TLO.Uplevels or else
              Instr.Parallel_Control().VM_Num() not in
                TLO.Uplevels[OCS.Cur_Node]}

            var Type_Desc_To_Use :
               optional Reflection::Type_Descriptor := null;

            //  Declare variables that will be parameters to the
            //  call on _psc_execute_...
            var Code_Name : String;
            var Code_Type : String;
            var Indirect : Bool := #false;
            var Execute : String;
            var Uses_Queuing : Bool := #false;
            const Internal_Precond_Type := "i32(i64*, i64*, i64*)*";
            var Internal_Precond_Name := "null";

            var CT_Base : Reflection::Object_Locator::Area_Base_Indicator;
            var CT_Offset : Reflection::Offset_Within_Area;
            var Routine : optional Reflection::Routine := null;

            if Is_Block_Op then
               const Block_Desc := Instr.Parallel_Code_Block();
               const Internal_Precond := Operation_Routine.Internal_Precond();
               const Is_Internal_Precond :=
                 Internal_Precond not null and then
                   Block_Desc == Internal_Precond;
               Uses_Queuing := Block_Desc.Uses_Queuing;
               Code_Name := 
                  LLVM_Printer::Get_Block_Name(I + Block_Desc.Pc_Offset,
                    Is_Internal_Precond, Get_LLVM_Name(Operation_Routine));
               Code_Type := "i32(i64*, i64*, i64*)*";
            else
               const Target := Instr.Parallel_Call_Target();
               CT_Base := Base(Target);
               CT_Offset := Offset(Target);
               const Routine_TDesc := Routine_And_TDesc_For_Call
                  (Target, Instr_PSL);

               Type_Desc_To_Use := Routine_TDesc.Second;
               const Routine_To_Call := Routine_TDesc.First;
               Routine := Routine_To_Call;

               if Routine is null then
                  //  Determine Routine from target index
                  Routine := Routine_At_Index(Instr.Parallel_Target_Index());
               end if

               if Routine_To_Call is null then
                  //  Name is not compile time known, Go indirect
                  Indirect := #true;
                  Code_Type := "";  //  not used
               else
                  //   Name is compile time known, Go direct
                  Code_Name := Get_LLVM_Name(Routine);

                  //  If queued, need to pass Internal_Precond
                  if Instr.Parallel_Is_Queued_Call() and
                     Routine.Built_In_Desig() is null
                  then
                     Internal_Precond_Name :=
                        //  The integer parameter is ignored if
                        //  Internal_Precond is #true. So, just pass zero
                        LLVM_Printer::Get_Block_Name
                          (0, Is_Internal_Precond => #true,
                           Fn_Name => Code_Name);
                     //  Declare the internal precondition
                     //  because it may not be in this file
                     TLO.Declare(Internal_Precond_Name,
                        "i32 " | Internal_Precond_Name |
                        "(i64*, i64*, i64*)");
                  end if

                  Code_Type := "void(i64*, i64*, i64*)*";

               end if

            end if

            //  Get Type descriptor or uplevel pointer from Static Link Locator
            if SL_Base == Zero_Base or SL_Base == Type_Area or
               SL_Base in Enclosing_Type_Areas then
               //  Static link refers to a type descriptor
               Load_Type_Desc(Instr_PSL, Static_Link_Reg, Type_Desc_To_Use);
            else
               //  Static link refers to an enclosing stack frame
               Get_Locator_Ptr(Instr_PSL, Static_Link_Reg, UID_Extra => 3);
            end if
            
            //  Get flag values
            const Is_Start_Flag := Is_Start_Op? 1 : 0;
            const Tcb_Is_Local_Flag := Tcb_Is_Local? 1 : 0;

            //  Set up TCB and parameter area
            Setup_Params_For_Call(Routine, Control, Is_Parallel => #true,
              UID_Extra => 2);

            //  Call out-of-line to Spawn thread etc.
            if Is_Block_Op then
               //  Parallel invocation of a nested block
               Execute := "@_psc_execute_compiled_parallel_op";

               TLO.Declare(Execute, "void `(Execute)(i64*, i64*, i64*, " |
                  "`(Code_Type), i64* , i1, i1, i1)");

               TLO |= "call void `(Execute)(i64* %_Context, i64* `(Master), " |
                  "i64* `(Control), `(Code_Type) `(Code_Name), " |
                  "i64* `(Static_Link_Reg), i1 `(Uses_Queuing - #false), " |
                  "i1 `(Tcb_Is_Local_Flag), i1 `(Is_Start_Flag))"
            elsif Indirect then
               //  Parallel call on routine unknown at compile-time
               Execute := "@_psc_execute_compiled_indirect_parallel_call_op";

               TLO.Declare(Execute, "void `(Execute)(i64*, i64*, i64*, " |
                  "i16, i16, i64*, i16, i16, i1, i1, i8)");
               TLO |= "call void `(Execute)(i64* %_Context, i64* `(Master), " |
                  "i64* `(Control), i16 `(CT_Base), i16 `(CT_Offset), " |
                  "i64* `(Static_Link_Reg), i16 `(SL_Base), " |
                  "i16 `(SL_Offset), " |
                  "i1 `(Tcb_Is_Local_Flag), i1 `(Is_Start_Flag), " |
                  "i8 `(Instr.Parallel_Locked_Param_Info()))";
            else
               //  Parallel call on known routine
               const Code_Profile := LLVM_Function_Profile (Routine, Code_Name);
               const Code_Name_Type :=
                       LLVM_Function_Profile (Routine, "") | "*";

               TLO.Declare (Code_Name, Code_Profile);

               Execute := "@_psc_execute_compiled_parallel_call_op_conv";

               TLO.Declare(Execute, "void `(Execute)(i64*, i64*, i64*, " |
                  "`(Code_Type), i64*, " |
                  "`(Internal_Precond_Type), i1, i1, i8, i32)");
               TLO |= "call void `(Execute)(i64* %_Context, i64* `(Master), " |
                  "i64* `(Control), `(Code_Type) " |
                  "bitcast(`(Code_Name_Type) `(Code_Name) to `(Code_Type)), " |
                  "i64* `(Static_Link_Reg), " |
                  "`(Internal_Precond_Type) `(Internal_Precond_Name), " |
                  "i1 `(Tcb_Is_Local_Flag), i1 `(Is_Start_Flag), " |
                  "i8 `(Instr.Parallel_Locked_Param_Info()), " |
                  "i32 `(Conv_Desc(Routine).Encoding))";
            end if;
           
            //  Retrieve output parameter, if any
            Finish_Params_After_Call(Routine, Control, Is_Parallel => #true)

         [#Prepare_To_Exit_Parallel_Op] =>
            //  Assign unique identifiers
            const First_Exit := "%_first_exit" | UI;
            const Master     := "%_master"     | UI;

            //  Handle labels
            const Next_Instr := TLO.Add_Label(0);
            const Exit_Now   := "_exit_now"    | UI;

            //  Get argument
            Get_Locator_Ptr(Instr.Parallel_Master(), Master);

            //  Call out-of-line
            const Execute := "@_psc_execute_prepare_to_exit_parallel_op";
            TLO.Declare(Execute, "i1 `(Execute)(i64*, i64*)");
            TLO |= First_Exit | " = call i1 `(Execute)(i64* %_Context" | 
               ", i64* `(Master))";
            
            //  If this thread is first to Prepare_To_Exit, then continue
            //  running, otherwise exit now (with "normal" outcome).
            TLO |= "br i1 `(First_Exit), label " | Next_Instr | //  True
                                          ", label %" | Exit_Now;   //  False
            TLO |= Exit_Now | ":";

            Finalize_If_Needed(TLO, Stg_Rgn_Is_Available);

            //  (Level_Diff => 0, Skip => 0) == 0
            TLO |= "ret i32 0";
         [#Wait_For_Parallel_Op] =>
            //  Assign identifiers and get arguments
            const Master := "%_master" | UI;
            const Level_Skip := "%_level_skip" | UI;
            Get_Locator_Ptr(Instr.Parallel_Master(), Master, UID_Extra => 1);

            //  Go out-of-line to wait
            const Execute := "@_psc_execute_wait_for_parallel_op";
            TLO.Declare(Execute, "i32 `(Execute)(i64*, i64*)");
            TLO |= Level_Skip | " = call i32 " | Execute | 
               "(i64* %_Context, i64* `(Master))";

            //  If level diff not zero, return
            Continue_If_Level_Diff_Zero(Level_Skip);
            
         [#Create_Lock_For_Obj_Op] =>
            const Obj_Virt_Ptr := "%_obj_virt_ptr" | UI;
            const Obj_Virt     := "%_obj_virt"     | UI;
            Load_Via_Locator
              (Instr.Destination(), Obj_Virt_Ptr, Obj_Virt);

            //  Create Lock uses Virtual addresses
            const Execute := "@_psc_create_lock_for_obj";
            TLO.Declare(Execute, "void `(Execute)(i64*, i64)");
            TLO |= "call void " | Execute |
                      "(i64* %_Context, i64 `(Obj_Virt))";
         [#Create_Tcb_Op] =>

            {OCS.Inline_Stack.Is_Empty()}  //  Not allowed in an inlining

            //  Assign llvm identifiers and get arguments
            const Master  := "%_master"  | UI;
            const Control := Instr.Parallel_Control().VM_Name()
            Get_Locator_Ptr(Instr.Parallel_Master(), Master, UID_Extra => 2);

            //  Call _psc_new_tcb
            TLO.Declare("_psc_new_tcb", "i64* @_psc_new_tcb(i64*, i64*, i64)");
            TLO |= Control |
                          " = call i64* @_psc_new_tcb(i64* %_Context, i64* " |
                          Master | ", i64 " |
                          Instr.Num_In_Params()+Instr.Num_Out_Params() | ")";

         [#Create_Polymorphic_Obj_Op] =>
            const Source   := "%_src"      | UI;
            const Dest_Ptr := "%_dest_ptr" | UI;
            const Desc_Ptr := "%_desc" | UI;
            const Null_Val := "%_null_val" | UI;

            //  Pass source object, or 0 if is null locator
            if Is_Null_Locator(Instr.Source()) then
               //  Region for poly object is local region
               //  so just pass a zero
               TLO |= Source | " = bitcast i64 0 to i64"
            else
               //  Region for poly object is region det'd by Instr.Source()
               //  so retrieve source value to pass to create_poly_obj.
               const Src_Ptr  := "%_src_ptr"  | UI;

               Load_Via_Locator(Instr.Source(), Src_Ptr,
                                Source, UID_Extra => 1);
            end if

            //  Get destination and type descriptor
            Get_Locator_Ptr(Instr.Destination(), Dest_Ptr, UID_Extra => 1);
            Load_Type_Desc(Instr.Type_Info(), Desc_Ptr);
            const Execute := "@_psc_create_poly_obj";
            TLO.Declare(Execute, "void " |
                                 Execute | "(i64*, i64, i64*, i64*)");
            TLO |= "call void `(Execute)(i64* %_Context, i64 " | Source |
               ", i64* `(Dest_Ptr), i64* `(Desc_Ptr))";

         [#Unwrap_Polymorphic_Obj_Op] =>
            const Dest_Ptr       := "%_dest_ptr"       | UI;
            const TDesc          := "%_tdesc" | UI;
            const Source_TDesc   := "%_source_tdesc"   | UI;
            const Source_Ptr     := "%_source_ptr"     | UI;
            const Source         := "%_source"         | UI;

            //  Get arguments
            Get_Locator_Ptr(Instr.Destination(), Dest_Ptr, UID_Extra => 0);
            Load_Type_Desc(Instr.Source_Type_Info(), Source_TDesc,
              UID_Extra => 0);
            Load_Type_Desc(Instr.Type_Info(), TDesc, UID_Extra => 1);
            Load_Via_Locator
              (Instr.Source(), Source_Ptr, Source, UID_Extra => 1);

            //  Pass to out-of-line routine
            const Unwrap := "@_psc_unwrap_polymorphic_obj";
            TLO.Declare(Unwrap, "void `(Unwrap)(i64*, i64*, i64*, i64)");
            TLO |= "call void `(Unwrap)(i64* `(Dest_Ptr), i64* " |
               Source_TDesc | ", i64* `(TDesc), i64 `(Source))";
         [#Select_Polymorphic_Ancestor_Part_Op |
          #Select_Ancestor_Part_Op] =>
            const Poly :=
               Opcode(Instr) == #Select_Polymorphic_Ancestor_Part_Op;

            //  Assign unique identifiers
            const Dest           := "%_dest"           | UI;
            const Dest_Ptr       := "%_dest_ptr"       | UI;
            const Source_Ptr     := "%_source_ptr"     | UI;
            const Source         := "%_source"         | UI;
            const Ancestor_TDesc := "%_ancestor_tdesc" | UI;
            const Source_TDesc   := "%_source_tdesc"   | UI;

            Load_Type_Desc(Instr.Type_Info(), Ancestor_TDesc, UID_Extra => 0);

            if Instr.Ancestor_Lvalue() and then not Poly then
               //  Expects Source to be a "ref" to object
               Get_Locator_Ptr(Instr.Source(), Source_Ptr,
                  UID_Extra => 1);
               //  Pass in the pointer as an int
               TLO |= Source | " = ptrtoint i64* " | Source_Ptr |
                  " to i64";
            else
               //  Get the source value
               Load_Via_Locator(Instr.Source(), Source_Ptr, Source,
                  UID_Extra => 1);
            end if

            if Poly then
               //  Get Source_TDesc from large (poly) object
               const Get_TD := "@_psc_get_large_obj_type_descriptor";

               TLO.Declare(Get_TD, "i64* `(Get_TD)(i64)");
               TLO |= Source_TDesc | " = call i64* `(Get_TD)(i64 " |
                  Source | ")";
            else
               //  Get (non-poly) Source_TDesc from instruction itself
               Load_Type_Desc(Instr.Source_Type_Info(), Source_TDesc,
                 UID_Extra => 1);
            end if;

            //  Call the out-of-line function
            const Select := "@_psc_select_ancestor_part";
            TLO.Declare(Select,
                        "i64 `(Select)(i64*, i64, i64*, i64*, i1)");
            TLO |= Dest | " = call i64 `(Select)(i64* %_Context, i64 " |
               Source | ", i64* `(Ancestor_TDesc), i64* " |
               Source_TDesc | ", i1 `((Instr.Ancestor_Lvalue()? 1 : 0)))";

            if Instr.Ancestor_Lvalue() then
               //  Result is a "ref" -- convert to pointer type
               const Dest_As_Addr   := "%_dest_as_addr"   | UI;

               TLO |= Dest_As_Addr | " = inttoptr i64 `(Dest) to i64*";
               Store_Via_Locator(Instr.Destination(), Dest_Ptr, Dest_As_Addr,
                 Ptr_Level => 1);
            else
               //  Result is selected ancestor -- store into destination
               Store_Via_Locator(Instr.Destination(), Dest_Ptr, Dest);
            end if;

         [#If_Op] =>
            //  Compute Label locations
            const True := TLO.Add_Label(0);
            const False := TLO.Add_Label(Instr.Skip_If_False());

            //  Name local variables for this instruction
            const Source_Ptr   := "%_if_source_ptr"   | UI;
            const Source_Val   := "%_if_source_val"   | UI;
            const Source_Trunc := "%_if_source_trunc" | UI;

            const If_Cond      := Instr.If_Condition();

            //  output LLVM code
            Load_Via_Locator
              (Instr.If_Source(), Source_Ptr, Source_Val, UID_Extra => 1);

            if If_Cond == Reflection::Instruction::Boolean_Is_True then
               //  Special case of boolean input = True
               //  NOTE: Just checking for not-equal 0 gives the wrong answer
               //        if the condition is of type Ordering.
               TLO |= Source_Trunc | " = icmp eq i64 `(Source_Val), 1";
            elsif If_Cond == Reflection::Instruction::Boolean_Is_False then
               //  Special case of boolean input = False
               TLO |= Source_Trunc | " = icmp eq i64 `(Source_Val), 0";
            else
               //  Handle more general Ordering test
               const Shifted      := "%_shifted"         | UI;
               const And          := "%_and"             | UI;

               TLO |= Shifted | " = shl i64 1, " | Source_Val;
               TLO |= And | " = and i64 `(Shifted), " | To_Rep(If_Cond)
               TLO |= Source_Trunc | " = icmp ne i64 `(And), 0";
            end if
            TLO |= "br i1 `(Source_Trunc), label " | True |
                                            ", label " | False;
         [#Call_Nested_Block_Op | #Check_Nested_Block_Op] =>
            //  Call_Nested_Block not yet used. 
            const Block_Desc := Instr.Code_Block();
            if Block_Desc is null then
               Put_Error
                 ("Attempted to call or check null Nested_Block",
                  Instr.Source_Pos());
               {#false};

            elsif TLO.Doing_Run_Time_Checks and then not Instr.Proved() then
               //  Generate call to nested block which checks an assertion

               {OCS.Inline_Stack.Is_Empty()}  //  Not allowed when inlining

               //  Name llvm identifiers
               const Skip_Level       := "%_Skip_Level" | UI;
               const Static_Link_Reg := "%_call`(UI)_Static_Link";
               const Call_Param_Area  := Instr.Params().VM_Name();

               //  Get arguments
               const SL_Base := Base(Instr.Static_Link());
               if SL_Base == Zero_Base or SL_Base == Type_Area or
                  SL_Base in Enclosing_Type_Areas then
                  //  Static link refers to a type descriptor
                  Load_Type_Desc(Instr.Static_Link(), Static_Link_Reg);
               else
                  //  Static link refers to an enclosing stack frame
                  Get_Locator_Ptr(Instr.Static_Link(), Static_Link_Reg,
                          UID_Extra => 1);
               end if

               //  Allocate parameter area (just one output)
               TLO |= Call_Param_Area | " = alloca i64";
               Set_VM_Reg_Is_Ptr (Adjusted_VM_Num(Instr.Params()));

               //  Call the block function
               const Internal_Precond := Operation_Routine.Internal_Precond();
               const Is_Internal_Precond :=
                 Internal_Precond not null and then
                   Block_Desc == Internal_Precond;
               const Block_Name :=
                 LLVM_Printer::Get_Block_Name
                   (I + Block_Desc.Pc_Offset, Is_Internal_Precond,
                    Fn_Name => Get_LLVM_Name(Operation_Routine));
               TLO |= Skip_Level | " = call i32 " | Block_Name |
                  "(i64* %_Context, i64* `(Call_Param_Area), i64* " |
                  Static_Link_Reg | ")";

               if Opcode(Instr) != #Check_Nested_Block_Op then
                  //  we may need to exit as well
                  Continue_If_Level_Diff_Zero(Skip_Level);

               elsif Assertion_Str(Instr) is null then
                  //  This was a nested block used to compute
                  //  postcondition entry temps, so we know it succeeded.
                  //  We generate a branch to label anyway
                  //  since Check_Nested_Block is considered a "terminator."
                  const Next := TLO.Add_Label(0);

                  TLO |= "; Check_Nested_Block computed entry temps";
                  TLO |= "br label " | Next;
               else
                  --  Check to see whether assertion failed
                  const Assert          := "%_assert"         | UI;
                  const Assert_Trunc    := "%_assert_trunc"   | UI;
                  
                  //  Create Labels
                  const Fail            := "_fail"            | UI;
                  const Next := TLO.Add_Label(0);

                  //  Check assertion value and branch
                  TLO |= Assert | " = load i64, i64* " | Call_Param_Area;
                  TLO |= Assert_Trunc | " = icmp eq i64 `(Assert), 1";
                  TLO |= "br i1 `(Assert_Trunc), label " | Next | //  True
                                                  ", label %" | Fail; // False
                  TLO |= Fail | ":";
                  Runtime_Message(Source_Pos(Instr) |
                    ": Error: Assertion failed: " |
                     Instr.Assertion_Str() | '\n');
                  TLO |= "br label " | Next;
               end if

            else
               //  Omitting Check_Nested_Block, but still create label
               //  since Check_Nested_Block is considered a "terminator."
               const Next := TLO.Add_Label(0);

               TLO |= "; Check_Nested_Block omitted";
               TLO |= "br label " | Next;
            end if

         [#Begin_Nested_Block_Op] =>
            //  Notify LLVM accum of location of beginning of nested block
            //  Always preceded by a Return_Op or Exit_Op
            const Block_Desc := Instr.Nested_Code_Block();
            const Internal_Precond := Operation_Routine.Internal_Precond();
            const Is_Internal_Precond :=
              Internal_Precond not null and then Block_Desc == Internal_Precond;

            //  Get pre-determined block node id
            const Block_Node := TLO.Nested_Block_Nodes[Func_Node][I]

            if Verbose_Debug then
               Println(" Begin block with Pc_Offset = " |
                 Block_Desc.Pc_Offset | ", id " | Block_Node |
                 ", depth = " | Depth(TLO.LLVM_Func_Tree, Block_Node) |
                 ", parent = " | Ancestor(TLO.LLVM_Func_Tree, Block_Node, 1))
            end if

            TLO.Begin_Nested_Block_Op(Block_Node, Block_Desc.Pc_Offset, 
               (Block_Desc.Start_Callee_Locals, Block_Desc.Uses_Stg_Rgn, 
                Block_Desc.Nesting_Level, Line(Source_Pos)),
                Is_Internal_Precond);

            //  Update Cur_Node to refer to this block
            OCS.Cur_Node := Block_Node;

            //  Reset set of VM regs that are pointers to the empty set.
            OCS.VM_Ptr_Regs := [];

            //  Reset known values of VM regs
            OCS.VM_Reg_Vals := [];

            //  Reset set of VM regs that are known to be for a local obj
            OCS.VM_Regs_For_Local_Objs := [];

         [#Check_Not_Null_Op] =>
            //  Send a fail message if it is null
            if TLO.Doing_Run_Time_Checks and not Instr.Proved() then
               const Result     := "%_is_null"     | UI;

               Test_For_Null(Type_Loc => Instr.Null_Type_Info(),
                 Value_Loc => Instr.Destination(),
                 Result_Bit => Result);

               const Next := TLO.Add_Label(0);
               const Fail := "_fail" | UI;
               TLO |= "br i1 `(Result), label %" | Fail | //  True
                                         ", label " | Next;   //  False
               TLO |= Fail | ":";
               Runtime_Message(Source_Pos(Instr) |
                  ": Error: Null value not permitted here: \n");
            else
               TLO |= "; Check_Not_Null omitted";
            end if
         [..] =>
            Put_Error
              ("Unrecognized PSVM Opcode " | Opcode(Instr),
               Instr.Source_Pos());
            {#false};
      end case

      //  Bump the PC according to the number of PSVM instructions processed
      //  (by Look_Ahead_Count + 1).
      for Offset in 0 .. Look_Ahead_Count loop
         TLO.Next_PSIR_Instr();
      end loop
   end func Compile_One_Instr

   //  Add the declaration to TLO_Vector if it resides in the given source file
   func Add_To_TLO_Vector
     (var LL : LLVM_Printer;
      var TLOs : TLO_Vector;
      var Items_Seen : Set<Reflection::Decl>;
      File_Name : String;
      Item : Reflection::Decl) -> Int is

      if Item is null
        or else Context(Item) == #inherited
        or else File(Decl_Source_Pos(Item)) != File_Name
        or else Item in Items_Seen
      then
         //  Ignore null or inherited declarations, or declarations
         //  in some other file, or decl already seen..
         return 0;
      end if;

      //  Remember we have processed this item before
      Items_Seen |= Item

      case Kind(Item) of
       [#type] =>
         return 0;  //  Ignore type declarations

       [#operation] =>
         if Operation_Equiv_To(Item) not null then
            return 0;  //  Ignore equiv-to's
         elsif Is_Spec(Item) then
            //  We have the spec of an operation; nothing to do
            return 0;
         else
            //  We have the body of an operation
            //  Add to vector of TLOs
            const TLO_Index := |TLOs| + 1
            const Mod_Name := Module_Name(Item)

            if Verbose_Debug then
               Println("Adding " | (Mod_Name not null? Mod_Name | "::": "") |
                 Id(Item) | " to TLO vector")
            end if

            TLOs |= LLVM_Top_Level_Op::Create
                         (Op_Body => Item, TLO_Index => TLO_Index,
                          N_Spaces => LL.Fn_Indent,
                          LLVM_Debug => LL.LLVM_Debug,
                          Doing_Run_Time_Checks => LL.Doing_Run_Time_Checks,
                          Use_Stack_For_Objects => LL.Use_Stack_For_Objects,
                          TLO_First_MD_Node_Num =>
                            LLVM_Printer::Max_MD_Nodes_Per_TLO * TLO_Index)
            return 1;
         end if;

       [#object] =>
         //  Module-Level object, process now if is initialized constant
         const Val := Value_Of_Global_Const(Item);

         if Val not null then
            const Const_Name := Make_Link_Name(Module_Name(Item) | "::" |
              Id(Item));  //  surrounds with "...", so need to strip off
            LL.Add_Constant(Const_Name[1 <..< |Const_Name|], Val);
            const Const_Type_Index := LL.PFT.Get_Local_Index
              (Const_Info_For_Value(Val).Data.Type_Desc);
               //  Get type desc to ensure it exists for reconstruct value
            return 1;
         else
            return 0;
         end if;

       [#module] =>
         if Kind(Item) == #module and then not Is_Spec(Item) then
            //  See whether module interface (spec) and class (body)
            //  in same file

            const Spec := Spec(Item);
            if File(Decl_Source_Pos(Spec)) == File(Decl_Source_Pos(Item)) then
               //  Interface and class are in same file.  
               //  We compile the whole region of the module when we see the
               //  interface, so we ignore the class (aka "body").
               return 0;
            end if
         end if

         const R := Decl_Region(Item);

         const Enclosing_Mod := Module_Name(Item)

         if Verbose_Debug then
            Println("Processing module " |
              (Enclosing_Mod not null? Enclosing_Mod | "::" : "") | Id(Item))
         end if

         var Count := 0;
         //  Iterate through all items in this (module) region
         //  And (recursively) call Add_To_TLO_Vector on each
         for I in 1 .. Num_Items(R) forward loop
            const Next_Item := R.Nth_Item(I);
            if Verbose_Debug then
               const This_Mod := Module_Name(Item);
               if Next_Item not null then
                  Println("Recursing from " |
                     To_String(Kind(Item)) | " " |
                     (This_Mod is null? "" : This_Mod | "::") |
                     Id(Item) | " to " |
                     To_String(Kind(Next_Item)) | " " |
                     (Module_Name(Next_Item) is null? ""
                        : Module_Name(Next_Item) | "::") |
                     (Id(Next_Item) is null? "null" : Id(Next_Item)));
               end if
            end if
            Count += Add_To_TLO_Vector
                       (LL, TLOs, Items_Seen, File_Name, R.Nth_Item(I));
         end loop
         return Count;

      end case

   end func Add_To_TLO_Vector

   func Apply_To_Locators
     (Instr : Reflection::Instruction;
      Action : func
                (Reflection::Object_Locator; Is_Address : Boolean := #false))
   is
     //  Apply Action to each Object_Locator in Instr
      const Op := Opcode(Instr)
      case Op of
         [#Skip_Op | #Exit_Op] =>
            null;

         [#Call_Op |
          #Call_Nested_Block_Op | #Check_Nested_Block_Op] =>
            Action(Instr.Params());
            //  TBD: Action(Instr.Static_Link());

         [#Indirect_Call_Op] =>
            Action(Instr.Params());
            Action(Instr.Call_Target());  //  This is an operation descriptor

         [#Return_Op] =>
            null;

         [#Store_Int_Lit_Op                    |
          #Store_Str_Lit_Op                    |
          #Store_Real_Lit_Op                   |
          #Store_Enum_Lit_Op                   |
          #Store_Char_Lit_Op                   |
          #Store_Operation_Desc_Op             |
          #Copy_Word_Op                        |
          #Copy_Address_Op                     |
          #Store_Address_Op                    |
          #Assign_Word_Op                      |
          #Swap_Obj_Op                         |
          #Move_Obj_Op                         |
          #Store_Local_Null_Op                 |
          #Store_Large_Local_Null_Op           |
          #Store_Null_Of_Same_Stg_Rgn_Op       |
          #Create_Obj_Op                       |
          #Create_Lock_For_Obj_Op              |
          #Create_Polymorphic_Obj_Op           |
          #Unwrap_Polymorphic_Obj_Op           |
          #Store_Type_Related_Const_Op         |
          #Select_Polymorphic_Ancestor_Part_Op |
          #Select_Ancestor_Part_Op             |
          #Make_Copy_In_Stg_Rgn_Op             |
          #Is_Null_Op                          |
          #Not_Null_Op                         |
          #Declare_Obj_Op                      |
          #Check_Not_Null_Op]                  =>

            Action(Instr.Destination());

            case Op of
               [#Store_Local_Null_Op | #Check_Not_Null_Op] =>
                  null;

               [#Store_Large_Local_Null_Op] =>
                  //  TBD: Action(Instr.Local_Addr());
                  null;

               [#Store_Int_Lit_Op  |
                #Store_Char_Lit_Op |
                #Store_Real_Lit_Op |
                #Store_Str_Lit_Op  |
                #Store_Enum_Lit_Op] =>
                  null;

               [#Store_Operation_Desc_Op] =>
                  //  TBD: Action (Instr.Operation_Static_Link())
                  null;

               [#Declare_Obj_Op] =>
                  null;

               [#Copy_Word_Op                        |
                #Copy_Address_Op                     |
                #Assign_Word_Op                      |
                #Swap_Obj_Op                         |
                #Move_Obj_Op                         |
                #Store_Null_Of_Same_Stg_Rgn_Op       |
                #Create_Obj_Op                       |
                #Create_Polymorphic_Obj_Op           |
                #Unwrap_Polymorphic_Obj_Op           |
                #Store_Type_Related_Const_Op         |
                #Select_Polymorphic_Ancestor_Part_Op |
                #Select_Ancestor_Part_Op             |
                #Make_Copy_In_Stg_Rgn_Op             |
                #Is_Null_Op                          |
                #Not_Null_Op]                         =>
                  Action (Instr.Source());

                  case Op of
                     [#Assign_Word_Op                      |
                      #Swap_Obj_Op                         |
                      #Move_Obj_Op                         |
                      #Store_Null_Of_Same_Stg_Rgn_Op       |
                      #Create_Obj_Op                       |
                      #Create_Polymorphic_Obj_Op           |
                      #Unwrap_Polymorphic_Obj_Op           |
                      #Store_Type_Related_Const_Op         |
                      #Select_Polymorphic_Ancestor_Part_Op |
                      #Select_Ancestor_Part_Op             |
                      #Is_Null_Op                          |
                      #Not_Null_Op]                         =>
                         null;
                     [#Make_Copy_In_Stg_Rgn_Op] =>
                         Action(Instr.Existing_Obj_In_Stg_Rgn());

                     [..] =>
                        null;
                  end case;

               [#Store_Address_Op] =>
                  //  Indicate that the address is being taken
                  Action (Instr.Source(), Is_Address => #true);

               [..] =>
                  null;
            end case;

         [#If_Op] =>
            Action(Instr.If_Source());

         [#Start_Parallel_Op      |
          #Add_Parallel_Op        |
          #Wait_For_Parallel_Op   |
          #Start_Parallel_Call_Op |
          #Add_Parallel_Call_Op   |
          #Create_Tcb_Op          |
          #Prepare_To_Exit_Parallel_Op] =>

            Action(Instr.Parallel_Master());

            case Op of
               [#Start_Parallel_Op      |
                #Add_Parallel_Op        |
                #Start_Parallel_Call_Op |
                #Add_Parallel_Call_Op   |
                #Create_Tcb_Op]          =>

                  Action(Instr.Parallel_Control());

                  //  TBD: Action(Instr.Parallel_Static_Link());

               [..] =>
                  null;
            end case;

         [#Case_Op] =>
            Action(Instr.Case_Selector());

         [#Begin_Nested_Block_Op] =>
            null;

         [#Loop_Op] =>
            null;
         [..] =>
            {#false};
      end case
   end func Apply_To_Locators

   //  Layout frame record for one operation and its nested blocks
   func Layout_Frame_Record
     (var TLO : LLVM_Top_Level_Op;
      Func_Node : LLVM_Top_Level_Op::LLVM_Func_Node_Id;
      Item : Reflection::Decl) is

      const Routine := Routine_For_Operation(Item);

      // Compute name
      const Full_Name := Full_Op_Name(Item);

      func Walk_Code_Block_Tree
        (Cur_Node : LLVM_Func_Node_Id; Start_At : Code_Index) is
        //  Walk code block tree starting at given code index
        //  Process nested block when it is invoked

         func Walk_Nested_Block (Block_Start : Code_Index) is
           //  Determine node id of block and then call Walk_Code_Block_Tree
           //  recursively
            const Block_Instr := Routine.Nth_Instr(Block_Start);

            {Opcode(Block_Instr) == #Begin_Nested_Block_Op}

            const Block_Key : LLVM_Func_Key :=
                               (PSVM_Routine => Item,
                                Block_Region =>
                                  Block_Instr.Nested_Block_Region(),
                                Start_Src_Pos => Block_Instr.Source_Pos())

            const Block_Node :=
              Get_Child(TLO.LLVM_Func_Tree, Cur_Node, Block_Key)

            //  Add to mapping of block instr => block node
            TLO.Nested_Block_Nodes[Func_Node][Block_Start] := Block_Node

            if Verbose_Debug then
               Println (" Walk_Nested_Block for block at " |
                 Block_Start | ", " | Block_Instr.Source_Pos() |
                 ", id " | Block_Node |
                 ", depth = " | Depth(TLO.LLVM_Func_Tree, Block_Node) |
                 ", parent = " | Cur_Node)
            end if

            //  Do the recursive call
            Walk_Code_Block_Tree(Block_Node, Block_Start)
         end func Walk_Nested_Block

         func Process_One_Locator
           (Locator : Reflection::Object_Locator;
            Is_Address : Boolean := #false)
         is
           //  Process one object locator in instruction
           //  by marking the VM register as up-level referenced
            if #false and then Verbose_Debug then
               Println (" Process_One_Locator " | Locator)
            end if
            case Base(Locator) of
               [Enclosing_Local_Areas.First .. Enclosing_Local_Areas.Last] => 
                  //  Find enclosing LLVM func node id
                  {not VM_Is_Component(Locator)}

                  const Uplevel :=
                    Base(Locator) - Enclosing_Local_Areas.First
                  const Enclosing_Func_Node :=
                    Ancestor(TLO.LLVM_Func_Tree, Cur_Node, Uplevel)
                  const Reg_Num := VM_Num(Locator)

                  if Reg_Num == 0 then
                     //  This should only happen if offset <= master offset
                     const Local_Offset := Offset(Locator)
                     {Local_Offset <= Master_Offset_In_Words}

                     //  Keep track of the fact we made an uplevel ref
                     //  to a master object.
                     if Local_Offset == Master_Offset_In_Words then
                        TLO.Uplevel_Ref_To_Master |= Enclosing_Func_Node
                     end if;

                  else
                     if Enclosing_Func_Node not in TLO.Uplevels then
                        TLO.Uplevels[Enclosing_Func_Node] := []
                     end if

                     //  Remember we made an up-level ref to given LLVM reg
                     if Verbose_Debug then
                        if Reg_Num not in
                          TLO.Uplevels[Enclosing_Func_Node]
                        then
                           Println("  Adding " | Reg_Num |
                             " to Uplevels for func id " | Enclosing_Func_Node)
                        elsif #false then
                           Println(Reg_Num |
                             " already in Uplevels for func id " |
                             Enclosing_Func_Node)
                        end if
                     end if

                     TLO.Uplevels[Enclosing_Func_Node] |= Reg_Num
                  end if
                  
               [Enclosing_Param_Areas.First .. Enclosing_Param_Areas.Last] => 
                  //  Find enclosing LLVM func node id
                  {not VM_Is_Component(Locator)}
                  const Uplevel :=
                    Base(Locator) - Enclosing_Param_Areas.First
                  const Param_Offset := Offset(Locator)
                  const Enclosing_Func_Node :=
                    Ancestor(TLO.LLVM_Func_Tree, Cur_Node, Uplevel)
               
                  if Enclosing_Func_Node not in TLO.Uplevel_Params then
                     TLO.Uplevel_Params[Enclosing_Func_Node] := []
                  end if

                  //  Remember we made an up-level ref to given param
                  if Verbose_Debug then
                     if Param_Offset not in
                       TLO.Uplevel_Params[Enclosing_Func_Node]
                     then
                        Println("  Adding " | Param_Offset |
                          " to Uplevel_Params for func id " |
                          Enclosing_Func_Node)
                     elsif #false then
                        Println(Param_Offset |
                          " already in Uplevel_Params for func id " |
                          Enclosing_Func_Node)
                     end if
                  end if

                  TLO.Uplevel_Params[Enclosing_Func_Node] |= Param_Offset
                  
               [Param_Area] =>
                  //  Interesting if takes the address of a parameter;
                  //  we treat it like an uplevel, so it will have an addr.
                  if Is_Address then
                     if Cur_Node not in TLO.Uplevel_Params then
                        TLO.Uplevel_Params[Cur_Node] := []
                     end if
                     TLO.Uplevel_Params[Cur_Node] |= Offset(Locator)
                  end if

               [..] =>
                  //  Nothing special to do
                  null;
            end case
         end func Process_One_Locator

         //  begin: Walk_Code_Block_Tree

         if Verbose_Debug then
            Println(" Doing layout for func id " | Cur_Node)
         end if

         if Start_At == 1 then
            //  Check for the "internal precondition" -- aka the Dequeue cond
            const Dq_Block := Routine.Internal_Precond()
            if Dq_Block not null then
               //  There is a dequeue condition; walk it now
               Walk_Nested_Block (Dq_Block.Pc_Offset + 1)
            end if
         end if

         for I in Start_At .. Routine.Num_Instrs() forward loop
            const Instr := Routine.Nth_Instr(I);
            const Op := Opcode(Instr);

            case Op of
               [#Start_Parallel_Op | #Add_Parallel_Op] =>
                  if Base(Instr.Parallel_Static_Link()) == Local_Area then
                     //  Recurse with nested block
                     Walk_Nested_Block
                       (I + Instr.Parallel_Code_Block().Pc_Offset + 1)
                  end if

               [#Check_Nested_Block_Op] =>
                  //  Recurse with nested block
                  Walk_Nested_Block (I + Instr.Code_Block().Pc_Offset + 1)

               [#Begin_Nested_Block_Op] =>
                  if I == Start_At then
                     //  This is the header to a nested block
                     null;
                  else
                     //  This is the end of the current LLVM func
                     exit loop
                  end if
               [..] =>
                  null
            end case

            //  Keep track of up-level references
            Apply_To_Locators(Instr, Process_One_Locator)
         end loop

         //  All up-level references to this code block should be
         //  complete.

         //  Determine number of uplevel-ref'ed VM regs
         if Cur_Node not in TLO.Uplevels then
            //  Initialize Uplevels for this node to the empty set
            TLO.Uplevels[Cur_Node] := []
         end if

         if Cur_Node not in TLO.Uplevel_Params then
            //  Initialize Uplevel_Params for this node to the empty set
            TLO.Uplevel_Params[Cur_Node] := []
         end if

         //  Fill in VM_Param_Frame_Offsets and VM_Frame_Offsets for this node
         TLO.VM_Param_Frame_Offsets[Cur_Node] := []
         var Offset : Reflection::Offset_Within_Area :=
                         LLVM_Printer::First_Uplevel_Ref_Offset;

         if Start_At == 1
           and then Pass_Params_In_Regs[Convention(Routine)]     
         then
            const Num_Outputs := (for each P of Parameters(Routine)
                                    {P.Is_Operation_Output} => <0> + 1)
            //  Register Parameters get the first set of frame offsets
            for Par_Off in TLO.Uplevel_Params[Cur_Node] forward loop
               if Par_Off >= Num_Outputs then
                  //  Only input reg parameters need frame offsets;
                  //  Output parameter already has its own memory area.
                  TLO.VM_Param_Frame_Offsets[Cur_Node][Par_Off] := Offset
                  Offset += 1
               end if
            end loop
         end if

         //  Local variables get the remainder
         TLO.VM_Frame_Offsets[Cur_Node] := []
         for VMR in TLO.Uplevels[Cur_Node] forward loop
            TLO.VM_Frame_Offsets[Cur_Node][VMR] := Offset
            Offset += 1
         end loop

      end func Walk_Code_Block_Tree

      //  begin: Layout_Frame_Record

      if Verbose_Debug then
         Println ("Begin layout for function `(Full_Name), id " |
           Func_Node)
      end if

      //  Initialize mapping of nested block nodes
      TLO.Nested_Block_Nodes[Func_Node] := []

      //  Recursively walk the operation and its nested blocks
      Walk_Code_Block_Tree (Func_Node, Start_At => 1);

      //  Done laying out this function
      if Verbose_Debug then
         Println ("End layout for function " | Full_Name)
      end if;

   end func Layout_Frame_Record

   //  Compile one operation
   func Compile_Operation
     (var TLO : LLVM_Top_Level_Op;
      Func_Node : LLVM_Top_Level_Op::LLVM_Func_Node_Id;
      Op_Body : Reflection::Decl) is

      const Routine := Routine_For_Operation(Op_Body);

      var OCS : Op_Comp_State := (Cur_Node => Func_Node);
        //  Keep track of compilation state:
        //    Cur_Node, VM_Ptr_Regs, VM_Reg_Vals, Inline_Stack

      // Compute name
      const Module_Name := Reflection::Routine::Module_Name(Routine);

      //  Check if this might be main
      const Formal_Params := Parameters(Routine);
      var Possible_Type := 
        "PSL::Containers::Basic_Array<PSL::Core::Univ_String>";
      //  One Parameter of type Basic_Array<Univ_String> and, no result.
      //  Allow parameterless as well.
      const Args_Match_Main := |Formal_Params| == 0
        or else
         (|Formal_Params| == 1
            and then 
          not Formal_Params[1].Is_Operation_Output
            and then
          Formal_Params[1].Type_Name == Possible_Type);

      var Full_Name := Full_Op_Name(Op_Body);
      if Args_Match_Main and then Full_Name == "main" then
         //  main must be a top-level function
         //  not nested within a module
         //  And therefore, can't be overloaded
         Full_Name := "_parasail_main_routine";
      end if

      //  For overloading
      const Homonyms := Num_Prior_Homonyms(Op_Body);
      const Full_Link_Name := Make_Link_Name (Full_Name, Homonyms);

      //  For registering compiled routine
      //  Do not use Linker substitutions on Op_Name or Module_Name
      const Register_Op_Name : String :=
        Name_With_Overloading_Index(Routine);

      TLO.Add_Module_Op(Module_Name, Register_Op_Name, '@' | Full_Link_Name,
         Has_Internal_Precond => Routine.Internal_Precond() not null,
         Conv_Desc            => Routine.Conv_Desc(),
         Func_Type            => LLVM_Function_Profile (Routine, ""));

      if #false and then Verbose_Debug and then |Formal_Params| == 1
        and then not Formal_Params[1].Is_Operation_Output
      then
         Println ("First param type = " |
           Formal_Params[1].Type_Name);
      end if

      const Line_Number := Line(Decl_Source_Pos(Op_Body));

      if TLO.Has_Func(Full_Link_Name) then
         //  Prevent double definition
         if Verbose_Debug then
            Println ("Already seen function " | Full_Link_Name |
              " at line " | Line_Number)
         end if
         return
      end if

      if Verbose_Debug then
         Println ("Begin function " | Full_Link_Name |
           " at line " | Line_Number)
         Println ("  Func node-id = `(Func_Node), Depth = " |
           Depth(TLO.LLVM_Func_Tree, Func_Node) | ", Parent = " |
           Ancestor(TLO.LLVM_Func_Tree, Func_Node, 1))
      end if
      TLO.Begin_Function(Full_Link_Name, Func_Node, Routine.Frame_Size(),
         Routine.Uses_Stg_Rgn(), Line_Number,
         Func_Profile => LLVM_Function_Profile(Routine, Get_LLVM_Name(Routine),
                                               With_Param_Names => #true),
         Is_Internal => Depth(TLO.LLVM_Func_Tree, Func_Node) > 0);
           //  Only nested functions can be local, because any non-nested
           //  function might be called from an inlined routine.

      var Look_Ahead_Count := 0;

      const Convention := Convention(Routine);
      const Formal_Params_In_Regs := Pass_Params_In_Regs[Convention];

      if Formal_Params_In_Regs
        and then |Formal_Params| > 0
      then
         //  Do one-time setup for parameters passed in registers
         for (each P of Formal_Params forward; POffs := 0 then POffs+1) loop
            if P.Is_Operation_Output then
               //  Initialize output variable
               TLO |= "%_Param_Area = alloca i64";
               if Output_Needs_Init (Conv_Desc (Routine)) then
                  //  Initialize output variable from initial value
                  const Result_Type := LLVM_Param_Type (P);
                  {POffs == 0}  //  Only handling one output param

                  TLO |= "store `(Result_Type) %_inited_output, " |
                    Result_Type | "* %_Param_Area"
               end if
               if 0 in TLO.Uplevel_Params[Func_Node] then
                  //  Output variable is up-level referenced, so
                  //  store a pointer to it at offset 1 in local area
                  TLO |= "%_pa = ptrtoint i64* %_Param_Area to i64";
                  TLO |= 
                    "%_store_pa = getelementptr i64, i64* %_Local_Area, i64 1";
                  TLO |= "store i64 %_pa, i64* %_store_pa";
               end if
            else
               //  Remember which inputs are pointers
               if P.Is_Passed_By_Ref then
                  OCS.VM_Ptr_Regs |= Formal_Param_VM_Num (POffs);
                     // equiv to Set_VM_Reg_Is_Ptr (which is not visible)
               end if
            end if
         end loop

         if OCS.Cur_Node in TLO.VM_Param_Frame_Offsets then
            //  Copy register parameters into local area if up-level ref'ed
            //  or have their address taken.
            for each [Param_Offs => Frame_Offs] of
              TLO.VM_Param_Frame_Offsets[OCS.Cur_Node] forward loop
               const Param_Type := LLVM_Param_Type (Formal_Params[Param_Offs+1])
               const Orig_Param_Addr := "%_param_addr_" | Param_Offs
               var Param_Addr := Orig_Param_Addr

               TLO |= Orig_Param_Addr | " = getelementptr i64, " |
                 "i64* %_Local_Area, i64 " | Frame_Offs
               if Param_Type != "i64" then
                  //  Param is passed by reference
                  Param_Addr := "%_param_addr_ptr_" | Param_Offs
                  TLO |= Param_Addr | " = bitcast i64* " | Orig_Param_Addr |
                    " to i64**"
               end if
               TLO |= "store `(Param_Type) %_formal_param_" | Param_Offs |
                 ", `(Param_Type)* " | Param_Addr
            end loop
         end if
         //  Add a blank line
         TLO |= ""
      end if

      //  Initialize reg adjustment for inlined routines
      //  to first multiple of Min_Adjustment above this routine's reg count.
      TLO.Inlining_Reg_Adjustment :=
            (Routine.Num_VM_Regs()/Inline_Info_Type::Min_Adjustment + 1) *
             Inline_Info_Type::Min_Adjustment;

      //  Compile intructions in this routine
      for I in 1 .. Routine.Num_Instrs() forward loop
         if Look_Ahead_Count > 0 then
            //  Skipping this instruction, because code for it was
            //  generated when processing a prior instruction
            Look_Ahead_Count -= 1;
         else
            //  No look-ahead was performed
            Compile_One_Instr
              (Routine, TLO, Func_Node,
               I, Look_Ahead_Count, OCS);
         end if;
      end loop

      //  Done compiling this function
      if Verbose_Debug then
         Println ("End function `(Full_Link_Name), id " | Func_Node)
      end if;

      func Preceded_By_Terminator(I : Int) -> Boolean is
        //  Return #true if instruction preceding instruction I
        //  will produce a terminating LLVM instruction.
         return I > 1
           and then Opcode(Routine.Nth_Instr(I-1)) in Terminators;
      end func Preceded_By_Terminator;

      TLO.End_Function(Preceded_By_Terminator);

   end func Compile_Operation

   func Process_One_TLO
     (var TLO    : LLVM_Top_Level_Op;
      Operation_Action : func
                          (var LLVM_Top_Level_Op;
                           Func_Node : LLVM_Top_Level_Op::LLVM_Func_Node_Id;
                           Op_Body   : Reflection::Decl))
   is
     //  Process one top-level operation and all of its nested operations
     //  applying "Operation_Action" to each operation in the TLO" 
     //  in a bottom-up fashion.

      func Body_If_Has_One (R : optional Reflection::Region)
        -> optional Reflection::Region is
        //  If R is the Operation_Param_Region for the body of an operation,
        //  then return the corresponding Operation_Body_Region.
         if R not null
           and then Kind(R) == #Operation_Param_Region_Kind
         then
            const Op_Decl := Associated_Decl(R);

            if Op_Decl is null then
               //  Missing associated symbol
               return R;
            end if

            const Op_Body_Region := Body_Region(Op_Decl);

            if Op_Body_Region is null then
               //  Missing associated body region
               return R;
            end if

            const Op_Body_Decl := Associated_Decl(Op_Body_Region);

            //  Return body region if has same associated sym as R.
            return (Op_Body_Decl == Op_Decl? Op_Body_Region: R);
         end if

         //  Fall back is to return original region
         return R;

      end func Body_If_Has_One

      func Process_Nested_Operations_Of_Region
        (Enclosing_Routine_Region : Reflection::Region;
         Parent_Node : LLVM_Func_Node_Id;
         R : Reflection::Region) is
        //  Walk region and its nested regions
        //  calling Operation_Action on each nested operation found

         if R not null then

            if Verbose_Debug then
               if Associated_Decl(R) not null then
                  Println (" Processing `(Kind(R)) region at " |
                    Decl_Source_Pos(Associated_Decl(R)) | ", num syms = " |
                    Num_Items(R) | ", num nested = " |
                    Num_Nested_Regions(R)) 
               end if
            end if

            //  First recurse on nested (statement and op) regions
            case Kind(R) of
               [#Module_Region_Kind | #Operation_Param_Region_Kind] =>
                  //  Modules aren't permitted inside of operations
                  //  Parameter regions can't have operations inside them.
                  null

               [..] =>
                  //  Recurse on the nested regions, looking for nested
                  //  operation definitions.
                  for I in 1 .. Num_Nested_Regions(R) forward loop
                     if Verbose_Debug then
                        if R.Nth_Nested_Region(I) is null then
                           Println(" Nested region `(I) is null")
                        end if
                     end if
                     for Nested := Body_If_Has_One (R.Nth_Nested_Region(I))
                       then Sibling_Region(Nested)
                       while Nested not null loop

                        const Enclosing_Routine :=
                          (Kind(Nested) == #Operation_Body_Region_Kind?
                             Nested : Enclosing_Routine_Region)

                        const Region_Node : LLVM_Func_Node_Id :=
                          (Kind(Nested) == #Operation_Body_Region_Kind
                             or else
                           Produces_Nested_Block(Nested)?
                             Get_Child(TLO.LLVM_Func_Tree, Parent_Node,
                               (PSVM_Routine =>
                                  Associated_Decl(Enclosing_Routine),
                                Block_Region =>
                                  Index(Nested),
                                Start_Src_Pos =>
                                  Decl_Source_Pos(Associated_Decl(Nested)))):
                             Parent_Node);

                        if Verbose_Debug then
                           if Produces_Nested_Block (Nested) then
                              Println ("  Nested block of " |
                                Id(Associated_Decl(Enclosing_Routine)) |
                                " has node id " |
                                Region_Node | ", src_pos = " |
                                Decl_Source_Pos(Associated_Decl(Nested)))
                           elsif #false then
                              Println ("  NO nested block for " |
                                Kind(Nested) | " region enclosed by " |
                                Id(Associated_Decl(Enclosing_Routine)) |
                                ", has NO new node id, still " |
                                Region_Node | ", src_pos = " |
                                Decl_Source_Pos(Associated_Decl(Nested)))
                           end if
                        end if
                        
                        Process_Nested_Operations_Of_Region
                          (Enclosing_Routine, Region_Node, Nested);
                     end loop
                  end loop
            end case

            //  Now iterate through all items in this region
            //  and call Operation_Action
            //  on each operation found
            for I in 1 .. Num_Items(R) forward loop
               const Next_Item := R.Nth_Item(I);

               if Next_Item is null or else Kind(Next_Item) != #operation
                 or else Is_Spec(Next_Item)
               then
                  continue loop;
               end if;

               if Verbose_Debug then
                  const This_Mod := Module_Name(Next_Item);
                  if Next_Item not null then
                     Println("Compiling nested operation " |
                        (This_Mod is null? "" : This_Mod | "::") |
                        Id(Next_Item));
                  end if
               end if

               //  Process a nested operation.  But first get its Node_Id
               const Func_Key : LLVM_Func_Key :=
                                  (PSVM_Routine => Next_Item,
                                   Block_Region =>
                                     Index(Body_Region(Next_Item)),
                                   Start_Src_Pos => Decl_Source_Pos(Next_Item))
               const Func_Node :=
                 Get_Child(TLO.LLVM_Func_Tree, Parent_Node, Func_Key)

               //  Now perform the appropriate action
               Operation_Action(TLO, Func_Node, Next_Item)
            end loop

         end if
      end func Process_Nested_Operations_Of_Region;

      const TLO_Node := TLO.LLVM_Func_Tree.Root();

      //  Process the nested operations using recursive routine
      Process_Nested_Operations_Of_Region
        (Body_Region (TLO.Op_Body), TLO_Node, Body_Region(TLO.Op_Body));

      //  Now process the top-level operation
      Operation_Action(TLO, TLO_Node, TLO.Op_Body);

   end func Process_One_TLO;

   func Compile_One_TLO(var TLO : LLVM_Top_Level_Op) is
     //  Compile one top-level operation and all of its nested operations
     //  Do a pre-pass to find all up-level references and allocate
     //  space for them in a stack-frame object.

      //  Lay out frame records for all operations in TLO
      Process_One_TLO(TLO, Operation_Action => Layout_Frame_Record)

      //  Now compile all the operations of the TLO
      Process_One_TLO(TLO, Operation_Action => Compile_Operation)
   end func Compile_One_TLO;

   func Finish_One_TLO (var LL : LLVM_Printer; TLO : LLVM_Top_Level_Op) is
     //  Copy information from TLO into LLVM_Printer
     //  TBD
      null

   end func Finish_One_TLO;

   func Init_One_Const
     (var LL        : LLVM_Printer;
      var Init_Func : String;
      Is_Internal   : Boolean;
      Const_Val     : Reflection::Streamable_Value;
      Const_Name    : String;
      Const_Size    : Int;
      UID           : Int) is
   //  Initialize one named or anonymous compile-time-known constant
   //  Add LLVM code to LL and to Init_Func, according to whether
   //  is a declaration (add to LL) or initialization code (add to Init_Func).
   //  Is_Internal is True if this is an internal object, as opposed to an
   //  externally visible object.
   //  Const_Val is the streamable value for the constant
   //  Const_Name is the name to use for the declared object
   //  Const_Size is the size of the stream used to represent a large constant
   //  UID is a uniquifying integer for use in LLVM variables

      //  See whether we have a small or string value
      const Info := Const_Info_For_Value (Const_Val);
      const Const_Locator := Const_Value_Locator (Const_Val);
      const Const_Annotation := Name_For_Object_Locator (Const_Locator);
      const Type_Of_Const := Info.Data.Type_Desc;
      const Val       := "%_const_val_" | UID;
      const Str_Ptr   := "%_const_str_ptr" | UID;
      const Global_Name := "@\"" | Const_Name | '"';
      const Univ_Integer_Null_Value := "-9223372036854775808";
      const Intern_Str := (Is_Internal? "internal " : "");

      if Is_Small(Type_Of_Const) then
         { Const_Size == 0 }

         //  NOTE: Univ_Enums need special handling
         if Type_Kind(Type_Of_Const) == #univ_enum then
            //  Declare an internal variable
            LL |= Global_Name | " = " | Intern_Str |
              "global i64 0; " | Const_Annotation;

            //  Initialize it in the Init_Func
            const Orig_Num_Strs := LL.PFS.Num_Elems();
            const Str_Index := LL.PFS.Get_Local_Index (To_String
              (Reflection::Interpret_As_Univ_Enum (Info.Data.Value)));
            if Debug_Strings
              and then LL.PFS.Num_Elems() > Orig_Num_Strs
            then
               Println("Univ_Enum const: #`(Str_Index) is " |
                 LL.PFS.Nth_Elem (Str_Index));
            end if;
            Init_Func |= Ind | Str_Ptr | " = getelementptr i64, i64* " | 
               "%_Str_Tab, i64 " | Str_Index-1 | '\n';
            Init_Func |= Ind | Val | " = load i64, i64* " | Str_Ptr | '\n';

            Init_Func |=
              Ind | "store i64 `(Val), i64* " | Global_Name | '\n';
         elsif Info.Data.Value is null then
            //  Value matches Univ_Integer null value
            LL |= Global_Name | " = `(Intern_Str)constant i64 " |
                             Univ_Integer_Null_Value | "; " | Const_Annotation;
         else
            //  Small value can be used as is
            LL |= Global_Name | " = `(Intern_Str)constant i64 " |
                             Info.Data.Value | "; " | Const_Annotation;
         end if
      elsif Type_Kind(Type_Of_Const) == #univ_string then
         //  Treat like the Store_Str_Lit operation, but create
         //  string literal in the global data area.
         { Const_Size == 0 }

         //  Declare an internal variable
         LL |= Global_Name | " = `(Intern_Str)global i64 0; " |
           Const_Annotation;

         //  Need to interpret Info.Data.Value as a Univ_String
         const Str_Val := Reflection::Interpret_As_String(Info.Data.Value);

         const Orig_Num_Strs := LL.PFS.Num_Elems();
         const Str_Index := LL.PFS.Get_Local_Index(Str_Val);
         if Debug_Strings and then LL.PFS.Num_Elems() > Orig_Num_Strs then
            Println("Univ_String const: #`(Str_Index) is " |
              Str_Val);
         end if;

         const Str_Id_Val := "%_str_id_val" | UID;

         //  Now load run-time string id
         Init_Func |= Ind | Str_Ptr | " = getelementptr i64, i64* " | 
            "%_Str_Tab, i64 " | Str_Index-1 | '\n';
         Init_Func |= Ind | Str_Id_Val | " = load i64, i64* " | Str_Ptr | '\n';

         //  Now call run-time routine to turn the string id into a
         //  global string value.

         LL.Declare("_psc_global_str_lit", "i64 @_psc_global_str_lit(i64)");
         Init_Func |= Ind | Val |
            " = call i64 @_psc_global_str_lit(i64 `(Str_Id_Val))\n";

         Init_Func |=
           Ind | "store i64 `(Val), i64* " | Global_Name | '\n';
      else
         //  Large, non-string value; use out-of-line reconstruction routine
         if Const_Size <= 0 then
            Println ("** Init_One_Const: Const_Name = " | Const_Name |
               ", Const_Size = " | Const_Size |
               ", Const_Annotation = " | Const_Annotation |
               ", Type = " | Name (Type_Of_Const));
         end if

         { Const_Size > 0 }

         //  Declare an internal variable
         LL |= Global_Name | " = `(Intern_Str)global i64 0; " |
           Const_Annotation;

         const Recon := "%_recon_" | UID;
         const Cast := "%_cast_" | UID;
         Init_Func |= Ind | Cast | " = bitcast ["|
            Const_Size | " x i8]* @\"`(Const_Name)$stream\" to i8*\n";
         Init_Func |= Ind | Recon | " = call i64 " | Recon_Value_Func | 
            "(i8* `(Cast), i64* %_Str_Tab)\n";
         Init_Func |= Ind | "store i64 " | Recon |
            ", i64* " | Global_Name | '\n';
      end if
   end func Init_One_Const

   //  Declare an alias for an anonymous constant
   func Init_Anon_Const_Alias
     (var LL        : LLVM_Printer;
      Alias         : String;
      Original_Name : String) is

      LL |= "@\"`(Alias)\" = internal alias i64, i64* @\"" |
               Original_Name | "\"";
   end func Init_Anon_Const_Alias

 exports

   func Compile(File_Name : String;
                LLVM_Debug, Doing_Run_Time_Checks, Sequential : Bool;
                Verbose, More_Verbose : Bool; Max_Instrs_For_Inlining : Int;
                Use_Stack_For_Objects : Bool) is
      //  Compile the code (if any) in the file named File_Name
      //  If Sequential is #true, then do not compile TLOs in parallel
      //  Max_Instrs_For_Inlining controls how large a routine we will
      //  inline at the point of call.
      //  If Use_Stack_For_Objects is #true, then try to allocate
      //  the space for large local objects on the stack.
      var LL : LLVM_Printer :=
        Create(Indent, LLVM_Debug => LLVM_Debug,
               Doing_Run_Time_Checks => Doing_Run_Time_Checks,
               Use_Stack_For_Objects => Use_Stack_For_Objects);

      var Env := Reflection::Environment::Get_Current_Env()

      var Count := 0;
      var TLOs : TLO_Vector := []
      var Items_Seen : Set<Reflection::Decl> := []

      //  Walk all the Declarations that are defined in File_Name
      //  Make a vector of top-level operations (TLOs)
      for I in 1 .. Env.Num_Library_Items() forward loop
         const Item := Env.Nth_Library_Item(I);
         const Pre_Count := Count;
        
         //  Add_To_TLO_Vector will recurse on the regions within Item
         Count += Add_To_TLO_Vector(LL, TLOs, Items_Seen, File_Name, Item)
         if More_Verbose and then Count > Pre_Count then
            const Net := Count - Pre_Count;

            Println("   [`(Id(Item)) contains " |
              Net | " top level operation" | (Net > 1? "s]" : "]"));
         end if
      end loop

      if Sequential then
         // Compile the top-level operations sequentially
         for each TLO of TLOs forward loop
            TLO.Max_Instrs_For_Inlining := Max_Instrs_For_Inlining;
            Compile_One_TLO (TLO)
         end loop
      else
         // Compile the top-level operations in parallel
         for each TLO of TLOs concurrent loop
            //  Do what can be done in parallel
            //  (no direct access to Printer here)
            //  NOTE: If necessary, we could pass Printer in read-only
            TLO.Max_Instrs_For_Inlining := Max_Instrs_For_Inlining;
            Compile_One_TLO (TLO)
         end loop
      end if

      for each TLO of TLOs forward loop
         //  Finish processing the TLO's sequentially.
         TLO.Finish_One_TLO (LL)
      end loop

      if Debug or More_Verbose then
         Println(" Begin initialization code for " | File_Name)
      end if

      //  Tell the printer to put the following code at the top,
      //  instead of in a function
      LL.Begin_Top_Of_File_Initializations();

      //  Code added to the LLVM_Printer after the last instruction will
      //  be put at the top of the file

      //  Declare the LLVM types used for type descriptors, etc.
      Type_Desc_LLVM_Utils::Declare_Type_Desc_LLVM_Types (LL);

      var Init_Func_Hdr := "define internal void @$initialize_streams() {\n";
      //  The per-file initialization routine header (will also have
      //  call on reconstruct_strings if it is used)

      var Init_Func := ""
      //  Rest of per-file initialization routine
      //  Init_Func initializes all the streamed
      //  Constants, Type_Descriptors, Univ_Enumerations, and Strings

      if Debug or More_Verbose then
         Println (" Emit `(LL.PFT.Num_Elems()) type descriptors for " |
           File_Name)
      end if

      if LL.PFT.Num_Elems() > 0 then
         //  Output stream data into arrays
         //  and build table to access those arrays
         const Descs_Type := "[`(LL.PFT.Num_Elems()) x i64*]";
         var Streams : String := 
            "@$Type_Desc_Streams = internal constant [" |
            LL.PFT.Num_Elems() | " x i8*] [";
         var Descs : String := "@$Type_Descriptors = internal global " |
            Descs_Type | "\n[";

         //  Iterate through the per file Type Descriptor table and stream
         //  out its contents
         for (I in 1 .. LL.PFT.Num_Elems(); Sep := "" then ", ") forward loop
            const Elem := LL.PFT.Nth_Elem(I);
            const Name := Make_Link_Name(Unique_Name(Elem));
            const Old := LL.PFS.Num_Elems();
            const S := Stream(Elem, LL.PFS);
            const Len := Length(S);
            if Debug_Strings then
               Println(File_Name | ": " |
                 Old | " -> " | LL.PFS.Num_Elems());
            end if
            LL |= "@`(Name) = internal constant [" | // tbd was "linkonce"
               Len | " x i8] ";
            LL |= To_String_Vec(S);
            LL |= "\n";
            //  Point to corresponding stream
            Streams |= (Sep | "\n i8* bitcast ([" | Len |
               " x i8]* @`(Name) to i8*)");
            //  Initialize Descriptors to null
            if I mod 5 == 0 then
               Descs |= (Sep | "\n i64* null");
            else
               Descs |= (Sep | "i64* null");
            end if
         end loop
         Streams |= "]";
         Descs |= "]";
         LL |= Streams;
         LL |= Descs;
         LL |= "@$Types = internal constant i64** bitcast (" | Descs_Type | 
            "* @$Type_Descriptors to i64**)";

         //  call Reconstruct_Type_Descriptors
         Init_Func |= Ind | "%_desc = load i64**, i64*** @$Types\n";
         LL.Declare("_psc_reconstruct_type_descriptors",
                    "void @_psc_reconstruct_type_descriptors" | 
            "(i16, i8**, i64*, i64**)");
         Init_Func |= Ind | "call void @_psc_reconstruct_type_descriptors(i16 "
            | LL.PFT.Num_Elems() | ", i8** " | 
            "bitcast ([" | LL.PFT.Num_Elems() |
            " x i8*]* @$Type_Desc_Streams to i8**)," |
            " i64* %_Str_Tab, i64** %_desc)\n";

      end if

      //  Initialize the compile-time constants

      //  Initialize the anonymous constants
      //  For each anonymous constant, in the Init_Func:
      //  * If small, non-univ-enum: nothing to do, since we can initialize
      //      on declaration.
      //  * If small, univ-enum: we need to include it in the per-file string
      //      table, and here we copy from the string table into the anon-const
      //      table.
      //  * If string: we need to include it in the per-file string table,
      //      and here we copy it from the string table and make it into
      //      a univ-string by calling some appropriate function.
      //  * If large, non-string: reconstruct value on a stream

      //  The anon-const table entry is initialized either with correct value,
      //  or a small univ-enum null value, or a large null value.
      //  The per-file string table needs to be augmented for univ-enum
      //  and univ-string.
      //  We emit a stream for each non-string large anon constant.
      //  At run-time we do not iterate through the anon-const table,
      //  so this "table" can in fact be a set of separate objects, either
      //  constants if a non-enum small value, or variables, if an enum,
      //  string, or other large object.  This also means that we can place
      //  the stream, if any, for the object immediately next to the object
      //  itself, which will simplify the compiler logic.

      if Debug or More_Verbose then
         Println (" Emit `(LL.PFC.Num_Elems()) anon consts for " |
           File_Name)
      end if

      var Large_Const_Seen : Boolean := #false;
             //  whether reconstruct-value func will be needed

      //  Define the anonymous constants
      const Aliases_Exist :=
        (for some I in 1 .. |LL.PFC_Aliases| => |LL.PFC_Aliases[I]| > 1)

      for I in 1 .. LL.PFC.Num_Elems() forward loop
         const Const_Val := LL.PFC.Nth_Elem(I);
         var Anon_Const_Name : optional String := null

         //  Define each of the aliases
         for each [TLO_Index => PFC_Index] of LL.PFC_Aliases[I] forward loop
            const Anon_Const_Alias :=
              "$Anon_Const_`(TLO_Index)_" | PFC_Index;

            if Anon_Const_Name is null then
               Anon_Const_Name := Anon_Const_Alias
               const Anon_Const_Size :=
                 LL.Create_Anon_Const_Stream(Anon_Const_Name, Const_Val);

               if Anon_Const_Size > 0 then
                  //  Will need to declare the reconstruct-value function
                  Large_Const_Seen := #true;
               end if

               Init_One_Const (LL, Init_Func,
                 Is_Internal => #true,
                 Const_Val   => Const_Val,
                 Const_Name  => Anon_Const_Name,
                 Const_Size  => Anon_Const_Size,
                 UID => I)
            else
               //  Same anon const appeared multiple times in file
               //  Create an alias
               Init_Anon_Const_Alias (LL,
                 Alias => Anon_Const_Alias,
                 Original_Name => Anon_Const_Name);
            end if
         end loop

         if Aliases_Exist then
            //  Add an extra blank line if aliases exist
            LL |= ""
         end if
      end loop

      //  Gather info on the named constants
      const Consts := LL.Get_Constants();

      if Debug or More_Verbose then
         Println (" Emit `(|Consts|) named consts for " |
           File_Name)
      end if

      if |Consts| > 0 then
         //  Outputing streams is handled in the printer
         //  We just need to call the reconstructor here

         for (each [Name => Size] of Consts;
              UID := LL.PFC.Num_Elems()+1 then UID+1) loop
            Init_One_Const(LL, Init_Func,
              Is_Internal => #false,
              Const_Val   => LL.Constants[Name],
              Const_Name  => Name, Const_Size => Size, UID => UID);

            if Size > 0 then
               Large_Const_Seen := #true;
            end if
         end loop
      end if

      if Large_Const_Seen then
         //  Declare the reconstruct-value function
         LL.Declare(Recon_Value_Func,
                    "i64 `(Recon_Value_Func)(i8*, i64*)");
      end if

      //  Register the compiled operations within this file
      //  so that the RTS can make indirect calls on them
      const Indices_Size := LL.Module_Op_Info_Size();

      if Debug or More_Verbose then
         Println (" Register `(Indices_Size) compiled ops for " |
           File_Name)
      end if

      if Indices_Size > 0 then
         const Func_Type := "void(i64*, i64*, i64*)*";
         const Block_Type := "i32(i64*, i64*, i64*)*";
         const Out_Line := "@_psc_register_compiled_operations";
         const Num_IPs := LL.Num_Internal_Preconds();
         //  Signature of Register_Compiled_Operations is: 
         //  Num_Operations, Operation_Ids, Operation_Addrs
         //  String_Tab, Num_Internal_Preconds, Internal_Precond_Ops,
         //  Internal_Precond_Addrs
         LL.Declare(Out_Line,
                    "void " | Out_Line |
                      "(i16, i16*, `(Func_Type)*, i32*, i64*, " |
            "i32, i16*, `(Block_Type)*)");
         Init_Func |= Ind | "call void `(Out_Line)(i16 " | Indices_Size |
            ", i16* bitcast ([" | (Indices_Size * 2) |
            " x i16]* @$Module_Op_Indices to i16*), " | Func_Type |
            "* bitcast ([`(Indices_Size) x `(Func_Type)]* " |
            "@$Local_Funcs to `(Func_Type)*), i32* bitcast ([" |
            Indices_Size | " x i32]* @$Local_Funcs_Conv_Descs to i32*),"
            | " i64* %_Str_Tab, i32 " | Num_IPs |
            ", i16* bitcast ([" | Num_IPs |
            " x i16]* @$Internal_Precond_Indices to i16*), " |
            Block_Type | "* bitcast ([`(Num_IPs) x " | Block_Type |
            "]* @$Internal_Precond_Blocks to `(Block_Type)*))\n";
      end if

      //  NOTE: We put out the string table last, as it might
      //        be updated as a side effect of streaming out the
      //        type descriptors or global constants.

      if Debug or More_Verbose then
         Println (" Emit `(LL.PFS.Num_Elems()) strings for " |
           File_Name)
      end if

      if LL.PFS.Num_Elems() > 0 then
         //  Output stream data for strings into arrays
         //  and build table to access those arrays
         const Str_Tab_Type := "[`(LL.PFS.Num_Elems()) x i64]";
         var Streams : String := 
            "@$Str_Streams = internal constant [" |
            LL.PFS.Num_Elems() | " x i8*] [";
         var Strs : String := "@$String_Table = internal global " |
            Str_Tab_Type | " \n[";

         //  Iterate throught the per file String table and stream out
         //  its contents
         for (I in 1 .. LL.PFS.Num_Elems(); Sep := "" then ", ") forward loop
            const S := LL.PFS.Nth_Elem_As_Stream(I);
            LL |= "@$str_stream`(I) = internal constant [" |
               Length(S) | " x i8] ";
            LL |= To_String_Vec(S);
            LL |= "\n";
            //  Point to corresponding stream
            Streams |= (Sep | "\ni8* bitcast ([" | Length(S) |
               " x i8]* @$str_stream`(I) to i8*)");
            //  Initialize String_Table to 0s.
            //  Will be filled in Reconstruct_Strings
            if I mod 10 == 0 then
               Strs |= (Sep | "\n i64 0");
            else
               Strs |= (Sep | "i64 0");
            end if;
         end loop
         Streams |= "]";
         Strs |= "]";
         LL |= Streams;
         LL |= Strs;
         LL |= "@$Strings = internal constant i64* bitcast (" | Str_Tab_Type | 
            "* @$String_Table to i64*)";

         //  Put call on reconstruct_strings at front of Init_Func so
         //  string table can be used while reconstructing
         //  other tables.
         LL.Declare("_psc_reconstruct_strings",
                    "void @_psc_reconstruct_strings(i16, i8**, i64*)")

         //  Make the call on Reconstruct_Strings
         Init_Func_Hdr |= Ind | "%_Str_Tab = load i64*, i64** @$Strings\n";
         Init_Func_Hdr |= Ind | "call void @_psc_reconstruct_strings(i16 " |
            LL.PFS.Num_Elems() | ", i8** " | 
            "bitcast ([" | LL.PFS.Num_Elems() |
            " x i8*]* @$Str_Streams to i8**), i64* %_Str_Tab)\n";
      else
         //  Init %_Str_Tab to the null value if no string table
         Init_Func_Hdr |= Ind |
           "%_Str_Tab = getelementptr i64, i64* null, i64 0\n";
      end if
      
      if Debug or More_Verbose then
         Println(" Emit initialization func for " | File_Name)
      end if

      //  Finish the Initialization Function
      Init_Func |= Ind | "ret void\n}";

      if LL.PFT.Num_Elems() > 0 or else LL.PFS.Num_Elems() > 0 
        or else |Consts| > 0 or else Indices_Size > 0
      then
         //  Global To Do list for initializations
         //  We cannot just add @$initialize_streams to the constructors list
         //  because llvm walks the constructor list before the Ada runtime
         //  is initialized. That is why this todo list is necessary
         LL |= "@_psc_global_to_do = external global {i64*, void()*}*";

         LL |= (Init_Func_Hdr | Init_Func);

         const Node := "@\"_node_" | Replace(File_Name, '"', '$') | '"';
         LL |= Node | " = global {i64*, void()*} " | 
            "{i64* null, void()* @$initialize_streams}";

         //  Add intialize_streams to the to do list
         LL |= "define internal void @$add_to_todo() {";
         LL |= Ind | "%_next = load {i64*, void()*}*, {i64*, void()*}** " |
                     "@_psc_global_to_do";
         LL |= Ind | "%_nextc = bitcast {i64*, void()*}* %_next to i64*";
         LL |= Ind | "%_node.next_ptr = getelementptr {i64*, void()*}, " | 
            "{i64*, void()*}* `(Node), i32 0, i32 0";
         LL |= Ind | "store i64* %_nextc, i64** %_node.next_ptr";
         LL |= Ind | "store {i64*, void()*}* `(Node), " | 
            "{i64*, void()*}** @_psc_global_to_do";
         LL |= Ind | "ret void";
         LL |= "}";
         
         //  Put the todo list appender into the llvm constructor list
         //  So it will be called at startup
         LL |= "@llvm.global_ctors = appending global " | 
            "[1 x {i32, void ()*}] [{i32, void()*} {i32 65535, void ()* " | 
            "@$add_to_todo}]";

      end if

      if Count == 0 then
         //  A pure interface (with no code) will come up empty
         //  or if someone forgot to load it into the interpreter
         var IO := IO::Get_IO();
         const Input_File : File_Input_Stream := Open(IO, File_Name);
         var Empty : File_Output_Stream := Create(IO, File_Name | ".ll");

         if Input_File is null then
            IO.Stderr.Println("   [`(File_Name): file not found]");
            Empty.Println("; source file `(File_Name) not found");

         else 
            if Verbose then
               Println("   [" | File_Name |
                 ": source has no executable code]");
            end if

            Empty.Println("; source file " | File_Name |
              " has no executable code");
         end if

         Empty.Close();
      else
         if Debug or More_Verbose then
            Println (" Dump LLVM for " | File_Name)
         end if

         LL.Dump(File_Name, File_Name | ".ll");
      end if

      //  Reclaim internal storage used for the per-file string table
      Reset(LL.PFS)
   end func Compile
end class PSC::Translate;

func Compile(Files : PSL::Containers::Basic_Array<String>) is
   var LLVM_Debug : Bool := #false;
   var Optimize : Bool := #false;
   var Doing_Run_Time_Checks : Bool := #true;
   var Sequential : Bool := #false; // concurrent file compilation by default
   var Verbose : Bool := #false;
   var Quiet : Bool := #false;
   var More_Verbose : Bool := #false;
   var Max_Instrs_For_Inlining := 20;  //  Default inlining cutoff
   var Checks_Flag : Bool := #false;
   var Use_Stack_For_Objects : Bool := #false;

   //  Analyze flags
   for each Arg of Files forward loop
      const Len := Length(Arg);
      if Arg == "-g" then
         LLVM_Debug := #true;
      elsif Arg == "-O" then
         Optimize := #true;
      elsif Len == 3 and then Arg[1 .. 2] == "-O" then
         //  -On where n is not '0' enables optimizations
         if Arg[3] == '0' then
            Optimize := #false;
         else
            Optimize := #true;
            //  For now, optimizing means suppressing run-time checks.
            //  Eventually, once we have ParaScope integrated in, we can rely
            //  on ParaScope indicating whether a check has been proved.
            Doing_Run_Time_Checks := #false;
         end if
      elsif Arg == "--forward" then
         Sequential := #true;
         if not Quiet then
            //  By default, setting --forward implies --verbose
            Verbose := #true;
         end if
      elsif Arg == "--verbose" then
         Verbose := #true;
         Quiet := #false;
      elsif Arg == "--quiet" then
         Verbose := #false;
         Quiet := #true;
      elsif Arg == "--debug" then
         More_Verbose := #true;
         Verbose := #true;
      elsif Arg == "--checks" then
         Checks_Flag := #true;
      elsif Arg == "--stack" then
         --  Try to use the stack for local large objects
         Use_Stack_For_Objects := #true;
      elsif Len >= 8 and then Arg[1 .. 8] == "--inline" then
         //  --inline=0 turns off inlining
         //  --inline=N inlines routines with <= N instructions
         if Len > 9 and then Arg[9] == '=' then
            const Max : Int := From_String(Arg[10 .. Len]);
            if Max not null and then Max >= 0 then
               //  Override the default inlining
               Max_Instrs_For_Inlining := Max;
            end if;
         end if;
      elsif Len > 0 and then Arg[1] == '-' then
         Println("Warning: switch \"`(Arg)\" ignored.")
      end if
   end loop

   if Checks_Flag then
      //  Make sure we generate code for the run-time checks
      Doing_Run_Time_Checks := #true;
   end if

   if Translate::Msg_File_Name not null then
      //  Initialize the message file
      var IO := IO::Get_IO();
      var Msg_File :=
        File_Output_Stream::Create(IO, Translate::Msg_File_Name)
      if Msg_File is null then
         IO.Stderr.Println("Cannot create message file \"" |
           Translate::Msg_File_Name | '"')
      else
         if Verbose or Translate::Debug then
            IO.Stderr.Println("   [Error messages in file \"" | 
              Translate::Msg_File_Name | "\"]")
         end if
         Msg_File.Close()
      end if
   end if

   //  Compile each file (except for flags)
   func Process_One_File(F : String) is
      if Length(F) < 1 or else F[1] == '-' then
         //  it's it's the empty string or a flag, ignore it
         return
      end if
      if Verbose or Translate::Debug then
         Println("   [compiling `(F)]");
      end if
      Translate::Compile(F, LLVM_Debug => LLVM_Debug,
                         Doing_Run_Time_Checks => Doing_Run_Time_Checks,
                         Sequential => Sequential,
                         Verbose => Verbose,
                         More_Verbose => More_Verbose,
                         Max_Instrs_For_Inlining => Max_Instrs_For_Inlining,
                         Use_Stack_For_Objects => Use_Stack_For_Objects)
      if Translate::Debug or More_Verbose then
         Println("   [done compiling `(F)]");
      end if
   end func Process_One_File

   if Sequential then
      for each F of Files forward loop
         Process_One_File(F);
      end loop
   else
      for each F of Files concurrent loop
         Process_One_File(F);
      end loop
   end if

end func Compile
