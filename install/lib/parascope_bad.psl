// ParaScope: ParaSail Static Catcher of Programming Errors

// Copyright (C) 2011-2015, AdaCore, New York, NY
// This program is provided "as is" with no warranty.
// Report errors at http://groups.google.com/group/parasail-programming-language

import PSC::Reflection

interface PSC::CFG<> is
   // Control Flow graph of nodes connected by edges
   type Node_Id is new Integer<0 .. 100_000>
   type Edge_Id is new Integer<0 .. 100_000>

   type Node_Set is Countable_Set<Node_Id>

   const First_Node_Id := 1
   const First_Edge_Id := 1

   interface Edge<> is
      const From : Node_Id
      const To   : Node_Id
   end interface Edge

   interface Node<> is
      var First : optional Reflection::Routine::Code_Offset := null
      var Last  : optional Reflection::Routine::Code_Offset := null
      var Incoming_Edges : Vector<Edge_Id> := []
      var Outgoing_Edges : Vector<Edge_Id> := []
   end interface Node

   interface Node_List<> is
     // A list of nodes; used to represent an order for walking the graph.
      const Id   : Node_Id
      const Next : optional Node_List
   end interface Node_List

   op "[]"() -> CFG
   //  Create an empty control-flow graph

   func Add_Node(var CFG) -> Node_Id
   //  Add node to control-flow graph

   func Last_Node_Id(CFG) -> Node_Id

   op "magnitude"(CFG) -> Univ_Integer is ([[Last_Node_Id(CFG)]])
   //  Number of nodes in control-flow graph

   func Add_Edge(var CFG; From, To : Node_Id) -> Edge_Id
   //  Add edge to control-flow graph

   func Last_Edge_Id(CFG) -> Edge_Id;

   func Nth_Node(ref CFG; Node_Id) -> ref Node
   //  Return reference to Node given Node_Id

   op "indexing"(ref CFG; Node_Id) -> ref Node is Nth_Node

   func Nth_Edge(ref CFG; Edge_Id) -> ref Edge
   //  Return reference to Edge given Edge_Id

   func Successors(CFG; Node_Id) -> Vector<Node_Id>

   func Predecessors(CFG; Node_Id) -> Vector<Node_Id>

   func All_Nodes(CFG) -> Countable_Range<Node_Id>
     is (1 .. Last_Node_Id(CFG))

   func All_Edges(CFG) -> Countable_Range<Edge_Id>
     is (1 .. Last_Edge_Id(CFG))

   func Reverse_Postorder(CFG) -> optional Node_List
     {|CFG| > 0 ==> Reverse_Postorder not null}
     //  Return list of all nodes in a reverse postorder 

   interface Dominator_Tree<> is
      func Dominates (Dominator_Tree; Dominator, Dominated : Node_Id)
        -> Boolean
      //  Return true if Dominator dominates Dominated

      func Immediate_Dominator (Dominator_Tree; Node_Id) -> Node_Id
      //  Return immediate dominator of given node.  Returns
      //  self only if node is the entry node of the CFG.

      func Root (Dominator_Tree) -> Node_Id
      //  Return the "root" of the dominator tree

      func Dominance_Frontier (ref const Dominator_Tree; Node_Id)
        -> ref const Set<Node_Id>
      //  Return the "dominance frontier" for the given node.  R. Cytron et al
      //  defines this in "Efficiently computing static single assignment form
      //  and the control dependence graph"(1991) as "...the set of all cfg
      //  nodes, y, such that b dominates a predecessor of y but does not
      //  strictly dominate y."
      //  Dominance frontiers are useful in SSA -- an assignment occurring
      //  in a node b generally needs a phi-node in all nodes in the
      //  dominance frontier of node b.
      //  NOTE: A node can be in its own dominance frontier (generally
      //        this means the node is a loop header).

      func Reverse_Postorder(ref const Dominator_Tree)
        -> ref const Node_List
      //  Return Node_List in Reverse Postorder for the CFG from which the
      //  control-flow graph was computed.

      func Is_Loop_Header (Dominator_Tree; Node_Id) -> Boolean
      //  Return #true if the specified node is a loop header
      //  (which is defined to be a node that has itself in its
      //  dominance frontier).

      func Enclosing_Loop (Dominator_Tree; Node_Id) -> optional Node_Id
      //  Return Node_Id of innermost loop header that (strictly) dominates
      //  the given node.  If Node_Id is itself a loop header, this is the
      //  enclosing loop, if any.  It is null if this is an outermost
      //  loop header, or the block is not inside any loop.

      func Is_Within_Loop(Dominator_Tree; Member, Loop_Header : Node_Id)
        -> Boolean
      //  Return #true if Member is inside the loop headed by Loop_Header,
      //  directly or indirectly.
      //  Loop_Header is within its own loop, presuming it is a loop header.
      //  This returns false if Loop_Header is not in fact a loop header.

      func Compute(CFG) {|CFG| > 0} -> Dominator_Tree
      //  Compute the dominator tree for the given control-flow graph

   end interface Dominator_Tree

   func Compute_Dominator_Tree(var CFG)
   //  Compute dominator tree of CFG if not already computed;

   func Get_Dominator_Tree(ref const CFG) -> ref const optional Dominator_Tree
     {|CFG| > 0 ==> Get_Dominator_Tree not null}
   //  Return reference to dominator tree.

   func Dump_Graph(var File : Output_Stream+; CFG;
     Reflection::Routine; Label : Univ_String;
     Node_Attrib_Map : Map<CFG::Node_Id, Univ_String> := [];
     Edge_Attrib_Map : Map<CFG::Edge_Id, Univ_String> := [];
     DT : optional Dominator_Tree := null)
   //  Dump the control-flow graph.  If DT is non-null, then include
   //  the dominator tree and the dominance frontiers

end interface PSC::CFG

class PSC::CFG is
   var Nodes : Vector<Node> := []
   var Edges : Vector<Edge> := []
   var Dom_Tree : optional Dominator_Tree := null

   func Contains(Str, Substr : Univ_String) -> Boolean is
     //  Return #true if Substr appears within Str somewhere
     //  TBD: This should be in Univ_String module, perhaps as "in"
      const Str_Len := |Str|
      const Sub_Len := |Substr|
      for I in 1 .. Str_Len - Sub_Len + 1 loop
         if Str[I ..< I + Sub_Len] == Str then
            return #true
         end if
      end loop
   end func Contains

  exports

   op "[]"() -> CFG is
   //  Create an empty control-flow graph
      return ()
   end op "[]"

   func Add_Node(var CFG) -> Node_Id is
   //  Add node to control-flow graph
      CFG.Nodes |= (Incoming_Edges => [], Outgoing_Edges => [])
      CFG.Dom_Tree := null  //  Reset dominator tree to null
      return Node_Id::(|CFG.Nodes|)
   end func Add_Node

   func Last_Node_Id(CFG) -> Node_Id is
      return Node_Id::(|CFG.Nodes|)
   end func Last_Node_Id

   func Add_Edge(var CFG; From, To : Node_Id) -> Result : Edge_Id is
   //  Add edge to control-flow graph
      CFG.Edges |= (From => From, To => To)
      Result := Edge_Id::(|CFG.Edges|)

      //  Keep track of incoming and outgoing edges
      CFG.Nodes[From].Outgoing_Edges |= Result
      CFG.Nodes[To].Incoming_Edges |= Result

      CFG.Dom_Tree := null  //  Reset dominator tree to null
   end func Add_Edge

   func Last_Edge_Id(CFG) -> Edge_Id is
      return Edge_Id::(|CFG.Edges|)
   end func Last_Edge_Id

   func Nth_Node(ref CFG; Node_Id) -> ref Node is
   //  Return reference to Node given Node_Id
      return CFG.Nodes[Node_Id]
   end func Nth_Node

   func Nth_Edge(ref CFG; Edge_Id) -> ref Edge is
   //  Return reference to Edge given Edge_Id
      return CFG.Edges[Edge_Id]
   end func Nth_Edge

   func Successors(CFG; Node_Id) -> Vector<Node_Id> is
      return [for each E of CFG[Node_Id].Outgoing_Edges => CFG.Edges[E].To]
   end func Successors

   func Predecessors(CFG; Node_Id) -> Vector<Node_Id> is
      return [for each E of CFG[Node_Id].Incoming_Edges => CFG.Edges[E].From]
   end func Predecessors

   func Reverse_Postorder(CFG) -> Result : optional Node_List is
     //  Return list of all nodes in a reverse postorder 
      var Visited : Bit_Set<Node_Id> := Create(CFG.All_Nodes(), #false)

      func Visit(Id : Node_Id) is
         //  Visit all successors of un-visited nodes
         if Id not in Visited then
            var Node_To_Visit := Id
            var Preds : Node_Set := []

            while |CFG[Node_To_Visit].Incoming_Edges| == 1 loop
               //  Always visit singleton predecessor first
               //  so reverse post-order ensures singleton predecessors
               //  come before their successors.
               const Only_Pred :=
                 CFG.Edges[CFG[Node_To_Visit].Incoming_Edges[1]].From

               if Only_Pred == Id
                 or else Only_Pred in Visited
                 or else Only_Pred in Preds
               then  //  Avoid infinite loop
                  exit loop
               end if
               Node_To_Visit := Only_Pred
               Preds |= Only_Pred  // Remember we already looked at this one
            end loop

            //  Now visit the Node_To_Visit
            Visited |= Node_To_Visit
            for each E of CFG[Node_To_Visit].Outgoing_Edges reverse loop
               //  Visit each successor, going in reverse order
               //  so returned list ends up in forward order.
               Visit (CFG.Edges[E].To)
            end loop

            //  Add Node_To_Visit to front of reverse post-order
            Result := (Id => Node_To_Visit, Next <== Result)

            {Id in Visited}  //  Should have visited original node by now
         end if
      end func Visit

      for N in All_Nodes(CFG) reverse loop
         //  Visit each node.
         //  Visit in reverse order to reduce depth of recursion.
         Visit(N)
      end loop

      {|CFG| > 0 ==> Result not null}
   end func Reverse_Postorder

   func Dump_Graph(var File : Output_Stream+; CFG;
     Reflection::Routine; Label : Univ_String;
     Node_Attrib_Map : Map<CFG::Node_Id, Univ_String> := [];
     Edge_Attrib_Map : Map<CFG::Edge_Id, Univ_String> := [];
     DT : optional Dominator_Tree) is

      func Node_Name(N : Node_Id) -> Univ_String is
         //  Return node name to uniquely identify node with given Node_Id
         ref N_Node => CFG[N]
         return "BB" | N
      end func Node_Name

      func Node_Label(N : Node_Id) -> Univ_String is
         //  Return label to be displayed for node with given Node_Id
         ref N_Node => CFG[N]
         return "BB" | N | ": I" | N_Node.First | "-I" | N_Node.Last | ",\n" |
           "L" | Source_Pos(Routine.Nth_Instr(N_Node.First)).Line() | "-L" |
           Source_Pos(Routine.Nth_Instr(N_Node.Last)).Line()
      end func Node_Label

      File.Println("digraph G {\n label = \"" | Label.Replace('"', With => '$')
        | "\";")
      //  Indicate the root node
      File.Println(" root = " |
        Node_Name(DT not null? DT.Root() : CFG::First_Node_Id) | ";")

      for E in CFG.All_Edges() loop
         ref Edge => CFG.Nth_Edge(E)
         var Style : Univ_String := ""
         if E in Edge_Attrib_Map then
            Style := "[label=E" | E | "," | Edge_Attrib_Map[E] | "]"
         else
            Style := "[label=E" | E | "]"
         end if
         File.Println(" " | Node_Name(Edge.From) | " -> " |
                            Node_Name(Edge.To) | Style | ";")
      end loop

      for N in CFG.All_Nodes() forward loop
         var Style := ""
         if N in Node_Attrib_Map then
            Style := "," | Node_Attrib_Map[N]
         end if

         File.Println(" " | Node_Name(N) |
           "[label=\"" | Node_Label(N) | '"' | Style | "];")
      end loop

      //  Add edges to represent the dominator tree, if DT not null
      if DT not null then
         for N in CFG.All_Nodes() forward loop
            ref DF => DT.Dominance_Frontier(N)
            const Idom := DT.Immediate_Dominator(N)
            const Encl_Loop := DT.Enclosing_Loop(N)

            ref BB => CFG[N]
            const BB_Graph_Id := Node_Name(N)

            const DF_Image := "[" |
              (for (F in DF; Sep := "" then ", ") => <""> | Sep | F) | "]"

            if Idom != N then
               //  Use bold, blue arrows for dominator relationship;
               //  Suppress any self-dominators as they are not interesting.
               File.Println(" " | Node_Name(Idom) |
                 " -> " | BB_Graph_Id | "[style=bold,color=blue];")
            end if

            //  Use dashed, light blue arrors for dominance frontier
            for F in DF loop
               File.Println(BB_Graph_Id | " -> " | Node_Name(F) |
                 "[style=dashed,color=lightblue];")
            end loop

            if DT.Is_Loop_Header(N) then
               if N not in Node_Attrib_Map
                 or else not Contains(Node_Attrib_Map[N], "fillcolor")
               then
                  //  Make loop headers pink (unless overridden)
                  File.Println(BB_Graph_Id |
                    "[style=filled,fillcolor=pink];")
               end if;

               //  Make each loop into a cluster
               File.Println("subgraph cluster_" | BB_Graph_Id | "{")
               File.Println("  label=\"Loop header: " | BB_Graph_Id | "\";")
               for In_Loop in CFG.All_Nodes() {DT.Is_Within_Loop(In_Loop, N)}
               loop
                  File.Print(" " | Node_Name(In_Loop))
               end loop
               File.Println("\n}")
            end if

            if #false and then Encl_Loop not null then
               //  Add arrows for enclosing loop
               //  TBD: Suppressed for now
               ref Encl_Loop_Node => CFG[Encl_Loop]
               File.Println(BB_Graph_Id | " -> BB" | Encl_Loop | "_" |
                 Encl_Loop_Node.First | "_" | Encl_Loop_Node.Last |
                 "[style=dashed,color=pink];")
            end if
            
         end loop
      end if
      File.Println("}")
      File.Flush()
   end func Dump_Graph

   class Dominator_Tree is
      interface Dominator_Info<> is
         // Dominator tree information
         type Order is new Integer<1 .. 100_000>  // reverse-postorder position

         var Immediate_Dominator : optional Node_Id := null
         var Dominance_Frontier : Set<Node_Id> := []
         var Position : optional Order := null
         var Is_Loop_Header : Boolean := #false
         var Enclosing_Loop : optional Node_Id := null
           //  For a loop header, this is the enclosing loop, or null
           //  if this is an outermost loop.

      end interface Dominator_Info

      const Root : optional Node_Id
      const RP_Order : optional Node_List
      var Dom_Info : Array<Dominator_Info, Indexed_By => Node_Id>
      
     exports

      func Dominates (Dominator_Tree; Dominator, Dominated : Node_Id)
        -> Boolean is
      //  Return true if Dominator dominates Dominated
         for Dom := Dominated
           then Dominator_Tree.Dom_Info[Dom].Immediate_Dominator
           while Dom != Dominator loop
            //  Look up the immediate-dominator chain
            if Dom == Dominator_Tree.Root then
               //  Reached the end of the chain
               return #false
            end if
         end loop
         //  Found the dominator in the immediate-dominator chain
         return #true
      end func Dominates

      func Root (Dominator_Tree) -> Node_Id is (Dominator_Tree.Root)
      //  Return the "root" of the dominator tree

      func Immediate_Dominator (Dominator_Tree; Node_Id) -> Node_Id is
      //  Return immediate dominator of given node.  Returns
      //  self only if node is the entry node of the CFG.
         return Dominator_Tree.Dom_Info[Node_Id].Immediate_Dominator
      end func Immediate_Dominator

      func Dominance_Frontier (ref const Dominator_Tree; Node_Id)
        -> ref const Set<Node_Id> is
         return Dominator_Tree.Dom_Info[Node_Id].Dominance_Frontier
      end func Dominance_Frontier

      func Reverse_Postorder(ref const Dominator_Tree)
        -> ref const Node_List is
      //  Return Node_List in Reverse Postorder for the CFG from which the
      //  control-flow graph was computed.
         return Dominator_Tree.RP_Order
      end func Reverse_Postorder

      func Is_Loop_Header (Dominator_Tree; Node_Id) -> Boolean is
      //  Return #true if the specified node is a loop header
      //  (which is defined to be a node that has itself in its
      //  dominance frontier).
         return Dominator_Tree.Dom_Info[Node_Id].Is_Loop_Header
      end func Is_Loop_Header

      func Enclosing_Loop (Dominator_Tree; Node_Id) -> optional Node_Id is
      //  Return Node_Id of innermost loop header that (strictly) dominates
      //  the given node.  If Node_Id is itself a loop header, this is the
      //  enclosing loop, if any.  It is null if this is an outermost
      //  loop header, or the block is not inside any loop.
         return Dominator_Tree.Dom_Info[Node_Id].Enclosing_Loop
      end func Enclosing_Loop

      func Is_Within_Loop(DT : Dominator_Tree; Member, Loop_Header : Node_Id)
        -> Boolean is
      //  Return #true if Member is inside the loop headed by Loop_Header,
      //  directly or indirectly.
      //  Loop_Header is within its own loop, presuming it is a loop header.
      //  This returns false if Loop_Header is not in fact a loop header.

         return DT.Dom_Info[Loop_Header].Is_Loop_Header
           and then (for some LH := Member
                     then DT.Dom_Info[LH].Enclosing_Loop
                     while LH not null => LH == Loop_Header)
      end func Is_Within_Loop

      func Compute(CFG) -> DT : Dominator_Tree is
        //  Compute the dominator tree for the given control-flow graph
        //  This is based on the paper:
        //    A Simple, Fast Dominance Algorithm
        //  by: Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy
        //      Rice University

        //  NOTE: we use a reverse-postorder numbering while the above paper
        //        uses a (forward) postorder numbering.

         {|CFG| > 0}
   
         func Common_Dominator (N1, N2 : Node_Id) -> Node_Id is
           //  Compute common dominator of N1 and N2
            var N1_Dom := N1
            var N2_Dom := N2
            while N1_Dom != N2_Dom loop
               
               //  Keep walking up N1's dominator chain as long as we haven't
               //  passed N2
               while DT.Dom_Info[N1_Dom].Position >
                 DT.Dom_Info[N2_Dom].Position loop
                  N1_Dom := DT.Dom_Info[N1_Dom].Immediate_Dominator
               end loop

               //  Keep walking up N2's dominator chain as long as we haven't
               //  passed N1
               while DT.Dom_Info[N2_Dom].Position >
                 DT.Dom_Info[N1_Dom].Position loop
                  N2_Dom := DT.Dom_Info[N2_Dom].Immediate_Dominator
               end loop
            end loop

            //  We found a common dominator
            return N1_Dom
         end func Common_Dominator

         const RP_Order := Reverse_Postorder(CFG)

         {RP_Order not null}

         //  Create initial dominator-tree info
         DT := (Root => RP_Order.Id,
                RP_Order => RP_Order,
                Dom_Info => Create(CFG.All_Nodes(), ()))

         //  Initialize reverse-postorder Position in Dom_Info array
         for (N => RP_Order then N.Next while N not null;
              I in Dominator_Info::Order forward) loop
            DT.Dom_Info[N.Id].Position := I
         end loop

         //  Root node has no predecessors, so we mark it as its own
         //  immediate dominator -- TBD: not clear this is a good idea,
         //  but the published algorithm does that!
         DT.Dom_Info[DT.Root].Immediate_Dominator := DT.Root

        *Find_Immediate_Dominators*
         loop
            var Changed : Boolean := #false

            //  Walk nodes in reverse post-order, skipping the root node
            for N => RP_Order.Next then N.Next while N not null loop
               //  Compute a new dominator for N.Id
               var New_Idom : optional Node_Id := null

               for each Pred of Predecessors(CFG, N.Id) forward loop
                  const Pred_Idom := DT.Dom_Info[Pred].Immediate_Dominator
                  if Pred_Idom not null then
                     //  Found a predecessor that has been processed
                     if New_Idom is null then
                        //  This is the first predecessor already processed.
                        //  Start with this as the new dominator.
                        New_Idom := Pred
                     else
                        //  Second or subsequent predecessor.
                        //  Find a common dominator.
                        New_Idom := Common_Dominator(New_Idom, Pred)
                     end if
                  end if
               end loop 

               if DT.Dom_Info[N.Id].Immediate_Dominator is null
                 or else
                   New_Idom != DT.Dom_Info[N.Id].Immediate_Dominator
               then
                  //  We have a new dominator for this node
                  DT.Dom_Info[N.Id].Immediate_Dominator := New_Idom
                  Changed := #true  //  Need to iterate further
               end if
            end loop

            if not Changed then
               //  We are all done
               exit loop
            end if

         end loop Find_Immediate_Dominators

         //  We will keep track of all of the loop headers
         var Loop_Headers : Node_Set := []

         //  Now compute the dominance frontiers for each node.
         //  Algorithm: for each node with more than one predecessor,
         //             add it to each predecessor's dominance frontier
         //             unless the predecessor dominates the original node.
         //             Keep doing this up the immediate dominator chain
         //             until reaching the immediate dominator of the original
         //             node.
        *Compute_Dominance_Frontier*
         for N in CFG.All_Nodes() loop
            if |CFG[N].Incoming_Edges| > 1 then
               //  Found a join point
               const Join_Point_Idom := DT.Dom_Info[N].Immediate_Dominator

               //  Add N to each node in dominator chain of each predecessor
               //  until it reaches the Join_Point_Idom.
               for each Pred of CFG.Predecessors(N) loop
                  //  Walk up the dominator chain
                  for Pred_Dom := Pred
                    then DT.Dom_Info[Pred_Dom].Immediate_Dominator
                    while Pred_Dom != Join_Point_Idom
                      and then N not in
                        DT.Dom_Info[Pred_Dom].Dominance_Frontier
                  loop
                     //  Add to dominance frontier of dominator of pred
                     DT.Dom_Info[Pred_Dom].Dominance_Frontier |= N
                     if Pred_Dom == N then
                        //  This must be a loop header, as it is in its own
                        //  dominance frontier
                        DT.Dom_Info[N].Is_Loop_Header := #true
                        Loop_Headers |= N
                     end if
                  end loop
               end loop
            end if
         end loop Compute_Dominance_Frontier

         //  Walk loop headers and build up natural loops by walking
         //  down all back edges.
        *Find_Enclosing_Loops*
         for LH in Loop_Headers loop
            var Preds_Visited : Node_Set := []
            var Preds_To_Be_Visited : Node_Set :=
               [for each P of CFG.Predecessors(LH) => P]

            //  Keep visiting predecessors until Preds_To_Be_Visited is empty
            for Pred := Remove_Any(Preds_To_Be_Visited)
              then Remove_Any(Preds_To_Be_Visited)
              while Pred not null
            loop
               if Pred != LH and then DT.Dominates(LH, Pred) then
                  //  We have a (strictly) dominated predecessor.
                  //  Set its Enclosing_Loop to LH if it is null or
                  //  if it points to a loop header that dominates LH.
                  ref Encl_Loop => DT.Dom_Info[Pred].Enclosing_Loop

                  if Encl_Loop is null
                    or else DT.Dominates(Encl_Loop, LH)
                  then
                     Encl_Loop := LH
                  end if

                  Preds_Visited |= Pred

                  //  Visit all of the predecessors of this node
                  for each P of CFG.Predecessors(Pred) loop
                     if P not in Preds_Visited then
                        Preds_To_Be_Visited |= P
                     end if
                  end loop
               end if
            end loop
         end loop Find_Enclosing_Loops
         
      end func Compute

   end class Dominator_Tree

   func Compute_Dominator_Tree(var CFG) is
   //  Compute dominator tree of CFG if not already computed;
      if |CFG| > 0 and then CFG.Dom_Tree is null then
         //  Compute the dominator tree
         CFG.Dom_Tree := Compute(CFG)
      end if
   end func Compute_Dominator_Tree

   func Get_Dominator_Tree(ref const CFG)
     -> ref const optional Dominator_Tree is
   //  Return reference to dominator tree.

      {|CFG| > 0 ==> CFG.Dom_Tree not null}
      return CFG.Dom_Tree
   end func Get_Dominator_Tree

end class PSC::CFG

import PSC::CFG::*, PSC::Reflection

func Test_CFG(N : Univ_Integer) is
   var Ran := Random::Start()
   var CFG := PSC::CFG::[]
   for I in 1 .. N loop
      const Ignore := Add_Node(CFG)
   end loop

   for I in 1 .. N*10 loop
      const Ran1 : Node_Id := Ran.Next() mod N + 1
      const Ran2 : Node_Id := Ran.Next() mod N + 1
      if (for all S of Successors(CFG, Ran1) => Ran2 != S) then
         // Println("Adding edge " | Ran1 | " -> " | Ran2)
         const Ignore := Add_Edge(CFG, From => Ran1, To => Ran2)
      end if
   end loop

   Println("Last_Node_Id = " | Last_Node_Id(CFG))
   Println("Last_Edge_Id = " | Last_Edge_Id(CFG))

   Println("digraph CFG {");
   for I in CFG.All_Edges() loop
      ref const Edge => Nth_Edge(CFG, I)
      Println("N" | Edge.From | " -> " | "N" | Edge.To | ";");
   end loop
   Println("}");

end func Test_CFG

import PSL::Short_Names::*,PSC::Reflection, PSC::Debugging, PSC::Analysis::*
import PSC::CFG

interface PSC::Analysis<> is
   const Debug : Boolean := #true
   const Debug_Verbose : Boolean := #true
   const Debug_Value_Numbering : Boolean := #true
   const Msg_File_Name : optional Univ_String := "errors.err"

   func Analyze(File_Name : String)

   type VN_Id is new Integer<0 .. 100_000>  
      //  Unique id assigned to value number and index into VN_Table

   type OID is new Integer<0 .. 100_000>
      //  Unique id assigned to an "origin" info and index into OID_Table

   type Code_Nesting_Level is Reflection::Code_Nesting_Level
      //  Used for dealing with up-level references

   type Output_Index is new Integer<0 .. 1_000>

   func Put_Error
     (Message : Univ_String;
      Source_Pos : optional Reflection::Source_Position := null;
      Message_Kind : Univ_String := "Error")
   //  Put out an error message on the standard error stream

   func Put_Warning
     (Message : Univ_String;
      Source_Pos : optional Reflection::Source_Position := null;
      Message_Kind : Univ_String := "Warning") is Put_Error

   func Compare_VN_Vectors(Left, Right : Vector<VN_Id>) -> Ordering;

   type VN_To_VN_Map_Type is
     Ordered_Map<Key_Type => VN_Id, Value_Type => VN_Id>

   type VN_To_OID_Map_Type is Ordered_Map<Key_Type => VN_Id, Value_Type => OID>
   type OID_To_VN_Map_Type is Ordered_Map<Key_Type => OID, Value_Type => VN_Id>
   type OID_To_UV_Map_Type is
     Ordered_Map<Key_Type => OID, Value_Type => Updated_Value>

   type VN_OID_Two_Way_Map_Type is
     Two_Way_Map<Key_Type => VN_Id, Value_Type => OID>

   type VN_Set is Ordered_Set<VN_Id>

   type VN_To_Value_Set_Map_Type is
     Ordered_Map<Key_Type => VN_Id, Value_Type => Value_Set+>

   type VN_Table is Indexed_Set<Value_Number+, VN_Id>

   type OID_Table is Indexed_Set<Origin_Info+, OID>

   func Is_Literal_VN(VN_Table; VN : VN_Id) -> Boolean
      //  Return #true if VN is the value number for a literal VN

   func Int_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_Integer
      //  Return value of int literal, or null if VN is not an int-literal VN

   func Enum_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_Enumeration
      //  Return value of enum literal, or null if VN is not an enum-literal VN

   func Str_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_String
      //  Return value of string lit, or null if VN is not an str-literal VN

   func Get_Int_Literal_VN(var VN_Table; Int_Val : Univ_Integer) -> VN_Id
      //  Return Int_Literal_VN for given int value

   func Get_Bool_Literal_VN(var VN_Table; Bool_Val : Boolean) -> VN_Id
      //  Return Bool_Literal_VN for given bool value

   func Boolean_Vals(VN_Values : VN_To_Value_Set_Map_Type; VN : VN_Id)
     -> Boolean_Value_Set
      //  Return stored Boolean_Value_Set of VN, or return an anything-goes
      //  value set (Might be null/true/false) if nothing stored yet.

   func Countable_Vals(VN_Values : VN_To_Value_Set_Map_Type; VN : VN_Id)
     -> Countable_Value_Set
      //  Return stored Countable_Value_Set of VN, or return an anything-goes
      //  value set (Might be null/-inf .. +inf) if nothing stored yet.

end interface PSC::Analysis

abstract interface PSC::Analysis::Value_Set<> is
  // Value sets are represented in various ways, depending on the
  // kind of value.  Initially we have Boolean_Value_Sets and
  // Countable_Value_Sets.  We will also have value sets for
  // floating point numbers (and perhaps Fixed as well?).
  // We might also have CTK_Value_Sets, which
  // would be sets of compile-time-known VNs that a given value number
  // might contain.

   var Might_Be_Null : Boolean := #true
   op "|="(var Left : Value_Set; Right : Value_Set)
   op "and="(var Left : Value_Set; Right : Value_Set)
   func Value_Kind(Value_Set) -> Univ_Enumeration
   optional func Set_Is_Null(var Value_Set)
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.
   func Is_Empty(Value_Set) -> Boolean
   op "=?"(Left, Right : Value_Set) -> Ordering
   func Hash(Value_Set) -> Univ_Integer
   func To_String(Value_Set) -> Univ_String
   optional func From_String(Univ_String) -> optional Value_Set
end interface PSC::Analysis::Value_Set

interface PSC::Analysis::Boolean_Value_Set<> extends Value_Set is
  // A representation for the set of possible Boolean values, namely
  // #true, #false, and null.
  // TBD: We might have simply used Countable_Value_Set for this instead.
   var Might_Be_True : Boolean := #true
   var Might_Be_False : Boolean := #true
   op "|="(var Left : Boolean_Value_Set; Right : Boolean_Value_Set)
   
   op "and="(var Left : Boolean_Value_Set; Right : Boolean_Value_Set)

   func Value_Kind(Boolean_Value_Set) -> Univ_Enumeration
     is (#Boolean)

   func Set_Is_Null(var Vals : Boolean_Value_Set)
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.

   func Is_Empty(Vals : Boolean_Value_Set) -> Boolean
     is (not (Vals.Might_Be_True
              or Vals.Might_Be_False
              or Vals.Might_Be_Null))

   op "=?"(Left, Right : Boolean_Value_Set) -> Ordering
     is (Left.Might_Be_True == Right.Might_Be_True
           and then Left.Might_Be_False == Right.Might_Be_False
           and then Left.Might_Be_Null == Right.Might_Be_Null? #equal :
         Left.Might_Be_True <= Right.Might_Be_True
           and then Left.Might_Be_False <= Right.Might_Be_False
           and then Left.Might_Be_Null <= Right.Might_Be_Null? #less :
         Left.Might_Be_True >= Right.Might_Be_True
           and then Left.Might_Be_False >= Right.Might_Be_False
           and then Left.Might_Be_Null >= Right.Might_Be_Null? #greater :
         #unordered)

   func Hash(Vals : Boolean_Value_Set) -> Univ_Integer
     is ((Vals.Might_Be_True - Boolean::First())*2 +
         (Vals.Might_Be_False - Boolean::First()))

   func To_String(Vals : Boolean_Value_Set) -> Univ_String
     is ("Boolean::[" | (Vals.Might_Be_Null? "null " : "") |
         (Vals.Might_Be_False? "false " : "") |
         (Vals.Might_Be_True? "true " : "") | "]")
end interface PSC::Analysis::Boolean_Value_Set

class PSC::Analysis::Boolean_Value_Set is
  exports
   op "|="(var Left : Boolean_Value_Set; Right : Boolean_Value_Set) is
      Left.Might_Be_Null  or= Right.Might_Be_Null
      Left.Might_Be_True  or= Right.Might_Be_True
      Left.Might_Be_False or= Right.Might_Be_False
   end op "|="
   
   op "and="(var Left : Boolean_Value_Set; Right : Boolean_Value_Set) is
      Left.Might_Be_Null  and= Right.Might_Be_Null
      Left.Might_Be_True  and= Right.Might_Be_True
      Left.Might_Be_False and= Right.Might_Be_False
   end op "and="

   func Set_Is_Null(var Vals : Boolean_Value_Set) is
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.
      Vals.Might_Be_True := #false
      Vals.Might_Be_False := #false
   end func Set_Is_Null

end class PSC::Analysis::Boolean_Value_Set

interface PSC::Analysis::Countable_Value_Set<> extends Value_Set is
  // A representation for a set of integer or integer-like values.
   var Possible_Values : Countable_Set<Univ_Integer> := [..]
   op "|="(var Left : Countable_Value_Set; Right : Countable_Value_Set)
   
   op "and="(var Left : Countable_Value_Set; Right : Countable_Value_Set)

   func Value_Kind(Countable_Value_Set) -> Univ_Enumeration
     is (#Countable)

   func Set_Is_Null(var Vals : Countable_Value_Set)
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.

   func Is_Empty(Vals : Countable_Value_Set) -> Boolean
     is (not Vals.Might_Be_Null and then Is_Empty(Vals.Possible_Values))

   func Hash(Vals : Countable_Value_Set) -> Univ_Integer
     is ((Vals.Might_Be_Null - Boolean::First())*100 + |Vals.Possible_Values|)

   op "=?"(Left, Right : Countable_Value_Set) -> Ordering
     is (Left.Might_Be_Null == Right.Might_Be_Null
           and then Left.Possible_Values == Right.Possible_Values? #equal :
         Left.Might_Be_Null <= Right.Might_Be_Null
           and then Left.Possible_Values <= Right.Possible_Values? #less :
         Left.Might_Be_Null >= Right.Might_Be_Null
           and then Left.Possible_Values >= Right.Possible_Values?
              #greater : #unordered)

   func To_String(Vals : Countable_Value_Set) -> Univ_String
end interface PSC::Analysis::Countable_Value_Set

class PSC::Analysis::Countable_Value_Set is
  exports
   op "|="(var Left : Countable_Value_Set; Right : Countable_Value_Set) is
      Left.Might_Be_Null or= Right.Might_Be_Null
      Left.Possible_Values or= Right.Possible_Values
   end op "|="
   
   op "and="(var Left : Countable_Value_Set; Right : Countable_Value_Set) is
      Left.Might_Be_Null and= Right.Might_Be_Null
      Left.Possible_Values and= Right.Possible_Values
   end op "and="

   func Set_Is_Null(var Vals : Countable_Value_Set) is
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.
      Vals.Possible_Values := []
   end func Set_Is_Null

   func To_String(Vals : Countable_Value_Set) -> Univ_String is
      const Rngs := Ranges(Vals.Possible_Values)
      return "Countable::[" | (Vals.Might_Be_Null? "null " : "") |
        (for R in Rngs forward =>
            <""> | R.First | ".." | R.Last | " ") | "]"
   end func To_String

end class PSC::Analysis::Countable_Value_Set

abstract interface PSC::Analysis::Value_Number<> is
   //  Value numbers are all extensions of this root interface
   //  TBD: Add a "type" field to all value numbers?
   func Hash(Value_Number) -> Univ_Integer
   op "=?"(Left, Right : Value_Number) -> Ordering

   optional func Child_Vec(Value_Number) -> optional Vector<VN_Id>

   optional func Compute_Value_Set
     (Value_Number; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   optional func Propagate_To_Operands
     (Value_Number; Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional VN_To_Value_Set_Map_Type is ([])
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.

   func To_String(Value_Number) -> Univ_String
   optional func From_String(Univ_String) -> optional Value_Number

end interface PSC::Analysis::Value_Number

//  Begin Literal Value Numbers

abstract interface PSC::Analysis::Literal_VN<>
   extends PSC::Analysis::Value_Number is
   type Literal_Kind is Enum<[#Null, #Univ_String, #Univ_Enumeration,
            #Univ_Integer, #Univ_Real, #Univ_Character, #Boolean]>;
   func Kind(L : Literal_VN) -> Literal_Kind;
   func Hash(L : Literal_VN) -> Univ_Integer;
   op "=?"(Left, Right : Literal_VN) -> Ordering;
end interface PSC::Analysis::Literal_VN;

interface PSC::Analysis::Null_Literal_VN<>
   extends PSC::Analysis::Literal_VN is
   func Kind(L : Null_Literal_VN) -> Literal_Kind is (#Null);
   func Hash(L : Null_Literal_VN) -> Univ_Integer is (1);
   op "=?"(Left, Right : Null_Literal_VN) -> Ordering is (#equal)
   func To_String(L : Null_Literal_VN) -> Univ_String
     is ("(Null_Literal)")
end interface PSC::Analysis::Null_Literal_VN;

interface PSC::Analysis::String_Literal_VN<>
   extends PSC::Analysis::Literal_VN is
   const Value : Univ_String;
   func Kind(L : String_Literal_VN) -> Literal_Kind is (#Univ_String);
   func Hash(L : String_Literal_VN) -> Univ_Integer is (Hash(L.Value));
   op "=?"(Left, Right : String_Literal_VN) -> Ordering is
      (Left.Value =? Right.Value);
   func To_String(L : String_Literal_VN) -> Univ_String
     is ("(String_Literal, \"" | L.Value | "\")")
end interface PSC::Analysis::String_Literal_VN;

interface PSC::Analysis::Enum_Literal_VN
   extends PSC::Analysis::Literal_VN is
   const Value : Univ_Enumeration;
   func Kind(L : Enum_Literal_VN) -> Literal_Kind is (#Univ_Enumeration);
   func Hash(L : Enum_Literal_VN) -> Univ_Integer is (Hash(L.Value));
   op "=?"(Left, Right : Enum_Literal_VN) -> Ordering is
      ((Left.Value =? Right.Value));
   func To_String(L : Enum_Literal_VN) -> Univ_String
     is ("(Enum_Literal, " | L.Value | ")")
end interface PSC::Analysis::Enum_Literal_VN;

interface PSC::Analysis::Int_Literal_VN<>
   extends PSC::Analysis::Literal_VN is
   const Value : Univ_Integer;
   func Kind(L : Int_Literal_VN) -> Literal_Kind is (#Univ_Integer);
   func Hash(L : Int_Literal_VN) -> Univ_Integer is (L.Value);
   op "=?"(Left, Right : Int_Literal_VN) -> Ordering is
      (Left.Value =? Right.Value);
   
   func Compute_Value_Set
     (Int_Lit : Int_Literal_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   func To_String(L : Int_Literal_VN) -> Univ_String
     is ("(Int_Literal, " | L.Value | ")")

  new
   
end interface PSC::Analysis::Int_Literal_VN;

class PSC::Analysis::Int_Literal_VN is
  exports
   func Compute_Value_Set
     (Int_Lit : Int_Literal_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> Result : optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
     Result := Countable_Value_Set::(Might_Be_Null => #false,
                                     Possible_Values => [Int_Lit.Value])
     if Result is null then
        Println("Countable_Value_Set is null??")
     end if
   end func Compute_Value_Set
end class PSC::Analysis::Int_Literal_VN

interface PSC::Analysis::Real_Literal_VN<>
   extends PSC::Analysis::Literal_VN is
   const Value : Univ_Real;
   func Kind(L : Real_Literal_VN) -> Literal_Kind is (#Univ_Real);
   func Hash(L : Real_Literal_VN) -> Univ_Integer is (Hash(L.Value));
   op "=?"(Left, Right : Real_Literal_VN) -> Ordering is
      (Left.Value =? Right.Value);
   func To_String(L : Real_Literal_VN) -> Univ_String
     is ("(Real_Literal, " | L.Value | ")")
end interface PSC::Analysis::Real_Literal_VN;

interface PSC::Analysis::Char_Literal_VN<>
   extends PSC::Analysis::Literal_VN is
   const Value : Univ_Character;
   func Kind(L : Char_Literal_VN) -> Literal_Kind is (#Univ_Character);
   func Hash(L : Char_Literal_VN) -> Univ_Integer is (Hash(L.Value));
   op "=?"(Left, Right : Char_Literal_VN) -> Ordering is
      (Left.Value =? Right.Value);
   func To_String(L : Char_Literal_VN) -> Univ_String
     is ("(Char_Literal, '" | L.Value | "')")
end interface PSC::Analysis::Char_Literal_VN;

interface PSC::Analysis::Bool_Literal_VN<>
   extends PSC::Analysis::Literal_VN is
   const Value : Boolean
   func Kind(L : Bool_Literal_VN) -> Literal_Kind is (#Boolean);
   func Hash(L : Bool_Literal_VN) -> Univ_Integer is (Hash(L.Value));
   op "=?"(Left, Right : Bool_Literal_VN) -> Ordering is
      (Left.Value =? Right.Value);
   func To_String(L : Bool_Literal_VN) -> Univ_String
     is ("(Bool_Literal, " | L.Value | ")")

   func Compute_Value_Set
     (Bool_Lit : Bool_Literal_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

end interface PSC::Analysis::Bool_Literal_VN;

class PSC::Analysis::Bool_Literal_VN is
  exports
   func Compute_Value_Set
     (Bool_Lit : Bool_Literal_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> Result : optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
     Result := Boolean_Value_Set::(Might_Be_Null => #false,
                                   Might_Be_True => Bool_Lit.Value,
                                   Might_Be_False => not Bool_Lit.Value)
   end func Compute_Value_Set
end class PSC::Analysis::Bool_Literal_VN

//  Begin Component selector value numbers

abstract interface PSC::Analysis::Component_Selector_VN<>
   extends PSC::Analysis::Value_Number is
   type Component_Selector_VN_Id is VN_Id
   type Selector_Kind is
     Enum<[#named, #static_index, #dynamic_index, #referenced_part]>
   func Kind(Component_Selector_VN) -> Selector_Kind
end interface PSC::Analysis::Component_Selector_VN

interface PSC::Analysis::Named_Selector_VN<>
   extends PSC::Analysis::Component_Selector_VN is
   //  A named selector is determined completely by the offset
   const Offset : Reflection::Offset_Within_Area;

   func Kind(Named_Selector_VN) -> Selector_Kind is (#named)

   func Hash(S : Named_Selector_VN) -> Univ_Integer is ([[S.Offset]])
   op "=?"(Left, Right : Named_Selector_VN) -> Ordering is
      (Left.Offset =? Right.Offset);
   func To_String(S : Named_Selector_VN) -> Univ_String
     is ("(Named_Selector, " | S.Offset | ")")
end interface PSC::Analysis::Named_Selector_VN

interface PSC::Analysis::Indexed_Selector_VN<>
   extends PSC::Analysis::Component_Selector_VN is
   //  An indexed selector is determined by the indexing routine
   //  and its (non-ref) operands.
   const Indexing_Routine_Id : VN_Id;
   const Indexing_Operands : Vector<VN_Id>
   const Is_Indexing_Op : Boolean  //  If true, may assume no overlap when
                                   //  Indexing_Operands are distinct.
   const Is_Static_Indexing : Boolean //  If true, all Indexing_Operands
                                      //  are literals

   func Kind(S : Indexed_Selector_VN) -> Selector_Kind
     is (not S.Is_Indexing_Op? #referenced_part:
         S.Is_Static_Indexing? #static_index: #dynamic_index)

   func Hash(S : Indexed_Selector_VN) -> Univ_Integer
     is ((for each [I => V] of S.Indexing_Operands => <0> + I * [[V]]))

   op "=?"(Left, Right : Indexed_Selector_VN) -> Ordering is
      (Left.Indexing_Routine_Id != Right.Indexing_Routine_Id?
        Left.Indexing_Routine_Id =? Right.Indexing_Routine_Id:
       Compare_VN_Vectors(Left.Indexing_Operands, Right.Indexing_Operands))

   func Child_Vec(S : Indexed_Selector_VN) -> Vector<VN_Id>
     is ([S.Indexing_Routine_Id] | S.Indexing_Operands)

   func To_String(S : Indexed_Selector_VN) -> Univ_String
     is ("(Indexed_Selector, routine VN" | S.Indexing_Routine_Id |
          (S.Is_Indexing_Op?
            (for each V of S.Indexing_Operands forward =>
               <""> | "[VN" | V | "]") :
            (for each V of S.Indexing_Operands forward =>
               <""> | ", VN" | V)) | ")")
end interface PSC::Analysis::Indexed_Selector_VN

//  Begin Address Value Numbers

abstract interface PSC::Analysis::Addr_VN<>
  extends PSC::Analysis::Value_Number is
   //  Address VNs are all extensions of this
   type Addr_VN_Id is VN_Id
end interface PSC::Analysis::Addr_VN

interface PSC::Analysis::Local_Addr_VN<>
  extends PSC::Analysis::Addr_VN is
   //  Address of a variable in the Local_Area
   const Level : Code_Nesting_Level
   const BB_Id : CFG::Node_Id  //  Zero for up-level reference
   const Offset : Reflection::Offset_Within_Area

   func Hash(Local_Addr_VN) -> Univ_Integer is (Local_Addr_VN.Offset)

   op "=?"(Left, Right : Local_Addr_VN) -> Ordering
     is (Left.Level != Right.Level? Left.Level =? Right.Level:
         Left.BB_Id != Right.BB_Id?  Left.BB_Id =? Right.BB_Id:
         Left.Offset =? Right.Offset)

   func To_String(A : Local_Addr_VN) -> Univ_String
     is ("(Local, L" | A.Level | ",BB" | A.BB_Id | "," | A.Offset | ")")
end interface PSC::Analysis::Local_Addr_VN

interface PSC::Analysis::Param_Addr_VN<>
  extends PSC::Analysis::Addr_VN is
   //  Address of a variable in the Param_Area
   const Level : Code_Nesting_Level
   const BB_Id : CFG::Node_Id  //  Zero for up-level reference
   const Offset : Reflection::Offset_Within_Area

   func Hash(Param_Addr_VN) -> Univ_Integer is (Param_Addr_VN.Offset)

   op "=?"(Left, Right : Param_Addr_VN) -> Ordering
     is (Left.Level != Right.Level? Left.Level =? Right.Level:
         Left.BB_Id != Right.BB_Id?  Left.BB_Id =? Right.BB_Id:
         Left.Offset =? Right.Offset)

   func To_String(A : Param_Addr_VN) -> Univ_String
     is ("(Param, L" | A.Level | ",BB" | A.BB_Id | "," | A.Offset | ")")
end interface PSC::Analysis::Param_Addr_VN

interface PSC::Analysis::Type_Addr_VN<>
  extends PSC::Analysis::Addr_VN is
   //  Address of a variable in the Type_Area
   const Uplevel : Code_Nesting_Level
   const Offset : Reflection::Offset_Within_Area

   func Hash(Type_Addr_VN) -> Univ_Integer is (Type_Addr_VN.Offset)

   op "=?"(Left, Right : Type_Addr_VN) -> Ordering
     is (Left.Uplevel != Right.Uplevel? Left.Uplevel =? Right.Uplevel:
         Left.Offset =? Right.Offset)

   func To_String(A : Type_Addr_VN) -> Univ_String
     is ("(Type_Area, L" | A.Uplevel | "," | A.Offset | ")")
end interface PSC::Analysis::Type_Addr_VN

interface PSC::Analysis::Const_Area_VN<>
  extends PSC::Analysis::Addr_VN is
   //  Address of a variable in the Const_Area
   const Offset : Reflection::Offset_Within_Area

   func Hash(Const_Area_VN) -> Univ_Integer is (Const_Area_VN.Offset)

   op "=?"(Left, Right : Const_Area_VN) -> Ordering
     is (Left.Offset =? Right.Offset)

   func To_String(A : Const_Area_VN) -> Univ_String
     is ("(Const_Area, " | A.Offset | ")")
end interface PSC::Analysis::Const_Area_VN

interface PSC::Analysis::Component_Addr_VN<>
  extends PSC::Analysis::Addr_VN is
   //  Address of component of a large object
   const Base_Obj : OID  //  Origin ID for base object
   const Selector : Component_Selector_VN::Component_Selector_VN_Id

   func Hash(Component_Addr_VN) -> Univ_Integer
     is ([[Component_Addr_VN.Base_Obj]] + [[Component_Addr_VN.Selector]])

   op "=?"(Left, Right : Component_Addr_VN) -> Ordering
     is (Left.Base_Obj != Right.Base_Obj?
           Left.Base_Obj =? Right.Base_Obj :
           Left.Selector =? Right.Selector)

   func Child_Vec(A : Component_Addr_VN) -> Vector<VN_Id> 
     is ([A.Selector])

   func To_String(A : Component_Addr_VN) -> Univ_String
     is ("(Component_Addr, Base => OID" | A.Base_Obj |
         ", Selector => VN" | A.Selector | ")")
end interface PSC::Analysis::Component_Addr_VN

//  Begin Compound Value Numbers (VNs that contain one or more other VNs)

interface PSC::Analysis::Call_VN<> extends PSC::Analysis::Value_Number is
   const Routine_Id : VN_Id;
   const Operands   : Vector<VN_Id>;

   //  Use the hashes of all the operands
   //  Multiply by index so that order matters
   func Hash(C : Call_VN) -> Univ_Integer is
      ([[C.Routine_Id]] +
        (for each [I => Val_Num] of C.Operands => <0> + I * [[Val_Num]]));

   op "=?"(Left, Right : Call_VN) -> Ordering is
      (Left.Routine_Id != Right.Routine_Id?
         Left.Routine_Id =? Right.Routine_Id :
         Compare_VN_Vectors(Left.Operands, Right.Operands));

   func Compute_Value_Set
     (Call : Call_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   func Child_Vec(C : Call_VN) -> Vector<VN_Id> 
     is ([C.Routine_Id] | C.Operands)

   func To_String(C : Call_VN) -> Univ_String
     is ("(Call VN" | C.Routine_Id |
          (for each Opnd of C.Operands forward => <""> | ", VN" | Opnd) | ")")
end interface PSC::Analysis::Call_VN;

class PSC::Analysis::Call_VN is
  exports
   func Compute_Value_Set
     (Call : Call_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      //  For Call_VNs, we only worry about calls on builtins.
      const Opnds_Have_Vals :=
        (for all Opnd of Call.Operands => Opnd in VN_Values)
      const Routine_Id := VNT.Int_Literal_Value(Call.Routine_Id)
      if Opnds_Have_Vals and then Routine_Id not null then
         //  All operands have value sets, and the routine-id is not null,
         //  so we can perhaps come up with a value set for the call.
         const Routine :=
           Reflection::Routine::Routine_At_Index(Routine_Id)
         const Desig := Routine.Built_In_Desig()
         if Desig not null then
            //  We have a call on a built-in
            case Desig of
             ["#identity" | "#integer_from_univ" | "#integer_to_univ"] =>
               // Identity operations
               return VN_Values[Call.Operands[1]]

             ["\"=?\""] =>
               // TBD: if neither side is a literal, convert to subtraction
               //      compared against zero
               return null // TBD
             ["\"-\""] =>
               // TBD: do compile-time calculation
               return null // TBD
             ["\"+\""] =>
               // TBD: do compile-time calculation;
               //      re-order for canonicalization
               return null // TBD
             [..] =>
               return null
            end case
         end if
      end if
      return null
   end func Compute_Value_Set
end class PSC::Analysis::Call_VN

interface PSC::Analysis::Input_VN<> extends PSC::Analysis::Value_Number is
   //  Represents the initial value of an input to the operation.
   const Input_Addr : Addr_VN::Addr_VN_Id;

   func Hash(I : Input_VN) -> Univ_Integer is ([[I.Input_Addr]]);

   op "=?"(Left, Right : Input_VN) -> Ordering
     is (Left.Input_Addr =? Right.Input_Addr);

   func Child_Vec(I : Input_VN) -> Vector<VN_Id> 
     is ([I.Input_Addr])

   func To_String(I : Input_VN) -> Univ_String is
      ("(Input_VN, VN" | I.Input_Addr | ")");
end interface PSC::Analysis::Input_VN;

interface PSC::Analysis::Not_Null_VN<> extends PSC::Analysis::Value_Number is
   //  Represents the boolean test "Tested_Val not null"
   const Tested_Val : VN_Id;

   func Hash(N : Not_Null_VN) -> Univ_Integer is ([[N.Tested_Val]]);

   op "=?"(Left, Right : Not_Null_VN) -> Ordering
     is (Left.Tested_Val =? Right.Tested_Val)

   func Child_Vec(N : Not_Null_VN) -> Vector<VN_Id> 
     is ([N.Tested_Val])

   func Compute_Value_Set
     (NN : Not_Null_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   func Propagate_To_Operands
     (NN: Not_Null_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional VN_To_Value_Set_Map_Type
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.

   func To_String(N : Not_Null_VN) -> Univ_String
     is ("(Not_Null, VN" | N.Tested_Val | ")")
end interface PSC::Analysis::Not_Null_VN;

class PSC::Analysis::Not_Null_VN is
   //  Represents the boolean test "Tested_Val not null"
  exports
   func Compute_Value_Set
     (NN : Not_Null_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      if VNT.Is_Literal_VN(NN.Tested_Val) then
         //  A literal value is always of known nullness
         case VNT[NN.Tested_Val] of
          [N : Null_Literal_VN] =>
            //  Known to be null ==> Not_Null is #false
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True => #false,
                                       Might_Be_False => #true)
          [..] =>
            //  Known to be non-null ==> Not_Null is #true
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True => #true,
                                       Might_Be_False => #false)
         end case
      elsif NN.Tested_Val in VN_Values then
         //  Tested_Val has a value set; check its nullness
         ref Val_Set => VN_Values[NN.Tested_Val]
         case Val_Set of
          [B : Boolean_Value_Set] =>
            //  Tested value is itself a boolean.
            //  Not null is equivalent to being #true or #false
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True =>
                                         B.Might_Be_True or
                                           B.Might_Be_False,
                                       Might_Be_False =>
                                         B.Might_Be_Null)
          [..] =>
            //  Some other kind of value.  Look at "Might_Be_Null" 
            if not Val_Set.Might_Be_Null then
               //  Definitely not null
               return Boolean_Value_Set::(Might_Be_Null => #false,
                                          Might_Be_True => #true,
                                          Might_Be_False => #false)
            else
               //  See whether is known to be null, by checking whether
               //  setting Might_Be_Null to #false makes it empty.
               var Val_Set_Copy := Val_Set

               Val_Set_Copy.Might_Be_Null := #false
               //  If Val_Set_Copy is now Empty, then we know it is null.
               return Boolean_Value_Set::(Might_Be_Null => #false,
                                          Might_Be_True =>
                                            not Is_Empty(Val_Set_Copy),
                                          Might_Be_False => #true)
            end if
         end case
      end if
      return null
   end func Compute_Value_Set

   func Propagate_To_Operands
     (NN: Not_Null_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.
      case Val_Set of
       [B : Boolean_Value_Set] =>
         //  Adjust Might_Be_Null value of Tested_Val
         //  TBD: We can't do anything if Tested_Val doesn't already
         //       have a value set, since we don't know what kind to
         //       create.  Might eventually create a trivial kind of
         //       value set which just keeps track of nullness, but that
         //       doesn't seem necessary, because the value set of the
         //       Not_Null_VN captures that information.
         if NN.Tested_Val in VN_Values then
            var New_Tested_Val_Set := VN_Values[NN.Tested_Val]
            if B.Might_Be_True and not B.Might_Be_False then
               //  Not-Null returns #true => cannot be null
               New_Tested_Val_Set.Might_Be_Null := #false
            elsif B.Might_Be_False and not B.Might_Be_True then
               //  Not-Null returns #false => can only be null
               Set_Is_Null(New_Tested_Val_Set)
            end if

            if Is_Empty(New_Tested_Val_Set) then
               return null  //  Caller will report failure
            end if

            //  Return map of Tested_Val to its new value set
            return [NN.Tested_Val => New_Tested_Val_Set]
         end if
       [..] => null
      end case
      return []
   end func Propagate_To_Operands

end class PSC::Analysis::Not_Null_VN

interface PSC::Analysis::Logical_Not_VN<> extends PSC::Analysis::Value_Number
   //  Represents the boolean operation "not Tested_Val"
  is
   const Tested_Val : VN_Id;

   func Hash(N : Logical_Not_VN) -> Univ_Integer is ([[N.Tested_Val]]);

   op "=?"(Left, Right : Logical_Not_VN) -> Ordering
     is (Left.Tested_Val =? Right.Tested_Val)

   func Child_Vec(N : Logical_Not_VN) -> Vector<VN_Id> 
     is ([N.Tested_Val])

   func Compute_Value_Set
     (N : Logical_Not_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   func Propagate_To_Operands
     (N: Logical_Not_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.

   func To_String(N : Logical_Not_VN) -> Univ_String
     is ("(Logical_Not, VN" | N.Tested_Val | ")")
end interface PSC::Analysis::Logical_Not_VN;

class PSC::Analysis::Logical_Not_VN is
   //  Represents the boolean operation "not Tested_Val"
  exports
   func Compute_Value_Set
     (N : Logical_Not_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      if N.Tested_Val in VN_Values then
         ref Val_Set => VN_Values[N.Tested_Val]
         case Val_Set of
          [B : Boolean_Value_Set] =>
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True =>
                                         B.Might_Be_False,
                                       Might_Be_False =>
                                         B.Might_Be_True)
          [C : Countable_Value_Set] =>
            //  Convert countable to boolean and invert
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True =>
                                         0 in C.Possible_Values,
                                       Might_Be_False =>
                                         1 in C.Possible_Values)
          [..] =>
            //  Not boolean/countable, what could it be?
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True => #true,
                                       Might_Be_False => #true)
         end case
      end if
      return null
   end func Compute_Value_Set

   func Propagate_To_Operands
     (N: Logical_Not_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.
      case Val_Set of
       [B : Boolean_Value_Set] =>
         //  Invert value set of Val_Num and "and" into Tested_Val
         var New_Tested_Val_Set : Value_Set+ for Result :=
           Boolean_Value_Set::(Might_Be_Null => #false,
                               Might_Be_True => B.Might_Be_False,
                               Might_Be_False => B.Might_Be_True)

         if N.Tested_Val in VN_Values then
            New_Tested_Val_Set and= VN_Values[N.Tested_Val]
            if Is_Empty(New_Tested_Val_Set) then
               //  Empty set implies the check will fail
               return null  //  Caller will report check failure
            end if
         end if

         //  Return map of Tested_Val to its new value set
         return [N.Tested_Val => New_Tested_Val_Set]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands

end class PSC::Analysis::Logical_Not_VN

interface PSC::Analysis::Logical_And_VN<> extends PSC::Analysis::Value_Number
   //  Represents the boolean operation "Left and Right"
  is
   const Left : VN_Id;
   const Right : VN_Id;

   func Hash(N : Logical_And_VN) -> Univ_Integer is ([[N.Left]] + [[N.Right]]);

   op "=?"(Left, Right : Logical_And_VN) -> Ordering
     is (Left.Left != Right.Left?
         Left.Left =? Right.Left : Left.Right =? Right.Right)

   func Child_Vec(N : Logical_And_VN) -> Vector<VN_Id> 
     is ([N.Left, N.Right])

   func Compute_Value_Set
     (And : Logical_And_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   func Propagate_To_Operands
     (And: Logical_And_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type
     //  Do a top-down propagation to operands of value number.

   func To_String(N : Logical_And_VN) -> Univ_String
     is ("(Logical_And, VN" | N.Left | ",VN" | N.Right | ")")
end interface PSC::Analysis::Logical_And_VN;

class PSC::Analysis::Logical_And_VN is
   //  Represents the boolean operation "Left and Right"
  exports
   func Compute_Value_Set
     (And : Logical_And_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      if And.Left in VN_Values and then And.Right in VN_Values then
         case VN_Values[And.Left] of
          [Left : Boolean_Value_Set] =>
            case VN_Values[And.Right] of
             [Right : Boolean_Value_Set] =>
               // Combine boolean value sets
               return Boolean_Value_Set::
                        (Might_Be_Null => #false,
                         Might_Be_True =>
                           Left.Might_Be_True and Right.Might_Be_True,
                         Might_Be_False =>
                           Left.Might_Be_False or Right.Might_Be_False)
               
             [..] => null
            end case
          [..] => null
         end case

         //  Result cannot be null
         return Boolean_Value_Set::(Might_Be_Null => #false,
                                    Might_Be_True => #true,
                                    Might_Be_False => #true)
      end if
      return null
   end func Compute_Value_Set

   func Propagate_To_Operands
     (And: Logical_And_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.

      case Val_Set of
       [B : Boolean_Value_Set] =>
         var Left_Bools := VN_Values.Boolean_Vals(And.Left)
         var Right_Bools := VN_Values.Boolean_Vals(And.Right)
         //  Neither operand can be null
         Left_Bools.Might_Be_Null := #false
         Right_Bools.Might_Be_Null := #false
         if not B.Might_Be_False then
            //  If result cannot be false, then neither operand can be
            Left_Bools.Might_Be_False := #false
            Right_Bools.Might_Be_False := #false
         end if
         if Is_Empty(Left_Bools) or else Is_Empty(Right_Bools) then
            //  Failure
            return null
         end if
         //  Return mapping from opernads to their new value sets
         return [And.Left => Left_Bools, And.Right => Right_Bools]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands
end class PSC::Analysis::Logical_And_VN

interface PSC::Analysis::Logical_Or_VN<> extends PSC::Analysis::Value_Number
   //  Represents the boolean operation "Left or Right"
  is
   const Left : VN_Id;
   const Right : VN_Id;

   func Hash(N : Logical_Or_VN) -> Univ_Integer is ([[N.Left]] + [[N.Right]]);

   op "=?"(Left, Right : Logical_Or_VN) -> Ordering
     is (Left.Left != Right.Left?
         Left.Left =? Right.Left : Left.Right =? Right.Right)

   func Propagate_To_Operands
     (Or: Logical_Or_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type
     //  Do a top-down propagation to operands of value number.

   func Compute_Value_Set
     (Or : Logical_Or_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   func Child_Vec(N : Logical_Or_VN) -> Vector<VN_Id> 
     is ([N.Left, N.Right])

   func To_String(N : Logical_Or_VN) -> Univ_String
     is ("(Logical_Or, VN" | N.Left | ",VN" | N.Right | ")")
end interface PSC::Analysis::Logical_Or_VN

class PSC::Analysis::Logical_Or_VN is
   //  Represents the boolean operation "Left or Right"
  exports
   func Compute_Value_Set
     (Or : Logical_Or_VN; VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      if Or.Left in VN_Values and then Or.Right in VN_Values then
         case VN_Values[Or.Left] of
          [Left : Boolean_Value_Set] =>
            case VN_Values[Or.Right] of
             [Right : Boolean_Value_Set] =>
               // Combine boolean value sets
               return Boolean_Value_Set::
                        (Might_Be_Null => #false,
                         Might_Be_True =>
                           Left.Might_Be_True or Right.Might_Be_True,
                         Might_Be_False =>
                           Left.Might_Be_False and Right.Might_Be_False)
               
             [..] => null
            end case
          [..] => null
         end case

         //  Result cannot be null
         return Boolean_Value_Set::(Might_Be_Null => #false,
                                    Might_Be_True => #true,
                                    Might_Be_False => #true)
      end if
      return null
   end func Compute_Value_Set

   func Propagate_To_Operands
     (Or: Logical_Or_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.

      case Val_Set of
       [B : Boolean_Value_Set] =>
         var Left_Bools := VN_Values.Boolean_Vals(Or.Left)
         var Right_Bools := VN_Values.Boolean_Vals(Or.Right)
         //  Neither operand can be null
         Left_Bools.Might_Be_Null := #false
         Right_Bools.Might_Be_Null := #false
         if not B.Might_Be_True then
            //  If result cannot be true, then neither operand can be
            Left_Bools.Might_Be_True := #false
            Right_Bools.Might_Be_True := #false
         end if
         if Is_Empty(Left_Bools) or else Is_Empty(Right_Bools) then
            //  Failure
            return null
         end if
         //  Return mapping from opernads to their new value sets
         return [Or.Left => Left_Bools, Or.Right => Right_Bools]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands
end class PSC::Analysis::Logical_Or_VN

interface PSC::Analysis::Condition_Mask_VN<>
  extends PSC::Analysis::Value_Number is
   //  Represents the boolean test "Tested_Val satisfies Mask"
   const Tested_Val : VN_Id;
   const Mask : Reflection::Instruction::Condition_Bit_Mask;

   func Hash(N : Condition_Mask_VN) -> Univ_Integer
     is ([[N.Tested_Val]] + N.Mask.To_Rep());

   op "=?"(Left, Right : Condition_Mask_VN) -> Ordering
     is (Left.Tested_Val != Right.Tested_Val?
           Left.Tested_Val =? Right.Tested_Val : Left.Mask =? Right.Mask)

   func Compute_Value_Set
     (C_Mask_VN : Condition_Mask_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> optional Value_Set+
     //  Do a bottom-up computation of the value set of the given VN

   func Child_Vec(N : Condition_Mask_VN) -> Vector<VN_Id> 
     is ([N.Tested_Val])

   func To_String(N : Condition_Mask_VN) -> Univ_String
     is ("(Condition_Mask, VN" | N.Tested_Val | "," | N.Mask | ")")
end interface PSC::Analysis::Condition_Mask_VN;

class PSC::Analysis::Condition_Mask_VN is
   //  Represents the boolean test "Tested_Val satisfies Mask"
  exports
   func Compute_Value_Set
     (C_Mask_VN : Condition_Mask_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      if C_Mask_VN.Tested_Val in VN_Values then
         //  Subrange of ordering known, so possible
         //  bool values are computable.
         const Ordering_Vals := VN_Values[C_Mask_VN.Tested_Val]
         const Ordering_Mask := To_Rep(C_Mask_VN.Mask)
         case Ordering_Vals of
          [C_Vals : Countable_Value_Set] =>
            //  Checking if ordering mask has proper bit on
            const Might_Be_True :=
              (for some Val in C_Vals.Possible_Values =>
                 (Ordering_Mask >> Val) mod 2 != 0)
            const Must_Be_True := Might_Be_True and then
              (for all Val in C_Vals.Possible_Values =>
                 (Ordering_Mask >> Val) mod 2 != 0)
            return Boolean_Value_Set::
              (Might_Be_Null => #false,
               Might_Be_True => Might_Be_True,
               Might_Be_False => not Must_Be_True)
          [B_Vals : Boolean_Value_Set] =>
             if C_Mask_VN.Mask == #compare_equal then
                return Ordering_Vals
             else
                return Boolean_Value_Set::
                          (Might_Be_Null => B_Vals.Might_Be_Null,
                           Might_Be_True => B_Vals.Might_Be_False,
                           Might_Be_False => B_Vals.Might_Be_True)
             end if
          [..] =>
            return null
         end case
      end if
      return null
   end func Compute_Value_Set

end class PSC::Analysis::Condition_Mask_VN

interface PSC::Analysis::Cond_VN<> extends PSC::Analysis::Value_Number is
   //  Represents the conditional expression "Cond? Then : Else"
   const Cond : VN_Id;
   const Then : VN_Id;
   const Else : VN_Id;

   func Hash(C : Cond_VN) -> Univ_Integer is
      ([[C.Cond]] + 2 * [[C.Then]] + 3 * [[C.Else]]);

   op "=?"(Left, Right : Cond_VN) -> Ordering;

   func Child_Vec(C : Cond_VN) -> Vector<VN_Id> 
     is ([C.Cond, C.Then, C.Else])

   func To_String(C : Cond_VN) -> Univ_String
     is ("(Cond, VN" | C.Cond | "? VN" | C.Then | ": VN" | C.Else | ")")
end interface PSC::Analysis::Cond_VN;

class PSC::Analysis::Cond_VN is
   //  Represents the conditional expression "Cond? Then : Else"
  exports
   op "=?"(Left, Right : Cond_VN) -> Ordering is
      const Left_VNs : Vector<VN_Id> := [Left.Cond, Left.Then, Left.Else];
      const Right_VNs : Vector<VN_Id> := [Right.Cond, Right.Then, Right.Else];
      return Compare_VN_Vectors(Left_VNs, Right_VNs);
   end op "=?";
end class PSC::Analysis::Cond_VN;

interface PSC::Analysis::Phi_VN<> extends PSC::Analysis::Value_Number is
   //  Represents a "phi" node in block Phi_Block, for object at addr Phi_Addr
   //  TBD: Should this be based on an object-id instead?
   //  Answer: No, because might have different objects on different paths.
   //  But: Should we create a Phi_Obj_Id in that case, and associate the
   //       Phi_VN with that?
   const Phi_Block : CFG::Node_Id;    // Basic block where phi created
   const Phi_Addr : Addr_VN::Addr_VN_Id;  // Address associated with phi
   var Preds : Vector<optional VN_Id>;    // Values from incoming edges
                                 // NOTE: These are filled in later
                                 // TBD: These should be moved into a separate
                                 //      mapping, since set elements are R/O

   //  Use the hashes of Phi_Block and Phi_Addr.
   func Hash(P : Phi_VN) -> Univ_Integer is
      ([[P.Phi_Block]] + 2 * [[P.Phi_Addr]]);

   op "=?"(Left, Right : Phi_VN) -> Ordering is
      (Left.Phi_Block != Right.Phi_Block? Left.Phi_Block =? Right.Phi_Block:
        Left.Phi_Addr =? Right.Phi_Addr)

   func Child_Vec(P : Phi_VN) -> Vector<VN_Id> 
     is ([P.Phi_Addr])

   func To_String(P : Phi_VN) -> Univ_String
     is ("(Phi, BB" | P.Phi_Block | ", Addr_VN" | P.Phi_Addr |
         (for each Pred of P.Preds forward => <""> | ", VN" | Pred) | ")")
end interface PSC::Analysis::Phi_VN;

interface PSC::Analysis::Aggregate_VN<> extends PSC::Analysis::Value_Number is
   //  Represents a composite object, formed from an initial computation
   //  followed by a set of component assignments.

   const Base_Val   : optional VN_Id;  //  Value before component assignments
   const Kind_Of_Selectors : Component_Selector_VN::Selector_Kind
   const Components : VN_To_VN_Map_Type;
      //  This is a mapping from component offsets/selectors to their values.
      //  The keys are literal offsets, or a combination of indexing op id
      //  and indexing operands.
      //  All keys of Components map in Component_Selector_VN+
      //    with Kind() == Kind_Of_Selectors
      //  This map has at most one element if Kind_Of_Selectors in
      //    [#dynamic_indexing, #referenced_part]

   //  Use the hashes of all the components
   //  Multiply by selector so that selector matters
   func Hash(A : Aggregate_VN) -> Univ_Integer is
      ((for each [Sel => Val] of A.Components => <0> +
         [[Sel]] * [[Val]]));

   op "=?"(Left, Right : Aggregate_VN) -> Ordering is
      ((Left.Base_Val is null) != (Right.Base_Val is null)? #unordered:
       Left.Base_Val not null and then Left.Base_Val != Right.Base_Val?
        Left.Base_Val =? Right.Base_Val:
       |Left.Components| != |Right.Components|?
        |Left.Components| =? |Right.Components|:
       (for all [Sel => Val] of Left.Components =>
          Sel in Right.Components and then Right.Components[Sel] == Val)?
        #equal : #unordered)

   func Child_Vec(A : Aggregate_VN) -> Vector<VN_Id> 
     is ((A.Base_Val not null? [A.Base_Val] : [])|
            [for each C of A.Components forward => C])

   func To_String(A : Aggregate_VN) -> Univ_String
     is ("(Aggregate, " | (A.Base_Val is null? "[]": "VN" | A.Base_Val) |
          (for each [Sel => Val] of A.Components forward => <""> |
            ", VN" | Sel | "=>VN" | Val) | ")")
end interface PSC::Analysis::Aggregate_VN;

interface PSC::Analysis::Component_Value_VN<>
  extends PSC::Analysis::Value_Number is
   //  Represents the value of a component of a composite value
   const Base_Val : VN_Id;
   const Selector : Component_Selector_VN::Component_Selector_VN_Id

   func Hash(C : Component_Value_VN) -> Univ_Integer is
      ([[C.Base_Val]] + 2 * [[C.Selector]]);

   op "=?"(Left, Right : Component_Value_VN) -> Ordering is
      (Left.Base_Val != Right.Base_Val? Left.Base_Val =? Right.Base_Val:
         Left.Selector =? Right.Selector)

   func Child_Vec(C : Component_Value_VN) -> Vector<VN_Id> 
     is (C.Base_Val not null? [C.Base_Val, C.Selector] : [C.Selector])

   func To_String(C : Component_Value_VN) -> Univ_String
     is ("(Component_Val, Base => VN" | C.Base_Val |
         ", Selector => VN" | C.Selector | ")")
end interface PSC::Analysis::Component_Value_VN;

interface PSC::Analysis::Unknown_VN<> extends PSC::Analysis::Value_Number is
   //  Just a wrapper around one value
   const Unknown : VN_Id;

   func Hash(U : Unknown_VN) -> Univ_Integer is ([[U.Unknown]]);

   op "=?"(Left, Right : Unknown_VN) -> Ordering is
      (Left.Unknown =? Right.Unknown);

   func Child_Vec(U : Unknown_VN) -> Vector<VN_Id> 
     is ([U.Unknown])

   func To_String(U : Unknown_VN) -> Univ_String is
      ("(Unknown_VN, VN" | U.Unknown | ")");
end interface PSC::Analysis::Unknown_VN;

abstract interface PSC::Analysis::Origin_Info<> is
  // Origin_Info identifies where an object comes from,
  // and is used to identify a potentially updatable object
  // Value numbering maintains two mappings:
  //   Address => Origin
  //   Origin => Value
   func Hash(Origin_Info) -> Univ_Integer
   op "=?"(Left, Right : Origin_Info) -> Ordering
   func To_String(Origin_Info) -> Univ_String
   optional func From_String(Univ_String) -> optional Origin_Info
end interface PSC::Analysis::Origin_Info

interface PSC::Analysis::Code_Origin<>
  extends PSC::Analysis::Origin_Info is
  //  Object that originates from an instruction
   const Instr : Reflection::Routine::Code_Index
   const Which_Output : Output_Index
   func Hash(CO : Code_Origin) -> Univ_Integer
     is (Hash(CO.Instr) + Hash(CO.Which_Output))
   op "=?"(Left, Right : Code_Origin) -> Ordering
     is (Left.Instr == Right.Instr? Left.Which_Output =? Right.Which_Output:
         Left.Instr =? Right.Instr)
   func To_String(CO : Code_Origin) -> Univ_String
     is ("(Code_Origin: Instr#" | CO.Instr |
            ", Output#" | CO.Which_Output | ")")
end interface PSC::Analysis::Code_Origin

interface PSC::Analysis::Phi_Origin<>
  extends PSC::Analysis::Origin_Info is
  //  Object that originates as a phi-node of a join point in the CFG
   const Phi_Block : CFG::Node_Id
   const Phi_Addr : Addr_VN::Addr_VN_Id  // Address of "var"
   func Hash(PO : Phi_Origin) -> Univ_Integer
     is (Hash(PO.Phi_Block) + Hash(PO.Phi_Addr))
   op "=?"(Left, Right : Phi_Origin) -> Ordering
     is (Left.Phi_Block == Right.Phi_Block? Left.Phi_Addr =? Right.Phi_Addr:
         Left.Phi_Block =? Right.Phi_Block)
   func To_String(PO : Phi_Origin) -> Univ_String
     is ("(Phi_Origin: BB" | PO.Phi_Block | ", VN" | PO.Phi_Addr | ")")
end interface PSC::Analysis::Phi_Origin

interface PSC::Analysis::Input_Origin<>
  extends PSC::Analysis::Origin_Info is
  //  Object that comes from an input parameter, directly or indirectly
   const Input_Addr : Addr_VN::Addr_VN_Id  // Param_Addr_VN or Input_VN
   func Hash(IO : Input_Origin) -> Univ_Integer is (Hash(IO.Input_Addr))
   op "=?"(Left, Right : Input_Origin) -> Ordering
     is (Left.Input_Addr =? Right.Input_Addr)
   func To_String(IO : Input_Origin) -> Univ_String
     is ("(Input_Origin: VN" | IO.Input_Addr | ")")
end interface PSC::Analysis::Input_Origin

interface PSC::Analysis::Updated_Value<> is
  //  An updated value is used to represent a composite object's value
  //  after some number of assignments to its components
   const Base_Val      : VN_Id
   const Kind_Of_Selectors : Component_Selector_VN::Selector_Kind
   var Component_OIDs : VN_To_OID_Map_Type := []
      //  All keys of Component_OIDs map in Component_Selector_VN+
      //    with Kind() == Kind_Of_Selectors
      //  This map has at most one element if Kind_Of_Selectors in
      //    [#dynamic_indexing, #referenced_part]

   //  Imageable operations on Updated_Value
   op "=?"(Left, Right : Updated_Value) -> Ordering
   func Hash(Updated_Value) -> Univ_Integer
   func To_String(Updated_Value) -> Univ_String
   optional func From_String(Univ_String) -> optional Updated_Value is (null)

  //  TBD: Other Operations on Updated_Values
end interface PSC::Analysis::Updated_Value

class PSC::Analysis::Updated_Value is
  exports
   op "=?"(Left, Right : Updated_Value) -> Ordering is
      if Left.Base_Val != Right.Base_Val
        or else
         Left.Kind_Of_Selectors != Right.Kind_Of_Selectors
        or else
         |Left.Component_OIDs| != |Right.Component_OIDs|
      then
         //  Mismatch in basic info
         return #unordered
      else
         //  Same number of components, compare if equal.
         for each [C => O] of Left.Component_OIDs loop
            if C not in Right.Component_OIDs
              or else
               Right.Component_OIDs[C] != O
            then
               //  A component mismatch
               return #unordered
            end if
         end loop
         //  All components match
         return #equal
      end if
   end op "=?"

   func Hash(Updated_Value) -> Univ_Integer is
      return Hash(Updated_Value.Base_Val) +
        Hash(Updated_Value.Kind_Of_Selectors) +
        |Updated_Value.Component_OIDs|
   end func Hash

   func To_String(Updated_Value) -> Univ_String is
      //  Return a string representation
      return "Updated_Value::(Base => VN" | Updated_Value.Base_Val |
                           ", Kind_Of_Selectors => " |
                                            Updated_Value.Kind_Of_Selectors |
                           ", Component_OIDs => " |
             (for (each [C => O] of Updated_Value.Component_OIDs;
                  Sep := "[" then ", ") => <""> | Sep | "VN" | C |
                                                "=>OID" | O) | "])"
   end func To_String

end class PSC::Analysis::Updated_Value

func Test_VN() is
   var VNT : PSC::Analysis::VN_Table := []

   const VN1 : PSC::Analysis::Local_Addr_VN :=
     (Level => 0, BB_Id => 0, Offset => 3)
   const VN1_Id := VNT.Get_Unique_Id(VN1);
   Println("Val1:(Local_Area, 3) Id = " | VN1_Id)

   const VN2 : PSC::Analysis::Param_Addr_VN :=
     (Level => 0, BB_Id => 0, Offset => 2)
   const VN2_Id := VNT.Get_Unique_Id(VN2)
   Println("Val2:(Param_Area, 2) Id = " | VN2_Id)

   const VN3 : PSC::Analysis::Int_Literal_VN :=
      (Value => 42)
   const VN3_Id := VNT.Get_Unique_Id(VN3)
   Println("Val3:(Value => 42) Id = " | VN3_Id)

   const VN4_1 : PSC::Analysis::Indexed_Selector_VN :=
     (Indexing_Routine_Id => VN3_Id,
      Indexing_Operands => [VN2_Id],
      Is_Indexing_Op => #true,
      Is_Static_Indexing => #false)
   const VN4_1_Id := VNT.Get_Unique_Id(VN4_1)
   const OID_1 : OID := 31
   const VN4 : PSC::Analysis::Component_Addr_VN :=
     (Base_Obj => OID_1, Selector => VN4_1_Id)
   const VN4_Id := VNT.Get_Unique_Id(VN4)
   Println("Val4_1:(Indexed_Selector, call #42, Val2) Id = " | VN4_1_Id)
   Println("Val4:(Component_Addr, OID1, Val4_1) Id = " | VN4_Id)

   const VN5 : PSC::Analysis::Param_Addr_VN :=
     (Level => 0, BB_Id => 0, Offset => 2)
   const VN5_Id := VNT.Get_Unique_Id(VN5)
   Println("Val5:(Param_Area, 2) Id = " | VN5_Id)

   {VN5_Id == VN2_Id}

   const VN6_1 : PSC::Analysis::Named_Selector_VN := (Offset => 7)
   const OID_2 : OID := 42
   const VN6 : PSC::Analysis::Component_Addr_VN := (Base_Obj => OID_2,
     Selector => VNT.Get_Unique_Id(VN6_1))
   const VN6_Id := VNT.Get_Unique_Id(VN6)
   Println("Val6:(Component, OID" | OID_2 | ", 7) Id = " | VN6_Id)

   const VN7 : PSC::Analysis::String_Literal_VN :=
      (Value => "hi there")
   const VN7_Id := VNT.Get_Unique_Id(VN7)
   Println("Val7:(Value => \"hi there\") Id = " | VN7_Id)

   for each [Id => VN] of VNT forward loop
      Println ("Found VN" | Id | ':' | VN)
   end loop

   Println("About to call From_String");
   const FS_VN := PSC::Analysis::Param_Addr_VN::From_String("hi there")
   Println("From_String returned " | FS_VN)
end func Test_VN

class PSC::Analysis is
   type Code_Offset is Reflection::Routine::Code_Offset
   type Code_Index is Reflection::Routine::Code_Index

   type Node_Set is CFG::Node_Set
   
   type Pass_Enum is Enum<[#find_basic_blocks, #build_cfg, #value_number]>

   func Is_Equal(Left, Right : VN_To_Value_Set_Map_Type) -> Boolean is
      if |Left| != |Right| then
         return #false
      else
         return (for all [K => V] of Left =>
            K in Right and then V == Right[K])
      end if
   end func Is_Equal

   func Unwrapped_Type_Desc (Type_Desc : Reflection::Type_Descriptor)
     -> Reflection::Type_Descriptor is
     //  Return a non-wrapper type descriptor, following op maps and wrappers
      if Type_Desc is null then
         return Type_Desc
      elsif Has_Op_Map (Type_Desc) then
         return Unwrapped_Type_Desc (Actual_Type (Type_Desc))
      elsif Is_Wrapper (Type_Desc) then
         return Unwrapped_Type_Desc (Components (Type_Desc)[1].Type_Desc)
      else
         return Type_Desc
      end if
   end func Unwrapped_Type_Desc

   interface Op_Ctx<> is
     // Data maintained during the static analysis of one operation
      ref const Routine : Reflection::Routine
                                // Ref to associated Routine
      var Pass : Pass_Enum := #find_basic_blocks
                                // Current analysis "pass" for cur operation
      var CFG : PSC::CFG := []  // Control-flow graph for current operation

      var Node_Starts : Countable_Set<Code_Index> := []
                                // Instr indices where basic blocks start
      var Nested_Block_Starts : Countable_Set<Code_Index> := []
                                // Instr indices where nested blocks start
      var Last_End_Instr : optional Code_Index := null
                                // Last return/exit stmt in op/nested block
      var CFG_Ends : Countable_Set<Code_Index> := []
                                // Instr indices where op/nested-block ends
      var Instr_To_Node_Map : Map<Code_Index, CFG::Node_Id> := []
                                // CFG node that starts at given instr, if any
      var Cur_Node_Id : optional CFG::Node_Id := null
                                // Current CFG node, in #build_cfg pass
                                // and thereafter.
      var Cur_Entry_Node : optional CFG::Node_Id := null
                                // Node id for basic-block that starts
                                // current control-flow graph, where each
                                // nested block is treated as a separate CFG.
      var Cur_Exit_Node : optional CFG::Node_Id := null
                                // Node id for basic-block that ends
                                // current control-flow graph, where each
                                // nested block is treated as a separate CFG.
      var CFG_Entry_Nodes : Node_Set := []
                                //  Nodes where CFGs start
      var CFG_Exit_Nodes  : Node_Set := []
                                //  Nodes where CFGs end
      var Entry_Node_To_Exit_Node_Map :
        Two_Way_Map<CFG::Node_Id, CFG::Node_Id> := []
                                // For each entry node, corresponding exit node
                                // where all exit/return statements converge.
      var Invoked_Blocks : Countable_Set<Code_Index> := []
                                // Begin_Nested_Block instructions for nested
                                // blocks that have been invoked prior to a
                                // Wait_For_Parallel
      var VNT : VN_Table := []
                                // Set of value numbers for current operation

      var Null_VN : VN_Id := 0; // Initialized to value number for "null"

      var Boolean_VNs : VN_Set := []
                                // Set of VNs that are booleans

      var CTK_VNs : VN_Set := []
                                // Set of VNs that are compile-time known;
                                // i.e. literals or functions of literals.

      var OIT : OID_Table := []
                                // Set of origin infos for current operation

      var Addr_To_OID_Map : VN_To_OID_Map_Type := []
                                // Current BB's Address-to-OID mapping
      var OID_To_VN_Map : OID_To_VN_Map_Type := []
                                // Current BB's OID-to-VN mapping

      var OID_To_UV_Map : OID_To_UV_Map_Type := []
                                // Current BB's OID-to-Updated-Value mapping

      var Component_OID_Two_Way_Map : VN_OID_Two_Way_Map_Type := []
                                // Cur BB's Component-Addr <-> OID 2-way map

      var Node_To_AO_Map :
        Map<Key_Type => CFG::Node_Id, Value_Type => VN_To_OID_Map_Type> := []
                                // Map of all AO-maps, indexed by Node_Id

      var Node_To_OV_Map :
        Map<Key_Type => CFG::Node_Id, Value_Type => OID_To_VN_Map_Type> := []
                                // Map of all OV-maps, indexed by Node_Id

      var Node_To_OUV_Map :
        Map<Key_Type => CFG::Node_Id, Value_Type => OID_To_UV_Map_Type> := []
                                // Map of all OUV-maps, indexed by Node_Id

      var Instr_To_Assertions_Map : Ordered_Map<Key_Type => Code_Index,
                                        Value_Type => Vector<VN_Id>> := []
                                // Map from instruction to set of assertions
                                // that need to be proven.
      var Edge_Condition : Ordered_Map<Key_Type => CFG::Edge_Id,
                               Value_Type => VN_Id> := []
                                // Map from edge-id to condition that must
                                // be true to traverse the edge.
                                // Default condition is "#true".

      var Dead_Edges : Ordered_Set<CFG::Edge_Id> := []
                                // Set of edges that are determined to be dead

      var Edge_Values : 
        Array<VN_To_Value_Set_Map_Type, Indexed_By => CFG::Edge_Id> := []
                                // Map from VN to Value set for each edge

      var VN_To_Parent_Set_Map : Array<VN_Set, Indexed_By => VN_Id> := []
   end interface Op_Ctx

   type Object_Locator is Reflection::Object_Locator;

   const Zero_Base  := Object_Locator::Zero_Base;
   const Local_Area := Object_Locator::Local_Area;
   const Param_Area := Object_Locator::Param_Area;
   const Type_Area  := Object_Locator::Type_Area;
   const Const_Area := Object_Locator::Const_Area;
   const Enclosing_Param_Areas :=
      Object_Locator::Enclosing_Param_Areas;
   const Enclosing_Local_Areas :=
      Object_Locator::Enclosing_Local_Areas;
   const Enclosing_Type_Areas :=
      Object_Locator::Enclosing_Type_Areas;
   const Base_Registers := Object_Locator::Base_Registers;
   const Phys_Base_Registers :=
      Object_Locator::Phys_Base_Registers;

   func Dump_VNT (Op_Ctx; Max_VN : VN_Id) is
      //  Dump Value Number Table up to Max
      ref VNT => Op_Ctx.VNT

      if Max_VN not null then
         for V in 1 .. Max_VN forward loop
            if V in VNT then
               var Attribs := ""
               if V in Op_Ctx.Boolean_VNs then
                  if V in Op_Ctx.CTK_VNs then
                     Attribs := "[BC]"
                  else
                     Attribs := "[B]"
                  end if
               elsif V in Op_Ctx.CTK_VNs then
                  Attribs := "[C]"
               end if
                  
               case VNT[V] of
                  [Call : Call_VN] =>
                     //  Try to print out name of routine being called
                     Print("  VN" | V | Attribs | ":" | Call)
                     const Routine_Id :=
                       Int_Literal_Value (VNT, Call.Routine_Id)
                     if Routine_Id not null then
                        const Routine :=
                          Reflection::Routine::Routine_At_Index(Routine_Id)
                        if Routine not null then
                           Print(" = " | Routine.Name())
                           const Desig := Routine.Built_In_Desig();
                           if Desig not null then
                              if Desig[1] != '#' then
                                 Print(" (#" | Desig | ")")
                              else
                                 Print(" (" | Desig | ")")
                              end if
                           end if
                        end if
                     end if
                     Print('\n')
                  [..] =>
                     Println("  VN" | V | Attribs | ":" | VNT[V])
               end case
            end if
         end loop
      end if
   end func Dump_VNT

   func Dump_OIT (Op_Ctx; Max_OID : OID) is
      //  Dump OID Table up to Max
      ref OIT => Op_Ctx.OIT

      if Max_OID not null then
         for O in 1 .. Max_OID forward loop
            if O in OIT then
               Println("  OID" | O | ":" | OIT[O])
            end if
         end loop
      end if
   end func Dump_OIT

   func Dump_UVT (Op_Ctx; var Max_OID_Seen : optional OID) is
      //  Dump Updated-Value Table
      ref UVT => Op_Ctx.OID_To_UV_Map

      for each [O => UV] of UVT loop
         Println("  OID" | O | " => " | UV)
         Max_OID_Seen := Max(Max_OID_Seen, O)
      end loop
   end func Dump_UVT

   func Dump_Addr_OID_Value_Maps(Op_Ctx) is
      //  Dump mapping of addresses to OIDs to value numbers,
      //  and the definition of each value number.
      ref A2O => Op_Ctx.Addr_To_OID_Map
      ref O2V => Op_Ctx.OID_To_VN_Map
      ref O2UV => Op_Ctx.OID_To_UV_Map
      ref VNT => Op_Ctx.VNT

      var Max_VN_Seen : optional VN_Id := null
      var Max_OID_Seen : optional OID := null
      Println ("Addr to Value Map:")
      for each [A => O] of A2O forward loop
         Println(" [VN" | A | " => OID" | O | "]")
         Max_VN_Seen := Max(Max_VN_Seen, A)
         Max_OID_Seen := Max(Max_OID_Seen, O)
      end loop
      for each [O => V] of O2V forward loop
         Println(" [OID" | O | " => VN" | V | "]")
         if Op_Ctx.Has_Updated_Value(O) then
            Println("    => UV ");
         end if;
         Max_VN_Seen := Max(Max_VN_Seen, V)
      end loop
      Dump_UVT (Op_Ctx, Max_OID_Seen);
      Dump_VNT (Op_Ctx, Max_VN_Seen)
      Dump_OIT (Op_Ctx, Max_OID_Seen)
   end func Dump_Addr_OID_Value_Maps

   func Component_Selector_Kind(Op_Ctx; Selector : VN_Id)
     -> optional Component_Selector_VN::Selector_Kind is
     //  Return #named, #static_index, #dynamic_index, #referenced_part,
     //  or null, depending on kind of Selector.
      case Op_Ctx.VNT[Selector] of
         [Named : Named_Selector_VN] =>
            return #named
         [Indexed : Indexed_Selector_VN] =>
            if not Indexed.Is_Indexing_Op then
               return #referenced_part
            elsif Indexed.Is_Static_Indexing then
               return #static_index
            else
               return #dynamic_index
            end if
         [..] =>
            return null
      end case
   end func Component_Selector_Kind

   func Might_Overlap(var Op_Ctx;
     New_Selector : VN_Id; Existing_Components : VN_To_VN_Map_Type)
     -> Boolean is
     //  Return #true if there is a possibility that the component identified
     //  by New_Selector might overlap with one of the components currently
     //  identified by the selectors in the Existing_Components map
      for each [Sel => Val] of Existing_Components loop
         case Op_Ctx.VNT[New_Selector] of
            [Named : Named_Selector_VN] =>
               case Op_Ctx.VNT[Sel] of
                  [Existing_Named : Named_Selector_VN] =>
                     if Sel == New_Selector then
                        //  A definite overlap
                        return #true
                     end if

                     //  These don't match, keep checking for an overlap ...
                  [Existing_Indexed : Indexed_Selector_VN] =>
                     //  Named and indexed always conflict
                     return #true
                  [..] => {#false}
               end case
            [Indexed : Indexed_Selector_VN] =>
               case Op_Ctx.VNT[Sel] of
                  [Existing_Named : Named_Selector_VN] =>
                     //  Named and indexed always conflict
                     return #true
                  [Existing_Indexed : Indexed_Selector_VN] =>
                     //  Two indexed, these might overlap unless
                     //  everything is static and different
                     //  and this is an "indexing" operation.
                     if not Indexed.Is_Indexing_Op 
                       or else not Existing_Indexed.Is_Indexing_Op
                       or else not Indexed.Is_Static_Indexing
                       or else not Existing_Indexed.Is_Static_Indexing
                       or else
                         Indexed.Indexing_Routine_Id !=
                           Existing_Indexed.Indexing_Routine_Id
                       or else
                         |Indexed.Indexing_Operands| !=
                           |Existing_Indexed.Indexing_Operands|
                     then
                        //  Not all static and for same indexing dimension
                        return #true
                     else
                        //  All indexing operands are literals.
                        //  They overlap only if all operands match.
                        if (for all I in 1 .. |Indexed.Indexing_Operands|
                             => Indexed.Indexing_Operands[I] ==
                                  Existing_Indexed.Indexing_Operands[I]) then
                           //  All match, so we have an overlap
                           return #true
                        end if

                        //  These are for different indices; keep checking ...
                     end if
                  [..] => {#false}
               end case
            [..] => {#false}  //  Should not occur
         end case
      end loop
      //  Doesn't overlap with anything
      return #false
   end func Might_Overlap

   func Entry_Node_For_BB(Op_Ctx; BB : CFG::Node_Id;
     Uplevel : Code_Nesting_Level := 0) -> CFG::Node_Id is
     // Return id of entry block for enclosing nested block/operation
     // given current basic block, and uplevel count, if any, from
     // Enclosing_Local_Area or Enclosing_Param_Area locator.
     // Return 0 for entry node if this is an up-level reference to an
     // enclosing operation.
      ref DT => Op_Ctx.CFG.Get_Dominator_Tree()
      var Remaining_Uplevel_Count := Uplevel

      for Dom := BB
        while Dom not null
      loop
         if Dom in Op_Ctx.CFG_Entry_Nodes then
            if Remaining_Uplevel_Count > 0 then
               //  Haven't reached desired entry block yet
               Remaining_Uplevel_Count -= 1
            else
               return Dom
            end if
         end if
         //  Check for case of nested block that dominates successor
         //  and skip over nested block.
         const Next_Dom := Immediate_Dominator(DT, Dom)
         if Next_Dom not null
           and then Next_Dom in Op_Ctx.CFG_Exit_Nodes
         then
            //  Skip to matching entry node
            const Entry_Node :=
              Key_Of(Op_Ctx.Entry_Node_To_Exit_Node_Map, Next_Dom)
            continue loop with Dom =>
              Immediate_Dominator(DT, Entry_Node)
         else
            //  Continue loop with immediate dominator
            continue loop with Dom => Next_Dom
         end if
      end loop
      {Remaining_Uplevel_Count > 0}
      return 0  //  Indicates a "true" up-level reference
   end func Entry_Node_For_BB

   func Level_Of_BB(Op_Ctx; BB : CFG::Node_Id;
     Uplevel : Code_Nesting_Level := 0) -> Code_Nesting_Level is
     // Return nesting level of enclosing nested block/operation
     // given current basic block, and uplevel, if any, from
     // Enclosing_Local_Area or Enclosing_Param_Area locator.
      const Entry_BB := Entry_Node_For_BB(Op_Ctx, BB, Uplevel)

      if Entry_BB == 0 then
         //  This is an up-level reference to an enclosing operation;
         //  just subtract the Uplevel from the current block's level
         //  (determined by calling Level_Of_BB recursively).
         {Uplevel > 0} // Must be non-zero to avoid infinite recursion
         return Level_Of_BB(Op_Ctx, BB, Uplevel => 0) - Uplevel

      elsif Entry_BB == Op_Ctx.CFG.Get_Dominator_Tree().Root() then
         //  Not in a nested block; return routine's nesting level
         return Op_Ctx.Routine.Nesting_Level()

      else
         //  The entry node for a nested block
         return Op_Ctx.Routine.Nth_Instr(Op_Ctx.CFG[Entry_BB].First).
           Nested_Code_Block().Nesting_Level
      end if
   end func Level_Of_BB

   func Fetch_OID_Value(var Op_Ctx; Source_OID : OID;
      Source_Pos : Reflection::Source_Position) -> VN_Id
     // Fetch VN at given OID

   func Fetch_Value(var Op_Ctx; Source_Addr : Addr_VN::Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) -> VN_Id
     // Fetch VN at given address

   func Fetch_OID_Base_Value(var Op_Ctx; Source_OID : OID;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) -> VN_Id is
     // Fetch VN at given OID only to determine whether it is null.
     // If addr has Updated_Value, fetch underlying value of Updated value.

      return Fetch_OID_Value (Op_Ctx, Source_OID, Source_Pos)  //  TBD
   end func Fetch_OID_Base_Value

   func Fetch_Base_Value(var Op_Ctx; Source_Addr : Addr_VN::Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) -> VN_Id is
     // Fetch VN at given address only to determine whether it is null.
     // If addr has Updated_Value, fetch underlying value of Updated value.

      return Fetch_Value (Op_Ctx, Source_Addr, Source_Pos, Origin)  //  TBD
   end func Fetch_Base_Value

   func Get_Updated_Value (ref var Op_Ctx; Base_Obj : OID;
     Selector : Component_Selector_VN::Component_Selector_VN_Id;
     Source_Pos : Reflection::Source_Position) -> ref var Updated_Value is
     //  Return Updated_Value associated with Base_Obj.
     //  TBD:  Create one if necessary.
      if Base_Obj not in Op_Ctx.OID_To_UV_Map then
         var Kind : Component_Selector_VN::Selector_Kind := #named
         case Op_Ctx.VNT[Selector] of
            [Component : Component_Selector_VN+] =>
               Kind := Kind (Component)
            [..] =>
               null
         end case
            
         Op_Ctx.OID_To_UV_Map |= [Base_Obj => 
           Updated_Value::
             (Base_Val => (Base_Obj in Op_Ctx.OID_To_VN_Map?
                             Op_Ctx.OID_To_VN_Map[Base_Obj]:
                           Op_Ctx.VNT.Get_Unique_Id
                             (Unknown_VN::(Unknown => Op_Ctx.Null_VN))),
              Kind_Of_Selectors => Kind)]
      end if
      return Op_Ctx.OID_To_UV_Map[Base_Obj]
   end func Get_Updated_Value

   func Store_OID
     (var Op_Ctx;
      Dest_Addr : Addr_VN::Addr_VN_Id; New_OID : OID;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) is
      //  Add [Dest_Addr => OID] into Op_Ctx.Addr_To_OID_Map
      //  Deal with assignments to base objects and their components
      //  
      case Op_Ctx.VNT[Dest_Addr] of
         [Component  : Component_Addr_VN] =>
            // Storing through a component address
            // * TBD: Add an assertion that the base object is not null
            //   (that might have been done when address VN was created).
            // * Find/Create Updated value representing object
            //   - This might involve recursion if base object is itself
            //     identified by a component address
            // * Add new OID to appropriate map/stack of updated value.
            const Base_Obj := Component.Base_Obj
            const Selector := Component.Selector
            ref Base_Val =>
              Get_Updated_Value (Op_Ctx, Base_Obj, Selector, Source_Pos)


            //  Updated value has mapping from selector to OID
            //  The basic block's OID=>VN and OID=>Updated_Value maps are
            //  used both for components and for whole objects.
            Base_Val.Component_OIDs |= [Selector => New_OID]

         [..] =>
            //  Not a component address;
            //  Add new value to the AV map for Dest_Addr
            Op_Ctx.Addr_To_OID_Map |= [Dest_Addr => New_OID]
      end case

      if Debug then
         Println("Storing OID" | New_OID |
           ":" | Op_Ctx.OIT[New_OID] |
           " into VN" | Dest_Addr | ":" | Op_Ctx.VNT[Dest_Addr])
      end if
   end func Store_OID

   func Store_OID_Value
     (var Op_Ctx;
      Dest_OID : OID; New_Val : VN_Id;
      Source_Pos : Reflection::Source_Position) is
      //  Add [Dest_OID => New_Val] into Op_Ctx.OID_To_VN_Map
      //  Deal with assignments to base objects and their components
      //  
      if Dest_OID in Op_Ctx.OID_To_VN_Map
        and then Op_Ctx.OID_To_VN_Map[Dest_OID] == New_Val
      then
         //  Redundant assignment
         case Op_Ctx.VNT[New_Val] of
            [Null_Val : Null_Literal_VN] =>
               //  Ignore redundant assign of null
               null
            [..] =>
               Put_Warning("Redundant assign to OID" | Dest_OID | ':' |
                 Op_Ctx.OIT[Dest_OID] | " of value it already has -- VN"
                 | New_Val | ':' | Op_Ctx.VNT[New_Val],
                 Source_Pos)
         end case
         return
      end if

      //  Add new value to the AV map for Dest_Addr
      Op_Ctx.OID_To_VN_Map |= [Dest_OID => New_Val]

      if Debug then
         Println("Storing VN" | New_Val |
           ":" | Op_Ctx.VNT[New_Val] |
           " into OID" | Dest_OID | ":" | Op_Ctx.OIT[Dest_OID])
      end if
   end func Store_OID_Value

   func Has_Updated_Value(Op_Ctx; Composite_OID : OID) -> Boolean is
     //  Return #true if given Composite_OID has an updated value.
      return Composite_OID in Op_Ctx.OID_To_UV_Map
   end func Has_Updated_Value

   func Freeze_Updated_Value(var Op_Ctx;
      Composite_OID : OID;
      Source_Pos : Reflection::Source_Position) is
     //  Freeze updated value of given Composite_OID, if any
      if Composite_OID in Op_Ctx.OID_To_UV_Map then
         ref UV => Op_Ctx.OID_To_UV_Map[Composite_OID]
         var Components : VN_To_VN_Map_Type := []
         var Base_Val := UV.Base_Val;
         const Selector_Kind := UV.Kind_Of_Selectors
         if Debug then
            Println("Freezing OID" | Composite_OID | " => " | UV)
         end if
              
         if Base_Val not null then
            //  Check whether selector kinds match
            case Op_Ctx.VNT[Base_Val] of
               [Agg : Aggregate_VN] =>
                  //  See whether can integrate Base_Val with the updates
                  if Agg.Kind_Of_Selectors == Selector_Kind then
                     //  Kind of selectors match, use Base of Base
                     Base_Val := Agg.Base_Val;
                     Components := Agg.Components;
                  end if
               [..] =>
                  //  Base_Val not an aggregate
                  null
            end case
         end if
         //  Build up new Aggregate VN
         for each [Selector => Comp_OID] of UV.Component_OIDs loop
            const Comp_Val := Fetch_OID_Value
                                (Op_Ctx, Comp_OID, Source_Pos)
            Components |= [Selector => Comp_Val]
         end loop
         const Comp_Value := Op_Ctx.VNT.Get_Unique_Id
                               (Aggregate_VN::
                                (Base_Val => Base_Val,
                                 Kind_Of_Selectors => Selector_Kind,
                                 Components => Components));
         Op_Ctx.OID_To_UV_Map -= Composite_OID
         Store_OID_Value(Op_Ctx, Composite_OID, Comp_Value, Source_Pos)
      end if
   end func Freeze_Updated_Value

   func Get_Component_OID(var Op_Ctx;
      Component_VN   : VN_Id;
      Component_Addr : Component_Addr_VN;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) -> Result : OID is
     //  Get OID for a component.  Defer getting value in case
     //  component is itself a composite object.

      if Component_VN in Op_Ctx.Component_OID_Two_Way_Map then
         //  Component address already in two-way map
         Result := Op_Ctx.Component_OID_Two_Way_Map[Component_VN]
      else
         //  Add component address to two-way map
         Result := Op_Ctx.OIT.Get_Unique_Id (Origin)
         Op_Ctx.Component_OID_Two_Way_Map |= [Component_VN => Result]
      end if
   end func Get_Component_OID

   func Set_Component_OID(var Op_Ctx;
      Component_VN   : VN_Id;
      Component_Addr : Component_Addr_VN;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+; New_OID : OID) is

      //  Update component address to two-way map
      Op_Ctx.Component_OID_Two_Way_Map |= [Component_VN => New_OID]
   end func Set_Component_OID

   func Get_OID(var Op_Ctx; Source_Addr : Addr_VN::Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) -> OID is
     // Fetch/Create OID associated with given address

      func Create_Phi(var AO_Map : VN_To_OID_Map_Type;
        Node : CFG::Node_Id)
        //  Create a phi in nearest unique predecessor that has multiple
        //  incoming edges.  If no unique predecessor has multiple incoming
        //  edges (i.e. there are no join points between point of reference
        //  and the entry node), then return null.
        //  TBD: Handle aggregates properly.
        //  TBD2: Input values need to be in a separate writable structure
        -> optional OID is
         ref In_Edges => Op_Ctx.CFG[Node].Incoming_Edges
         case |In_Edges| of
            [0] =>
               // Entry block
               return null
            [1] =>
               // Recurse
               ref Only_Edge => Op_Ctx.CFG.Nth_Edge(In_Edges[1])
               const Phi_Id := Create_Phi
                                 (Op_Ctx.Node_To_AO_Map[Only_Edge.From],
                                  Only_Edge.From)
               if Phi_Id not null then
                  // Add to this map as well
                  AO_Map |= [Source_Addr => Phi_Id]
               end if
               return Phi_Id
            [..] =>
               // Multiple incoming edges, create Phi here
               const Phi := Phi_Origin::(Phi_Block => Node,
                                         Phi_Addr => Source_Addr)
               const Phi_Id := Op_Ctx.OIT.Get_Unique_Id(Phi)
               // Enter into the map
               AO_Map |= [Source_Addr => Phi_Id]
               // And return it
               return Phi_Id
         end case
      end func Create_Phi

      // Check if address in Addr_To_OID_Map
      if Source_Addr in Op_Ctx.Addr_To_OID_Map then
         //  Address already in the current AO map
         const Existing_OID := Op_Ctx.Addr_To_OID_Map[Source_Addr]
         if Debug then
            Println("Getting OID" | Existing_OID |
              ":" | Op_Ctx.OIT[Existing_OID] |
              " from VN" | Source_Addr | ":" | Op_Ctx.VNT[Source_Addr])
         end if
         return Existing_OID
      end if

      var Result : optional OID := null
      var Is_Input : Boolean := #false

      //  Handle special sorts of addresses (components; type-relative)
      case Op_Ctx.VNT[Source_Addr] of
         [Component : Component_Addr_VN] =>
            // A component address
            // Associate it with an OID

            Result := Get_Component_OID
                        (Op_Ctx, Source_Addr, Component, Source_Pos, Origin)

            if Debug then
               Println("Fetching (component) OID" | Result |
                 ":" | Op_Ctx.OIT[Result] |
                 " from VN" | Source_Addr | ":" | Op_Ctx.VNT[Source_Addr])
            end if
            return Result

         [Type_Rel : Type_Addr_VN] =>
            //  This is an input
            Is_Input := #true
            
         [Const : Const_Area_VN] =>
            Is_Input := #true
            
         [..] =>
            null
      end case

      if Is_Input then
         return Op_Ctx.OIT.Get_Unique_Id
                             (Input_Origin::(Input_Addr => Source_Addr))
      end if

      // Create a "phi" if there are multiple incoming edges.
      // Recurse if there is only one

      const Phi_Id := Create_Phi(Op_Ctx.Addr_To_OID_Map, Op_Ctx.Cur_Node_Id)
      if Phi_Id not null then
         if Debug then
            Println("Fetching (phi) OID" | Phi_Id |
              ":" | Op_Ctx.OIT[Phi_Id] |
              " from VN" | Source_Addr | ":" | Op_Ctx.VNT[Source_Addr])
         end if
         return Phi_Id
      end if

      // Straight shot from entry block, and no definitions
      // See whether Source_Addr is an "Input" VN, in which case the content
      // of such a VN is itself an input.
      case Op_Ctx.VNT[Source_Addr] of
         [Input : Input_VN] =>
            const Input_OID := Op_Ctx.OIT.Get_Unique_Id
               (Input_Origin::(Input_Addr => Source_Addr))

            if Debug then
               Println("Fetching (input) OID" | Input_OID |
                 ":" | Op_Ctx.OIT[Input_OID] |
                 " from VN" | Source_Addr | ":" | Op_Ctx.VNT[Source_Addr])
            end if

            //  Record OID in AO Map
            Store_OID (Op_Ctx, Source_Addr,
                       New_OID => Input_OID, Source_Pos => Source_Pos,
                       Origin => Origin)

            return Input_OID
         [..] =>
            Put_Error("Fetch of undefined value at VN" | Source_Addr | ':' |
              Op_Ctx.VNT[Source_Addr], Source_Pos)
            const Unknown_OID := Op_Ctx.OIT.Get_Unique_Id (Origin)

            //  Record OID in AO Map
            Store_OID (Op_Ctx, Source_Addr,
                       New_OID => Unknown_OID, Source_Pos => Source_Pos,
                       Origin => Origin)

            //  Record an Unknown_VN in OV Map
            Store_OID_Value(Op_Ctx, Unknown_OID,
              New_Val => Op_Ctx.VNT.Get_Unique_Id
                           (Unknown_VN::(Unknown => Source_Addr)),
              Source_Pos => Source_Pos)

            return Unknown_OID
      end case

   end func Get_OID

   func Store_Value
     (var Op_Ctx;
      Dest_Addr : Addr_VN::Addr_VN_Id; New_Val : VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) is
      //  Create a new OID based on Origin, and then
      //  Add [Dest_Addr => New_OID] into Op_Ctx.Addr_To_OID_Map
      //  and [New_OID => New_Val] into Op_Ctx.OID_To_VN_Map.
      //  Deal with assignments to base objects and their components
      //  Get a new OID
      const New_OID := Op_Ctx.OIT.Get_Unique_Id (Origin)
      // Set new OID and value for destination
      Store_OID(Op_Ctx, Dest_Addr, New_OID => New_OID,
        Source_Pos => Source_Pos,
        Origin => Origin)
      Store_OID_Value(Op_Ctx, New_OID, New_Val, Source_Pos => Source_Pos)
   end func Store_Value

   func Fetch_OID_Value(var Op_Ctx; Source_OID : OID;
      Source_Pos : Reflection::Source_Position) -> Result : VN_Id is
     // Fetch VN at given OID

      if Op_Ctx.Has_Updated_Value(Source_OID) then
         Op_Ctx.Freeze_Updated_Value(Source_OID, Source_Pos);
      end if;

      if Source_OID in Op_Ctx.OID_To_VN_Map then
         return Op_Ctx.OID_To_VN_Map[Source_OID]  //  TBD: Handle all cases
      end if

      Result := null

      //  Not in OID_To_VN map.  See whether is an input
      case Op_Ctx.OIT[Source_OID] of
       [Input : Input_Origin] =>
         //  Handle special sorts of Inputs (constants; type-relative)
         const Source_Addr := Input.Input_Addr

         case Op_Ctx.VNT[Source_Addr] of
          [Type_Rel : Type_Addr_VN] =>
            //  TBD: Treat all of these as unknown for now
            null
          [Const : Const_Area_VN] =>
            //  Get contents of given constant area
            const Const_Loc : Object_Locator :=
              Create (Const_Area, Const.Offset);
            const Info :=
              Reflection::Const_Info::Const_Info_At_Locator(Const_Loc);
            const Const_Type := Unwrapped_Type_Desc (Info.Data.Type_Desc);
            const Const_Value := Info.Data.Value;
            var Const_VN : VN_Id := Op_Ctx.Null_VN
            if Is_Small (Const_Type) then
               //  A small object, treat each kind of
               //  value appropriately
               case Type_Kind (Const_Type) of
                  [#univ_integer | #normal] =>
                     if Const_Value is null then
                        //  Leave the null value
                        null;
                     elsif Name (Const_Type) == "PSL::Core::Boolean" then
                        //  Special case -- Boolean type
                        Const_VN := Op_Ctx.VNT.Get_Bool_Literal_VN
                                      (Const_Value != 0);
                     else
                        Const_VN := Op_Ctx.VNT.Get_Int_Literal_VN(Const_Value);
                     end if
                  [#univ_enum] =>
                     const Const_Enum :=
                       Reflection::Interpret_As_Univ_Enum (Const_Value);
                     if Const_Enum not null then
                        Const_VN := Op_Ctx.VNT.Get_Unique_Id
                          (Enum_Literal_VN:: (Value => Const_Enum))
                     end if
                  [#univ_real] =>
                     const Const_Real :=
                       Reflection::Interpret_As_Univ_Real (Const_Value)
                     if Const_Real not null then
                        Const_VN := Op_Ctx.VNT.Get_Unique_Id
                          (Real_Literal_VN:: (Value => Const_Real))
                     end if
                  [#univ_char] =>
                     const Const_Char :=
                       Reflection::Interpret_As_Univ_Char (Const_Value)
                     if Const_Char not null then
                        Const_VN := Op_Ctx.VNT.Get_Unique_Id
                          (Char_Literal_VN:: (Value => Const_Char))
                     end if
                  [..] =>
                     //  ** TBD **
                     Put_Error("Fetch of const of type " | Name (Const_Type) |
                       ", kind " | Type_Kind (Const_Type) |
                       " at " | Source_Addr |
                       ':' | Op_Ctx.VNT[Source_Addr], Source_Pos)
                     Const_VN := Op_Ctx.VNT.Get_Unique_Id
                        (Unknown_VN::(Unknown => Source_Addr))
               end case
            elsif Type_Kind (Const_Type) == #univ_string then
               const Const_Str :=
                 Reflection::Interpret_As_String (Const_Value)
               if Const_Str not null then
                  Const_VN := Op_Ctx.VNT.Get_Unique_Id
                    (String_Literal_VN:: (Value => Const_Str))
               end if
            else
               //  A large object, create an aggregate value
               //  ** TBD **
               Put_Warning("NYI: Fetch of large const at " | Source_Addr |
                       ':' | Op_Ctx.VNT[Source_Addr], Source_Pos)
               Const_VN := Op_Ctx.VNT.Get_Unique_Id
                              (Unknown_VN::(Unknown => Source_Addr))

            end if
            
            if Debug then
               Println("Fetching (const) VN" | Const_VN |
                 ":" | Op_Ctx.VNT[Const_VN] |
                 " from VN" | Source_Addr | ":" | Op_Ctx.VNT[Source_Addr])
            end if

            Result := Const_VN
            
          [..] =>
            null
         end case

         if Result is null then
            //  Treat remaining input cases as Input_VNs for now
            Result := Op_Ctx.VNT.Get_Unique_Id
                                 (Input_VN::(Input_Addr => Source_Addr))

            if Debug then
               Println("Fetching (input) VN" | Result |
                 ":" | Op_Ctx.VNT[Result] |
                 " from Input Addr" | Source_Addr | ":" |
                 Op_Ctx.VNT[Source_Addr])
            end if

         end if

       [..] =>
         //  See whether is an OID for a component
         const Addr_Id :=
                 Op_Ctx.Component_OID_Two_Way_Map.Key_Of (Source_OID)
         if Addr_Id not null then
            //  Get VN or UV for enclosing object
            case Op_Ctx.VNT[Addr_Id] of
             [Component : Component_Addr_VN] =>
               const Base_OID := Component.Base_Obj
               const Selector := Component.Selector
               const Base_Val := Op_Ctx.Fetch_OID_Value (Base_OID, Source_Pos)

               const Comp_Val := Op_Ctx.VNT.Get_Unique_Id
                                   (Component_Value_VN::(Base_Val, Selector))

               Result := Comp_Val
               
             [..] =>
               {*addr_should_be_component* #false}  //  Shouldn't happen
            end case
         end if

      end case

      if Result is null then
         //  Not clear where this OID came from.
         //  Return an Unknown VN
         Put_Error("Fetch of undefined value at OID" | Source_OID | ':' |
           Op_Ctx.OIT[Source_OID], Source_Pos)
         Result := Op_Ctx.VNT.Get_Unique_Id
                        (Unknown_VN::(Unknown => Op_Ctx.Null_VN))
      end if

      //  Record Result in OV Map
      Store_OID_Value (Op_Ctx, Source_OID,
                       New_Val => Result,
                       Source_Pos => Source_Pos)

   end func Fetch_OID_Value

   func Fetch_Value(var Op_Ctx; Source_Addr : Addr_VN::Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) -> VN_Id is
     // Fetch VN at given address

      return Fetch_OID_Value
        (Op_Ctx,
         Get_OID (Op_Ctx, Source_Addr, Source_Pos, Origin),
         Source_Pos)
   end func Fetch_Value

   func All_Are_Literals (Op_Ctx; Operands : Vector<VN_Id>) -> Boolean is
     //  Return #true if all of the operands are literals, if any.
     //  Return #false if any operand is not a literal.
     //  NOTE: We might allow other kinds of compile-time-known values
     //        at some point.
      return (for all Op of Operands => Is_Literal_VN (Op_Ctx.VNT, Op))
   end func All_Are_Literals

   func Value_Number_Locator(var Op_Ctx; Locator : Object_Locator;
     I : Code_Index; Which_Output : Output_Index := 1)
     -> Addr_VN::Addr_VN_Id is
      //  Return an addr value number for given object locator
      //  Add a non-null assertion if locator implies a non-null base obj

      var Result : optional Addr_VN::Addr_VN_Id := null;
      const Instr := Op_Ctx.Routine.Nth_Instr(I);
      const Source_Pos := Source_Pos (Instr)
      const Origin : Origin_Info+ := Code_Origin::(I, Which_Output)

      case Locator.Base() of
         [Zero_Base] => {#false}

         [Local_Area] =>
            Result := Op_Ctx.VNT.Get_Unique_Id
              (Local_Addr_VN::
                (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                 BB_Id => Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                 Offset => Locator.Offset()))

         [Enclosing_Local_Areas.First .. Enclosing_Local_Areas.Last] =>
            const Uplevel : Code_Nesting_Level :=
              [[Locator.Base() - Enclosing_Local_Areas.First]]
            Result := Op_Ctx.VNT.Get_Unique_Id
              (Local_Addr_VN::
                (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel),
                 BB_Id =>
                   Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel),
                 Offset => Locator.Offset()))

         [Param_Area] =>
            Result := Op_Ctx.VNT.Get_Unique_Id
              (Param_Addr_VN::
                (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                 BB_Id => Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                 Offset => Locator.Offset()))

         [Enclosing_Param_Areas.First .. Enclosing_Param_Areas.Last] =>
            const Uplevel : Code_Nesting_Level :=
              [[Locator.Base() - Enclosing_Param_Areas.First]]
            Result := Op_Ctx.VNT.Get_Unique_Id
              (Param_Addr_VN::
                (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel),
                 BB_Id =>
                   Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel),
                 Offset => Locator.Offset()))

         [Base_Registers.First .. Base_Registers.Last] =>
            // Select a component
            const Local_Addr := Op_Ctx.VNT.Get_Unique_Id(Local_Addr_VN::
                 (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  BB_Id => Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  Offset => [[Locator.Base() - Base_Registers.First]]))

            const Base_Obj :=
              Get_OID(Op_Ctx, Local_Addr, Source_Pos, Origin)

            const Base_Value :=
              Fetch_OID_Base_Value(Op_Ctx, Base_Obj, Source_Pos, Origin)

            //  Add assertion that base value is not null
            const NN_Val := Op_Ctx.VNT.Get_Unique_Id
                             (Not_Null_VN::(Tested_Val => Base_Value))
            Op_Ctx.Boolean_VNs |= NN_Val
            ref Assertions_Map => Op_Ctx.Instr_To_Assertions_Map[I]
            if Assertions_Map is null then
               Assertions_Map := [NN_Val]
            else
               Assertions_Map |= NN_Val
            end if

            Result := Op_Ctx.VNT.Get_Unique_Id(Component_Addr_VN::
                 (Base_Obj => Base_Obj,
                  Selector => Op_Ctx.VNT.Get_Unique_Id
                    (Named_Selector_VN::(Offset => Locator.Offset()))))

            Println("** Value_Number_Locator => Component: " |
              Op_Ctx.VNT[Result])

         [Phys_Base_Registers.First .. Phys_Base_Registers.Last] =>
            // Level of indirection
            const Offset : Reflection::Offset_Within_Area :=
              [[Locator.Base() - Phys_Base_Registers.First]]
            const Local_Addr := Op_Ctx.VNT.Get_Unique_Id
              (Local_Addr_VN::
                 (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  BB_Id => Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  Offset => Offset))

            const Base_Obj :=
              Get_OID(Op_Ctx, Local_Addr, Source_Pos, Origin)

            const Base_Value :=
              Fetch_OID_Base_Value(Op_Ctx, Base_Obj, Source_Pos, Origin)

            if Locator.Offset() == 0 then
               //  A pure indirection
               Result := Base_Value
            else
               //  Selecting a component
               Result := Op_Ctx.VNT.Get_Unique_Id(Component_Addr_VN::
                    (Base_Obj => Base_Obj,
                     Selector => Op_Ctx.VNT.Get_Unique_Id
                       (Named_Selector_VN::(Offset => Locator.Offset()))))
            end if

         [Type_Area] =>
            Result := Op_Ctx.VNT.Get_Unique_Id
              (Type_Addr_VN::
                 (Uplevel => 0,
                  Offset => Locator.Offset()))

         [Enclosing_Type_Areas.First .. Enclosing_Type_Areas.Last] =>
            Result := Op_Ctx.VNT.Get_Unique_Id
              (Type_Addr_VN::
                 (Uplevel => [[Locator.Base() - Enclosing_Type_Areas.First]],
                  Offset => Locator.Offset()))

         [Const_Area] =>
            Result := Op_Ctx.VNT.Get_Unique_Id
              (Const_Area_VN::
                 (Offset => Locator.Offset()))

         [..] =>
            Println("Locator " | Locator | " NYI")
            //  Fall through to return an unknown addr
      end case

      if Result is null then
         //  Return an unknown address
         Result :=
           Op_Ctx.VNT.Get_Unique_Id(Unknown_VN::(Unknown => Op_Ctx.Null_VN))
      end if
      if Debug_Value_Numbering then
         Println (" Value_Number_Locator(" | Locator | ") -> VN" | Result |
           ":" | Op_Ctx.VNT[Result])
      end if
      return Result
   end func Value_Number_Locator

   func Value_Number_Builtin(var Op_Ctx; Desig : Univ_String;
     Operands : Vector<VN_Id>; Source_Pos : Reflection::Source_Position)
     -> optional VN_Id is
      //  Return value number for result of call on builtin.
      //  Return null if should be treated like normal call.
      case Desig of
       ["#identity" | "#integer_from_univ" | "#integer_to_univ"] =>
         // Identity operations
         return Operands[1]
       ["#ordering_to_bool"] =>
         const Ordering_Mask := Int_Literal_Value(Op_Ctx.VNT, Operands[2])
         {Ordering_Mask not null}

         //  See whether value is known
         const Ordering_Val := Int_Literal_Value(Op_Ctx.VNT, Operands[1])
         if Ordering_Val is null then
            //  Not known, create a Condition_Mask_VN
            return Op_Ctx.VNT.Get_Unique_Id
                               (Condition_Mask_VN::
                                 (Tested_Val => Operands[1],
                                  Mask => From_Rep(Ordering_Mask)))
         end if
         //  Evaluate now, by checking if ordering mask has proper bit on
         const Bool_Val := (Ordering_Mask >> Ordering_Val) mod 2 != 0
         //  Return boolean result
         return Op_Ctx.VNT.Get_Bool_Literal_VN(Bool_Val)
       ["#bool_from_univ"] =>
         const Lit_Val := Enum_Literal_Value(Op_Ctx.VNT, Operands[1])
         if Lit_Val not null then
            case Lit_Val of
              [#false] =>
               return Op_Ctx.VNT.Get_Bool_Literal_VN(#false)
              [#true] =>
               return Op_Ctx.VNT.Get_Bool_Literal_VN(#true)
              [..] =>
               Put_Error("Not a Boolean literal: " | Lit_Val, Source_Pos)
               return null
            end case
         end if
       ["#ordering_from_univ"] =>
         const Lit_Val := Enum_Literal_Value(Op_Ctx.VNT, Operands[1])
         if Lit_Val not null then
            case Lit_Val of
             [#less] =>
               return Op_Ctx.VNT.Get_Int_Literal_VN(0)
             [#equal] =>
               return Op_Ctx.VNT.Get_Int_Literal_VN(1)
             [#greater] =>
               return Op_Ctx.VNT.Get_Int_Literal_VN(2)
             [#unordered] =>
               return Op_Ctx.VNT.Get_Int_Literal_VN(3)
             [..] =>
               Put_Error("Not an Ordering value: " | Lit_Val, Source_Pos)
               return null
            end case
         end if
       ["\"and\""] =>
         return Op_Ctx.VNT.Get_Unique_Id
                         (Logical_And_VN::(Left => Operands[1],
                                           Right => Operands[2]))
       ["\"or\""] =>
         return Op_Ctx.VNT.Get_Unique_Id
                         (Logical_Or_VN::(Left => Operands[1],
                                           Right => Operands[2]))
       ["\"not\""] =>
         return Op_Ctx.VNT.Get_Unique_Id
                         (Logical_Not_VN::(Tested_Val => Operands[1]))
       ["\"=?\""] =>
         // TBD: if neither side is a literal, convert to subtraction
         //      compared against zero
         return null // TBD
       ["\"-\""] =>
         // TBD: do compile-time calculation
         return null // TBD
       ["\"+\""] =>
         // TBD: do compile-time calculation; re-order for canonicalization
         return null // TBD
       [..] =>
         return null
      end case
      return null   //  TBD
   end func Value_Number_Builtin

   func Value_Number_Call(var Op_Ctx; Target_Index : Reflection::Routine_Index;
     Param_Start : Object_Locator; I : Code_Index) is
      //  Add value numbers to VNT and AO/OV Maps to represent effects of call 
      const Routine : Reflection::Routine :=
        Routine_At_Index (Target_Index)
      const Instr := Op_Ctx.Routine.Nth_Instr(I);
      const Source_Pos := Source_Pos (Instr)

      //  TBD: We need parameter info, which is not yet on calls
      //       through operation descriptors.
      {*op_desc_NYI* Routine not null}

      const Desig := Routine.Built_In_Desig();
      //  TBD: Some subset of the built-ins have "known" effects.

      const Params := Parameters(Routine)

      //  Count number of outputs
      const Num_Updated :=
        (for each P of Params
          {P.Is_Operation_Output or else P.Is_Var} => <0> + 1)

      if Debug_Verbose then
         Println(Source_Pos | ": Call of " | Routine.Name() |
           (Desig not null? "(" | Desig | ") ": "") |
           " has " |
           Num_Updated | " updated.")
      end if

      if Num_Updated == 0 then
         return  //  Nothing more to do (TBD: check precond)
      end if

      //  See whether this returns a "ref"
      const Returns_A_Ref := Params[1].Is_Operation_Output
        and then Params[1].Is_Declared_Ref

      //  Accumulate "ref" and non-ref operands if returns a "ref"
      var Ref_Operands  : Vector<Addr_VN::Addr_VN_Id> := []
      var Non_Ref_Operands : Vector<VN_Id> := []

      //  Create a value number to represent the effects of this
      //  call.
      const Num_Inputs :=
        (for each P of Params {not P.Is_Operation_Output} => <0> + 1)

      //  Get location of parameter area in local area
      const Start : Object_Locator := Param_Start
      {Start.Base() == Local_Area}

      const Param_Area_Offset := Start.Offset() - 1

      //  Create a Call value number using call target and
      //  each input.
      var Routine_Id    : VN_Id := Op_Ctx.VNT.Get_Int_Literal_VN(Target_Index)

      //  Build up the list of operands
      var Call_Operands : Vector<VN_Id> := []

      for each [J => P] of Params {not P.Is_Operation_Output}
        forward loop
         const Param_Locator : Object_Locator :=
           Create(Local_Area, Param_Area_Offset + J);
         const Param_Addr : Addr_VN::Addr_VN_Id :=
           Value_Number_Locator (Op_Ctx, Param_Locator, J)
         //  Now get the value passed (might be an address)
         const Passed_Value : VN_Id :=
           Fetch_Value(Op_Ctx, 
             Source_Addr    => Param_Addr,
             Source_Pos     => Source_Pos,
             Origin         => Code_Origin::(I, Which_Output => J))

         //  Add to Call_Operands only if needed
         if not Returns_A_Ref or else Num_Updated > 1 then
            if P.Is_Passed_By_Ref then
               //  Insert an extra level of indirection
               Call_Operands |=
                 Fetch_Value(Op_Ctx, Passed_Value,
                   Source_Pos  => Source_Pos,
                   Origin      => Code_Origin::(I, Which_Output => J))
            else
               Call_Operands |= Passed_Value
            end if
         end if

         if Returns_A_Ref then
            //  Keep track of ref and non-ref operands
            if P.Is_Declared_Ref then
               //  Include address in Ref_Operands if returns a ref
               if |Ref_Operands| > 0 then
                  Put_Error
                    ("NYI: Multiple \"ref\" inputs",
                     Source_Pos);
                  Non_Ref_Operands |= Passed_Value
               else
                  Ref_Operands |= Passed_Value
                  //  TBD: Some "ref" operands should be included
                  // 
               end if
            else
               Non_Ref_Operands |= Passed_Value
            end if
         end if
      end loop

      //  Get value number for call if needed
      var Call_Val : optional VN_Id := null

      //  Check for built-in
      //  TBD: What about a builtin that returns a ref?  E.g. basic_array_index
      if Desig not null then
         Call_Val :=
           Value_Number_Builtin(Op_Ctx, Desig, Call_Operands, Source_Pos)
      end if

      if Call_Val is null
        and then (not Returns_A_Ref or else Num_Updated > 1)
      then
         Call_Val := Op_Ctx.VNT.Get_Unique_Id
           (Call_VN::(Routine_Id => Routine_Id,
                      Operands => Call_Operands))
      end if

      var Indexed_Selector : optional VN_Id := null
      var Indexed_Addr_Val : optional Addr_VN::Addr_VN_Id := null

      if Returns_A_Ref then
         //  Should be at least one "ref" operand if called
         //  routine returns a "ref"
         {|Ref_Operands| > 0}
         Indexed_Selector := Op_Ctx.VNT.Get_Unique_Id
            (Indexed_Selector_VN::
              (Indexing_Routine_Id => Routine_Id,
               Indexing_Operands => Non_Ref_Operands,
               Is_Indexing_Op => Routine.Name() == "\"indexing\"",
                 //  TBD: Not necessarily reliable indicator of "Is_Indexing"
               Is_Static_Indexing =>
                 All_Are_Literals (Op_Ctx, Non_Ref_Operands)))

         Indexed_Addr_Val := Op_Ctx.VNT.Get_Unique_Id
           (Component_Addr_VN::
             (Base_Obj => Get_OID
                            (Op_Ctx, Ref_Operands[1], Source_Pos,
                             Code_Origin::(I, Which_Output => 0)),
              Selector => Indexed_Selector))
      end if

      //  Now use this new value number for the result(s) of the call
      for each [J => P] of Params
        {P.Is_Operation_Output or else P.Is_Var} forward loop
         const Param_Locator : Object_Locator :=
           Create(Local_Area, Param_Area_Offset + J);
         var Param_Addr : Addr_VN::Addr_VN_Id :=
           Value_Number_Locator (Op_Ctx, Param_Locator, J)
         const Output_OID := Op_Ctx.OIT.Get_Unique_Id
                              (Code_Origin::(I, Which_Output => J))
         if not P.Is_Operation_Output and then P.Is_Passed_By_Ref then
            //  Get address of var that is updated
            {P.Is_Var}  //  This should be marked as a variable
            Param_Addr := Fetch_Value(Op_Ctx, 
              Source_Addr    => Param_Addr,
              Source_Pos     => Source_Pos,
              Origin         => Code_Origin::(I, Which_Output => J))
         end if

         //  Store OID in output Param_Addr
         Store_OID(Op_Ctx, Param_Addr,
           New_OID => Output_OID,
           Source_Pos => Source_Pos,
           Origin => Code_Origin::(I, Which_Output => J))

         if Num_Updated == 1 then
            //  Set new value of the single output
            if P.Is_Operation_Output and then P.Is_Passed_By_Ref then
               //  This is a "ref" output
               {Returns_A_Ref}
               //  TBD: The address should be a function of the
               //       addresses of the "ref" parameters and
               //       the value of (some or all) of the parameters.
               //       The value of the "ref" parameters is normally
               //       irrelevant.
               
               Store_OID_Value(Op_Ctx, Output_OID,
                 New_Val => Indexed_Addr_Val,
                 Source_Pos => Source_Pos)
            else
               //  This is a "normal" output, set OID and value number
               {Call_Val not null}
               Store_OID_Value(Op_Ctx, Output_OID,
                 New_Val => Call_Val,
                 Source_Pos => Source_Pos)
            end if
         else
            //  This is just one of multiple updatable parameters.
            if P.Is_Operation_Output and then P.Is_Passed_By_Ref then
               //  The "ref" output is treated the same even if
               //  there are other non-ref updatable parameters.
               {Returns_A_Ref}
               //  Should be only one "ref" output
               {(for all K in J+1 .. |Params| =>
                   not Params[K].Is_Operation_Output
                   or else not Params[K].Is_Passed_By_Ref)}
               Store_OID_Value(Op_Ctx, Output_OID,
                 New_Val => Indexed_Addr_Val,
                 Source_Pos => Source_Pos)
            else
               //  Create a component value and assign to param.
               {Call_Val not null}
               const Component_Val := Op_Ctx.VNT.Get_Unique_Id
                 (Component_Value_VN::
                    (Base_Val => Call_Val,
                     Selector => Op_Ctx.VNT.Get_Unique_Id
                       (Named_Selector_VN::(Offset => J-1))))
               Store_OID_Value(Op_Ctx, Output_OID,
                 New_Val => Component_Val,
                 Source_Pos => Source_Pos)
            end if
         end if
      end loop
   end func Value_Number_Call

   func Logical_Not(var Op_Ctx; Val_To_Complement : VN_Id) -> Result : VN_Id is
     //  Return logical complement of Val_To_Complement
     //  If Val_To_Complement is itself a Logical_Not, just return the
     //  underlying value.  Otherwise, add a Logical_Not_VN on top.
      case Op_Ctx.VNT[Val_To_Complement] of
         [Log_Not : Logical_Not_VN] =>
            //  Two "not"s make a truth.
            Result := Log_Not.Tested_Val
         [..] =>
            Result := Op_Ctx.VNT.Get_Unique_Id 
                     (Logical_Not_VN::(Tested_Val => Val_To_Complement))
      end case
      Op_Ctx.Boolean_VNs |= Result
   end func Logical_Not

   func Apply_Condition_Mask(var Op_Ctx;
     Tested_Val : VN_Id;
     Mask : Reflection::Instruction::Condition_Bit_Mask) -> Result : VN_Id is
      //  Apply mask to tested value to turn it into a boolean expression
      //  with value 0 or 1
      case Mask.To_Rep() of
       [1] =>
         //  This is logical complement
         Result := Logical_Not(Op_Ctx, Tested_Val)
       [2] =>
         //  This is the identity (aka X != 0)
         Result := Tested_Val
         if Tested_Val not in Op_Ctx.Boolean_VNs then
            //  See whether need to adjust result
            case Op_Ctx.VNT[Tested_Val] of
               [Bool : Bool_Literal_VN] =>
                  null  //  OK as is
               [Not : Logical_Not_VN] =>
                  null  //  OK as is
               [And : Logical_And_VN] =>
                  null  //  OK as is
               [Or : Logical_Or_VN] =>
                  null  //  OK as is
               [Cond : Condition_Mask_VN] =>
                  null  //  OK as is
               [Int : Int_Literal_VN] =>
                  //  Convert to corresponding bool literal
                  Result := Op_Ctx.VNT.Get_Bool_Literal_VN(Int.Value != 0)
               [..] =>
                  //  Not sure whether this is a good boolean value
                  Put_Warning("Non-boolean being added to Boolean_VNs: VN" |
                    Tested_Val | ":" | Op_Ctx.VNT[Tested_Val])
                  //  Use special operator for applying the mask
                  Result := Op_Ctx.VNT.Get_Unique_Id
                    (Condition_Mask_VN::(Tested_Val => Tested_Val,
                                         Mask => Mask))
            end case
         end if
       [..] =>
         //  Use special operator for applying the mask
         Result := Op_Ctx.VNT.Get_Unique_Id
           (Condition_Mask_VN::(Tested_Val => Tested_Val,
                                Mask => Mask))
      end case
      if Debug_Verbose then
         Println("Apply_Condition_Mask: VN" | Tested_Val | ", Mask = " |
           Mask | " (" | Mask.To_Rep() | ") => VN" | Result | ":" |
           Op_Ctx.VNT[Result])
      end if
      Op_Ctx.Boolean_VNs |= Result
   end func Apply_Condition_Mask

   func Value_Number_Start_Of_Block(var Op_Ctx) is
      //  Incorporate incoming-edge info into Addr_To_OID and OID_To_VN maps
      ref Cur_Node => Op_Ctx.CFG[Op_Ctx.Cur_Node_Id]
      const Num_Incoming := |Cur_Node.Incoming_Edges|
      case Num_Incoming of
         [0] =>
            //  This must be the start node of the whole operation
            //  The Input_VNs should have already been created.
            //  NOTE: We now have edges going to nested blocks from
            //        Start/Add_Parallel_Op's
            {Op_Ctx.Cur_Node_Id in Op_Ctx.CFG_Entry_Nodes}
         [1] =>
            //  Just use prior AO, OV, and OUV Maps
            const Only_In_Edge_Id :=
              Cur_Node.Incoming_Edges[1]
            const Only_Pred_Id :=
              Op_Ctx.CFG.Nth_Edge (Only_In_Edge_Id).From

            {Only_Pred_Id in Op_Ctx.Node_To_AO_Map}
               // Should have encountered single predecessor already.

            Op_Ctx.Addr_To_OID_Map :=
              Op_Ctx.Node_To_AO_Map[Only_Pred_Id]
            Op_Ctx.OID_To_VN_Map :=
              Op_Ctx.Node_To_OV_Map[Only_Pred_Id]
            if Only_Pred_Id in Op_Ctx.Node_To_OUV_Map then
               Op_Ctx.OID_To_UV_Map :=
                 Op_Ctx.Node_To_OUV_Map[Only_Pred_Id]
            else
               Op_Ctx.OID_To_UV_Map := []
            end if

         [..] =>
            //  With multiple incoming edges, we initialize
            //  OID_To_UV_Map to empty (UV's should have been frozen
            //  at end of predecessor block)
            Op_Ctx.OID_To_UV_Map := []

            //  See which Addr-VNs have same OIDs and OIDs have same VNs
            //  in each predecessor.
            //  These preserve their OID/value into the new basic block.
            //  Others are removed, and may become phi's when ref'ed.
            for (each In_Edge_Id of Cur_Node.Incoming_Edges;
                 Count in 1 .. Num_Incoming forward)
            loop
               const Pred_Id := Op_Ctx.CFG.Nth_Edge(In_Edge_Id).From
               if Pred_Id not in Op_Ctx.Node_To_AO_Map then
                  // Haven't encountered this node yet.  Initialize
                  // it's entry in the Node_To_AV_Map.
                  {Pred_Id not in Op_Ctx.Node_To_OV_Map}
                  Op_Ctx.Node_To_AO_Map |= [Pred_Id => []]
                  Op_Ctx.Node_To_OV_Map |= [Pred_Id => []]
               end if
               ref Pred_AO_Map => Op_Ctx.Node_To_AO_Map[Pred_Id]
               ref Pred_OV_Map => Op_Ctx.Node_To_OV_Map[Pred_Id]
               if Count == 1 then
                  //  This is the first one; just copy maps
                  Op_Ctx.Addr_To_OID_Map := Pred_AO_Map
                  Op_Ctx.OID_To_VN_Map   := Pred_OV_Map
               else
                  //  This is not the first predecessor, incorporate matching
                  //  bindings only.
                  for each [Addr => Pred_OID] of Pred_AO_Map loop
                     if Addr in Op_Ctx.Addr_To_OID_Map then
                        // We have already seen this Addr; check OID
                        const Old_OID := Op_Ctx.Addr_To_OID_Map[Addr]
                        if Pred_OID != Old_OID then
                           //  OID different, remove addr/OID from AO/OV maps
                           Op_Ctx.Addr_To_OID_Map -= Addr
                           Op_Ctx.OID_To_VN_Map -= Old_OID
                        else
                           //  OID is the same, check the value
                           const Pred_Value := Pred_OV_Map[Pred_OID]
                           const Old_Value := Op_Ctx.OID_To_VN_Map[Old_OID]
                           if Pred_Value != Old_Value then
                              //  Values differ, remove addr/OID from AO/OV maps
                              Op_Ctx.Addr_To_OID_Map -= Addr
                              Op_Ctx.OID_To_VN_Map -= Old_OID
                           end if
                        end if
                     end if
                  end loop
               end if
            end loop
      end case
      {Op_Ctx.Cur_Node_Id not null}
      {Op_Ctx.Addr_To_OID_Map not null}
      {Op_Ctx.OID_To_VN_Map not null}
      {Op_Ctx.OID_To_UV_Map not null}

   end func Value_Number_Start_Of_Block

   func Value_Number_End_Of_Block (var Op_Ctx) is
      //  End of current basic block

      {Op_Ctx.Addr_To_OID_Map not null}
      {Op_Ctx.OID_To_VN_Map not null}
      {Op_Ctx.OID_To_UV_Map not null}

      //  Dump the address-to-OID and OID-to-value maps
      if Debug then
         Println("After BB" | Op_Ctx.Cur_Node_Id | " of " |
           Op_Ctx.Routine.Name())
         Dump_Addr_OID_Value_Maps(Op_Ctx)
      end if

      //  See if any successor has multiple incoming edges.
      //  If so, freeze all updated values
      ref Outgoing_Edges => Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Outgoing_Edges
      const Has_Multi_Input_Successor :=
        (for some Succ of Outgoing_Edges =>
           |Op_Ctx.CFG[Op_Ctx.CFG.Nth_Edge(Succ).To].Incoming_Edges| > 1)

      if Has_Multi_Input_Successor then
         //  Freeze the updated values
         const Index := Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last
         const Instr := Op_Ctx.Routine.Nth_Instr(Index)
         const Source_Pos := Source_Pos(Instr)

         //  Get set of OIDs to freeze before actually freezing any of them
         //  TBD: Should not die if remove OID from map during iteration
         //       or we should detect the race condition.
         //  TBD: const OIDs_To_Freeze : Set<OID> :=
         //  TBD:   [for each [O => UV] of Op_Ctx.OID_To_UV_Map => O]

         //  Freeze all of the OIDs that had Updated Values
         //  TBD:  for O in OIDs_To_Freeze loop
         for each [O => UV] of Op_Ctx.OID_To_UV_Map loop
            var Max_OID_Seen : optional OID := null
            if Debug then
               Println("UVT before freezing OID" | O)
               Op_Ctx.Dump_UVT(Max_OID_Seen)
            end if
            Op_Ctx.Freeze_Updated_Value (O, Source_Pos)
            if Debug then
               Println("UVT after freezing OID" | O)
               Op_Ctx.Dump_UVT(Max_OID_Seen)
            end if
         end loop

         Op_Ctx.OID_To_UV_Map := []
      end if

      if |Op_Ctx.OID_To_UV_Map| > 0 then
         //  Remember the updated values in mapping
         Op_Ctx.Node_To_OUV_Map[Op_Ctx.Cur_Node_Id] <==
           Op_Ctx.OID_To_UV_Map
         //  Reinitialize the OUV map
         Op_Ctx.OID_To_UV_Map := []
      else
         //  Remove updated values from mapping if present
         Op_Ctx.Node_To_OUV_Map -= Op_Ctx.Cur_Node_Id
      end if

      //  Move current Addr-to-OID and OID-to-VN maps into overall mapping
      //  NOTE: Must freeze UVs first, since that updates OID-to-VN maps.
      //  TBD: Clean out unused OIDs first?
      Op_Ctx.Node_To_AO_Map[Op_Ctx.Cur_Node_Id] <==
        Op_Ctx.Addr_To_OID_Map
      Op_Ctx.Node_To_OV_Map[Op_Ctx.Cur_Node_Id] <==
        Op_Ctx.OID_To_VN_Map

      // and reinitialize the maps.
      Op_Ctx.Addr_To_OID_Map := []
      Op_Ctx.OID_To_VN_Map := []

      {Op_Ctx.Addr_To_OID_Map not null}
      {Op_Ctx.OID_To_VN_Map not null}
      {Op_Ctx.OID_To_UV_Map not null}

   end func Value_Number_End_Of_Block

   func Analyze_One_Instr(var Op_Ctx;
     Operation_Routine : Reflection::Routine; I : Code_Index) is
      //  Analyze one instruction.
      //  Op_Ctx.Pass determines what action to take.

      const Instr := Operation_Routine.Nth_Instr(I);
      const Source_Pos := Source_Pos(Instr)
      const Uses_Rgn := Operation_Routine.Uses_Stg_Rgn();
      var IO := IO::Get_IO()

      if Op_Ctx.Pass != #find_basic_blocks
        and then I in Op_Ctx.Instr_To_Node_Map
      then
         //  Do the processing for the start of a basic block
         case Op_Ctx.Pass of
            [#build_cfg] =>
               //  Start of a basic block
               const Prev_Node_Id := Op_Ctx.Cur_Node_Id
               Op_Ctx.Cur_Node_Id := Op_Ctx.Instr_To_Node_Map[I]
               if Prev_Node_Id not null then
                  //  End the prior block if not already ended
                  ref Prev_Node => Op_Ctx.CFG[Prev_Node_Id]
                  if Prev_Node.Last is null then
                     // Prior block not yet ended; end it and add an edge
                     Prev_Node.Last := I - 1
                     const Ignore := Op_Ctx.CFG.Add_Edge(From => Prev_Node_Id,
                       To => Op_Ctx.Cur_Node_Id)
                  end if
               end if
               if Op_Ctx.Cur_Node_Id in Op_Ctx.CFG_Entry_Nodes then
                  //  This is the entry node of a CFG
                  Op_Ctx.Cur_Entry_Node := Op_Ctx.Cur_Node_Id
                  //  Identify the exit node
                  Op_Ctx.Cur_Exit_Node :=
                    Op_Ctx.Entry_Node_To_Exit_Node_Map[Op_Ctx.Cur_Entry_Node]
               end if
            [#value_number] =>
               //  Set the Cur_Node_Id
               Op_Ctx.Cur_Node_Id := Op_Ctx.Instr_To_Node_Map[I]

               //  Incorporate incoming-edge info into the Addr_To_Value_Map
               Value_Number_Start_Of_Block(Op_Ctx)

               //  Do VN processing upon *returning* from a nested block
               if (I-1) in Op_Ctx.Instr_To_Node_Map then
                  const Prev_Instr := Operation_Routine.Nth_Instr(I-1)
                  case Opcode(Prev_Instr) of
                   [#Check_Nested_Block_Op] =>
                     //  Save value number of assertion
                     const Nested_Block_Start :=
                       I + Prev_Instr.Code_Block().Pc_Offset
                     const Nested_Block_Node_Id :=
                       Op_Ctx.Instr_To_Node_Map[Nested_Block_Start]
                     const Nested_Block_Level :=
                       Level_Of_BB(Op_Ctx, Nested_Block_Node_Id)
                     const Result_Addr := Op_Ctx.VNT.Get_Unique_Id
                        (Param_Addr_VN::
                           (Level => Nested_Block_Level,
                            BB_Id => Nested_Block_Node_Id,
                            Offset => 0))
                     const Result_Val := Fetch_Value
                                (Op_Ctx, Result_Addr,
                                 Source_Pos,
                                 Origin =>
                                   Code_Origin::(I-1, Which_Output => 1))
                     Op_Ctx.Boolean_VNs |= Result_Val

                     //  Add result to vector of assertions
                     Op_Ctx.Instr_To_Assertions_Map[I-1] := [Result_Val]
                        // NOTE: we are putting it on the Check_Nested_Block
                        //       but that isn't quite right, as far as when
                        //       it actually gets evaluated.
                   [..] => null  //  TBD: Call_Nested_Block
                  end case
               end if // Special post-nested-block VN processing

            [..] => null
         end case
      end if

      if Debug_Value_Numbering and then Op_Ctx.Pass == #value_number then
         Print (" Value_Numbering Instr#" | I | ": ");
         Debugging::Dump_One_Instr(IO.Stdout, Instr, 0);
      end if

      //  Take the appropriate action based on Pass and instruction opcode
      case Opcode(Instr) of
         [#Skip_Op] =>
            //  Skip_Count is in units of PSVM instructions
            case Op_Ctx.Pass of
               [#find_basic_blocks] =>
                  //  Keep track of where basic blocks start.
                  Op_Ctx.Node_Starts |= (I + Instr.Skip_Count() + 1)
               [#build_cfg] =>
                  //  Keep track of where basic block ends and
                  //  outgoing edges.
                  Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
                  const Ignore :=
                    Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                      To => Op_Ctx.Instr_To_Node_Map[I+Instr.Skip_Count()+1])
               [..] =>
                  null
            end case
         [#Call_Op] =>
            if Op_Ctx.Pass == #value_number then
               Value_Number_Call(Op_Ctx, Instr.Target_Index(),
                 Instr.Params(), I)
            end if
         [#Return_Op | #Exit_Op] =>
            case Op_Ctx.Pass of
               [#find_basic_blocks] =>
                  //  Remember last return/exit statement
                  Op_Ctx.Last_End_Instr := I
               [#build_cfg] =>
                  //  Cur basic block ends here
                  Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
                  if Op_Ctx.Cur_Node_Id != Op_Ctx.Cur_Exit_Node then
                     //  This is not the exit node, so we need to add an
                     //  edge to an exit node
                     const Ignore :=
                       Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                         To => Op_Ctx.Cur_Exit_Node)

                     //  This node should not be listed as an exit node
                     {Op_Ctx.Cur_Node_Id not in Op_Ctx.CFG_Exit_Nodes}
                  end if
               [..] => null
            end case
            //  TODO Return_Op postcondition proved
         [#Copy_Word_Op | #Assign_Word_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Simple copy-word; copy OID from source to destination
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I)
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Which_Output => 2)
               const Source_OID := Get_OID
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 1))
               // Set new OID for destination
               Store_OID(Op_Ctx, Dest_Addr, New_OID => Source_OID,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 2))
            end if

         [#Make_Copy_In_Stg_Rgn_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Create copy of object; copy value from source to destination
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I)
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Which_Output => 2)
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 1))

               // Set new OID and value for destination
               Store_Value(Op_Ctx, Dest_Addr, Source_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Address_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Store address of source in destination
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                                      Which_Output => 3)
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                                      Which_Output => 2)
               // Set new value for destination
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Source_Addr,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Create_Obj_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Create an Aggregate_VN with nothing filled in
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Aggr := Op_Ctx.VNT.Get_Unique_Id
                 (Aggregate_VN::(Base_Val => null,
                                 Kind_Of_Selectors => #named,
                                 Components => []))
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Aggr,
                  Source_Pos => Source_Pos,
                  Origin => Code_Origin::(I, 1))
            end if
         [#Swap_Obj_Op] =>
            null;  //  ** TBD **
         [#Move_Obj_Op] =>
            null;  //  ** TBD **
         [#Store_Local_Null_Op | #Store_Large_Local_Null_Op |
           #Store_Null_Of_Same_Stg_Rgn_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.Null_VN
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Is_Null_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I)
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 2))
               const Not_Null_Val := Op_Ctx.VNT.Get_Unique_Id
                                (Not_Null_VN::(Tested_Val => Source_Value))
               const Is_Null_Val := Logical_Not (Op_Ctx, Not_Null_Val)
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Is_Null_Val,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
               Op_Ctx.Boolean_VNs |= Not_Null_Val
            end if
         [#Not_Null_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I)
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 2))
               const Not_Null_Val := Op_Ctx.VNT.Get_Unique_Id
                                (Not_Null_VN::(Tested_Val => Source_Value))
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Not_Null_Val,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))

               Op_Ctx.Boolean_VNs |= Not_Null_Val
            end if
         [#Store_Int_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value :=
                 Op_Ctx.VNT.Get_Int_Literal_VN(Int_Value(Instr))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Real_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.VNT.Get_Unique_Id
                   (Real_Literal_VN::(Value => Real_Value(Instr)))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Char_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.VNT.Get_Unique_Id
                   (Char_Literal_VN::(Value => Char_Value(Instr)))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Enum_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.VNT.Get_Unique_Id
                   (Enum_Literal_VN::(Value => Enum_Value(Instr)))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Str_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Str_Lit : String_Literal_VN :=
                 (Value => Str_Value(Instr))
               const Lit_Value := Op_Ctx.VNT.Get_Unique_Id(Str_Lit)
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Operation_Desc_Op] =>
            null;  //  ** TBD **
         [#Start_Parallel_Op | #Add_Parallel_Op] =>
            case Op_Ctx.Pass of
               [#find_basic_blocks] =>
                  //  Keep track of where basic blocks start.
                  const Nested_Block_Start :=
                    I + Instr.Parallel_Code_Block().Pc_Offset + 1;
                  Op_Ctx.Node_Starts |= (I + 1)
                  Op_Ctx.Node_Starts |= Nested_Block_Start
                  if Nested_Block_Start > I then
                     //  Remember only "forward" invocations
                     Op_Ctx.Invoked_Blocks |= Nested_Block_Start
                  end if
               [#build_cfg] =>
                  //  Keep track of where basic block ends and
                  //  outgoing edges.
                  const Nested_Block_Start :=
                    I + Instr.Parallel_Code_Block().Pc_Offset + 1;
                  Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
                  const Ignore :=
                    Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                      To => Op_Ctx.Instr_To_Node_Map[I+1])
                  const Ignore2 :=
                    Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                      To => Op_Ctx.Instr_To_Node_Map[Nested_Block_Start])
                  if Nested_Block_Start > I then
                     //  Remember only "forward" invocations
                     Op_Ctx.Invoked_Blocks |= Nested_Block_Start
                  end if
               [#value_number] => null
               [..] => null
            end case
         [#Start_Parallel_Call_Op | #Add_Parallel_Call_Op] =>
            //  TODO: Precond Proved
            //  We treat a parallel call as though it takes no time
            //  at all, and is essentially equivalent to a regular call.
            //  This is not good for race detection, but works for most things.
            if Op_Ctx.Pass == #value_number then
               const Tcb_Locator := Instr.Parallel_Control()
               const Params : Object_Locator :=
                 Create(Tcb_Locator.Base(),
                        Tcb_Locator.Offset() + Reflection::Tcb_Size)

               Value_Number_Call(Op_Ctx, Instr.Parallel_Target_Index(),
                 Params, I)
            end if
         [#Prepare_To_Exit_Parallel_Op] =>
            null;
         [#Wait_For_Parallel_Op] =>
            case Op_Ctx.Pass of
               [#find_basic_blocks] =>
                  if not Is_Empty(Op_Ctx.Invoked_Blocks) then
                     //  This is a wait for one or more nested blocks, so
                     //  mark it as the beginning of a basic block.
                     Op_Ctx.Node_Starts |= I

                     //  Reset set of invoked blocks to empty
                     Op_Ctx.Invoked_Blocks := []
                  end if
               [#build_cfg] =>
                  //  Keep track of where basic block ends and
                  //  outgoing edges.
                  if not Is_Empty(Op_Ctx.Invoked_Blocks) then
                     //  This is a wait for one or more nested blocks, so
                     //  create edges from each of the nested blocks being
                     //  awaited.
                     for Blk in Op_Ctx.Invoked_Blocks loop
                        Op_Ctx.CFG.Add_Edge
                          (From => Op_Ctx.Entry_Node_To_Exit_Node_Map
                                     [Op_Ctx.Instr_To_Node_Map[Blk]],
                           To => Op_Ctx.Cur_Node_Id)
                     end loop

                     //  Reset set of invoked blocks to empty
                     Op_Ctx.Invoked_Blocks := []
                  end if
               [#value_number] => null
               [..] => null
            end case
         [#Create_Lock_For_Obj_Op] =>
            null;
            //  Create Lock uses Virtual addresses
         [#Create_Tcb_Op] =>
            null;  //  ** TBD **
         [#Create_Polymorphic_Obj_Op] =>
            null;  //  ** TBD **
            //  Get destination and type descriptor
         [#Unwrap_Polymorphic_Obj_Op] =>
            null;  //  ** TBD **
         [#Select_Polymorphic_Ancestor_Part_Op |
          #Select_Ancestor_Part_Op] =>
            null;  //  ** TBD **
         [#If_Op] =>
            //  Two basic blocks as successors
            case Op_Ctx.Pass of
             [#find_basic_blocks] =>
               //  Keep track of where basic blocks start.
               Op_Ctx.Node_Starts |= (I + 1)
               Op_Ctx.Node_Starts |= (I + Instr.Skip_If_False() + 1)

             [#build_cfg] =>
               //  Keep track of where basic block ends and
               //  outgoing edges.
               Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
               const Ignore := Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                 To => Op_Ctx.Instr_To_Node_Map[I+1])
               const Ignore2 := Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                 To => Op_Ctx.Instr_To_Node_Map[I+Instr.Skip_If_False()+1])

             [#value_number] =>
               //  Determine the "path condition" for each outgoing edge
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, If_Source(Instr), I)
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 1))
               const Val_Is_True :=
                 Apply_Condition_Mask
                   (Op_Ctx, Source_Value, If_Condition(Instr))
               const Val_Is_False := Logical_Not(Op_Ctx, Val_Is_True)
               const True_Edge :=
                 Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Outgoing_Edges[1]
               const False_Edge :=
                 Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Outgoing_Edges[2]
               Op_Ctx.Edge_Condition[True_Edge] := Val_Is_True
               Op_Ctx.Edge_Condition[False_Edge] := Val_Is_False
             [..] =>
               null
            end case
         [#Call_Nested_Block_Op] =>
            //  Call_Nested_Block not yet used. 
            null;
         [#Check_Nested_Block_Op] =>
            //  We assume that there is only one use of a given nested block
            //  as a check.
            case Op_Ctx.Pass of
               [#find_basic_blocks] => 
                  //  Basic block starts at next instruction
                  Op_Ctx.Node_Starts |= (I + 1)
               [#build_cfg] =>
                  //  Basic block ends here
                  Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
                  //  Add edges to/from nested block
                  const Nested_Block_Start :=
                    I + Instr.Code_Block().Pc_Offset + 1
                  const Nested_Block_Node_Id :=
                    Op_Ctx.Instr_To_Node_Map[Nested_Block_Start]
                  const Nested_Block_End_Id :=
                    Op_Ctx.Entry_Node_To_Exit_Node_Map[Nested_Block_Node_Id]
                  //  Add edge to nested block
                  const Ignore := Op_Ctx.CFG.Add_Edge
                    (From => Op_Ctx.Cur_Node_Id,
                     To => Nested_Block_Node_Id)
                  //  Add edge back from end of nested block to next instr
                  const Ignore2 := Op_Ctx.CFG.Add_Edge
                    (From => Nested_Block_End_Id,
                     To => Op_Ctx.Instr_To_Node_Map[I+1])
               [#value_number] => null
                  //  NOTE: We do the value numbering of the result
                  //        of the nested block at the beginning of
                  //        the basic block that is a successor of the block.
               [..] => null
            end case
         [#Begin_Nested_Block_Op] =>
            case Op_Ctx.Pass of
               [#find_basic_blocks] => 
                  // Last exit/return is considered its own basic block
                  {Op_Ctx.Last_End_Instr not null}
                  Op_Ctx.Node_Starts |= Op_Ctx.Last_End_Instr
                  Op_Ctx.CFG_Ends |= Op_Ctx.Last_End_Instr
                  Op_Ctx.Last_End_Instr := null

                  //  Consider this the beginning of a basic block
                  Op_Ctx.Node_Starts |= I
                  //  Also remember this as the start of a nested block
                  Op_Ctx.Nested_Block_Starts |= I
               [#build_cfg] => null
               [..] => null
            end case
         [#Check_Not_Null_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Save value number of checked object
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Dest_Value := Fetch_Value
                             (Op_Ctx, Dest_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 1))
               const NN_Val := Op_Ctx.VNT.Get_Unique_Id
                                (Not_Null_VN::(Tested_Val => Dest_Value))
               //  Init vector of assertions from not-null condition
               Op_Ctx.Instr_To_Assertions_Map[I] := [NN_Val]
               Op_Ctx.Boolean_VNs |= NN_Val
            end if
         [..] =>
            Put_Error
              ("Internal: Unrecognized PSVM Opcode " | Opcode(Instr),
               Source_Pos);
            {#false};
      end case

      //  Perform end-of-basic-block processing
      if Op_Ctx.Pass == #value_number then
         if I == Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last then
            //  End of current basic block
            Value_Number_End_Of_Block(Op_Ctx)
         end if
      end if

   end func Analyze_One_Instr;

   func Report_Failure
     (var Op_Ctx; Instr : Reflection::Instruction; Failing_VN : VN_Id) is
      case Opcode(Instr) of
         [#Check_Not_Null_Op] =>
            Put_Warning("Null value not allowed here",
              Source_Pos => Instr.Source_Pos())
         [#Check_Nested_Block_Op] =>
            Put_Warning("Assertion will fail here",
              Source_Pos => Instr.Source_Pos())
         [#Call_Op | #Start_Parallel_Call_Op |
           #Add_Parallel_Call_Op] =>
            Put_Warning("Precondition not satisfied here",
              Source_Pos => Instr.Source_Pos())
         [#Return_Op] =>
            Put_Warning("Postcondition not satisfied here",
              Source_Pos => Instr.Source_Pos())
         [..] =>
            Put_Warning("Check will fail here",
              Source_Pos => Instr.Source_Pos())
      end case
   end func Report_Failure

   func Propagate_Top_Down
     (Op_Ctx;
      var VN_Values : VN_To_Value_Set_Map_Type;
      Updated_VNs : VN_Set) -> VNs_To_Recompute : optional VN_Set is
      //  Propagate values of Updated_VNs to their children
      //  (and further descendants)
      //  Update VN_Values with new values of VNs;
      //  return set of VNs needing to be recomputed bottom-up.
      //  Return a null set if an empty set occurs, and don't update the
      //  value set.

      if Is_Empty(Updated_VNs) then
         //  Nothing to do
         return []
      end if

      if Debug_Verbose then
         Println("Propagate_Top_Down:" |
           (for VN in Updated_VNs forward => <""> | " " | VN))
      end if

      //  Initialize VNs_To_Recompute with parents of Updated_VNs
      VNs_To_Recompute := (for VN in Updated_VNs => <[]> |
                             Op_Ctx.VN_To_Parent_Set_Map[VN])

      for VN in Updated_VNs loop
         var Changed_Operands : VN_Set := []

         func Update_Val_Set(Opnd : VN_Id; New_Vals : Value_Set+) is
           //  Update Opnd's value set.  Add to Changed_Operands if changed.
            if Opnd not in VN_Values or else New_Vals != VN_Values[Opnd] then
               //  Update Opnd's value set.
               if Debug_Verbose then
                  Println(" TD: New value set for VN" | Opnd |
                    " is " | To_String(New_Vals))
               end if
               VN_Values[Opnd] := New_Vals
               //  Keep track of operands with new values.
               Changed_Operands |= Opnd
            end if
         end func Update_Val_Set

         ref Val_Num => Op_Ctx.VNT[VN]
         ref Val_Set => VN_Values[VN]

         const New_Opnd_Values :=
           Propagate_To_Operands(Val_Num, Val_Set, Op_Ctx.VNT, VN_Values)

         if New_Opnd_Values is null then
            //  Top-down propagation failed
            if Debug_Verbose then
               Println(" Propagate_To_Operands " | Val_Num | " having " |
                 To_String(Val_Set) | " returned null")
            end if
            return null
         end if

         for each [Opnd => New_Vals] of New_Opnd_Values loop
            //  Update value set of each operand affected by propagation
            Update_Val_Set (Opnd, New_Vals)
         end loop

         if not Is_Empty(Changed_Operands) then
            //  Recurse with changed operands, and include parents of
            //  changed operands but not the VN that caused the top-down prop.
            const Recursive_Changes :=
              Propagate_Top_Down(Op_Ctx, VN_Values, Changed_Operands)

            if Recursive_Changes is null then
               //  Some check failed
               return null
            end if

            const Parents : VN_Set :=
               (for Opnd in Changed_Operands => 
                 <[]> | Op_Ctx.VN_To_Parent_Set_Map[Opnd])

            VNs_To_Recompute |= (Recursive_Changes | Parents) - VN
         end if
      end loop
   end func Propagate_Top_Down

   func Compute_Value_Set
     (Op_Ctx;
      VN_Values : VN_To_Value_Set_Map_Type;
      VN : VN_Id) -> Result : optional Value_Set+ is
      //  Compute value set for VN; return null if
      //  there is no representation for values.
      Result := Compute_Value_Set(Op_Ctx.VNT[VN], Op_Ctx.VNT, VN_Values)
      if Debug_Verbose and then Result is null then
         //  Value set not representable
         Println(" Compute_Value_Set null for " | Op_Ctx.VNT[VN])
      end if
   end func Compute_Value_Set

   func Propagate_Bottom_Up
     (Op_Ctx;
      var VN_Values : VN_To_Value_Set_Map_Type;
      VNs_To_Recompute : VN_Set) -> Boolean is
      //  Recompute values of VNs_To_Recompute, and their ancestors.
      //  Update VN_Values with new values of VNs.
      //  Return #false if we hit a failure during propagation.
      //  NOTE: Going "forward" here is important, as we keep adding to
      //        VNs_Not_Yet_Recomputed.
      var VNs_Not_Yet_Computed := VNs_To_Recompute

      for Ancestor_VN := Remove_First(VNs_Not_Yet_Computed)
        then Remove_First(VNs_Not_Yet_Computed)
        while Ancestor_VN not null
      loop
         //  (Re)compute value set for this Ancestor_VN
         if Debug_Verbose then
            Println("Propagate_Bottom_Up: " | Ancestor_VN)
         end if
         var New_Vals for VN_Values :=
           Compute_Value_Set(Op_Ctx, VN_Values, Ancestor_VN)

         if New_Vals is null then
            //  Value set not representable
            continue loop
         end if

         if Ancestor_VN in VN_Values then
            //  Intersect the prior values with the newly computed values
            New_Vals and= VN_Values[Ancestor_VN]
            if Is_Empty(New_Vals) then
               //  We hit a failure; caller will report the problem.
               return #false
            end if
         end if

         if Ancestor_VN not in VN_Values
           or else New_Vals != VN_Values[Ancestor_VN]
         then
            //  Update stored values
            if Debug_Verbose then
               Println(" BU: New value set for VN" | Ancestor_VN |
                 " is " | To_String(New_Vals))
            end if
            VN_Values[Ancestor_VN] <== New_Vals
            //  Add parents of this VN to list of VNs still to be recomputed
            VNs_Not_Yet_Computed |= Op_Ctx.VN_To_Parent_Set_Map[Ancestor_VN]

            //  We should always be going forward
            {Is_Empty(VNs_Not_Yet_Computed) or else
               First(VNs_Not_Yet_Computed) > Ancestor_VN}
         end if
      end loop

      //  No failures during bottom-up propagation
      return #true
   end func Propagate_Bottom_Up

   func Propagate_Values
     (var Op_Ctx;
      BB : CFG::Node_Id;
      var Predecessor_Changed : Node_Set) is
     //  Propagate value sets within the basic block identified by BB.
     //  If an outgoing edge of BB has a change in its vn-to-value-set map,
     //  add the successor to the Predecessor_Changed node set.
     //  Remove BB from the Predecessor_Changed set when starting.

      if Debug_Verbose then
         Println("Propagate_Values: BB" | BB)
      end if

      Predecessor_Changed -= BB  //  Might be added back below

      const Assert_Is_True : Value_Set+ :=
        Boolean_Value_Set::(Might_Be_Null  => #false,
                            Might_Be_True  => #true,
                            Might_Be_False => #false)

      var VN_Values : VN_To_Value_Set_Map_Type
        // Value set for each VN that is restricted

      ref BB_Node => Op_Ctx.CFG[BB]

      //  Merge information from the incoming edges
      ref In_Edges => BB_Node.Incoming_Edges

      case |In_Edges| of
         [0] =>
            // Must be the entry block;
            // compute values for compile-time-known VNs.
            VN_Values := []
            const Success :=
              Propagate_Bottom_Up(Op_Ctx, VN_Values, Op_Ctx.CTK_VNs)
            {Success}  //  Should not fail when computing CTKs for first time.
         [1] =>
            // Initialize from only incoming edge
            VN_Values := Op_Ctx.Edge_Values[In_Edges[1]]
         [..] =>
            // Merge incoming edge value mappings
            VN_Values := []
           *VN_Loop*
            for each [V => VSet] of Op_Ctx.Edge_Values[In_Edges[1]] loop
               var Merged_VSet := VSet
               for Edge_Index in 2 .. |In_Edges| loop
                  ref This_Edge_Vals => Op_Ctx.Edge_Values[Edge_Index]

                  if V not in This_Edge_Vals then
                     // VN missing from this edge, so that means no restriction
                     continue loop VN_Loop
                  end if

                  //  Union in the values from this edge
                  {Value_Kind(Merged_VSet) == Value_Kind(This_Edge_Vals[V])}
                  Merged_VSet |= This_Edge_Vals[V]
               end loop
               // Store the merged set
               VN_Values[V] := Merged_VSet
            end loop VN_Loop
      end case

      //  Propagate values

      //  Walk instructions of basic block looking for assertions
      for I in BB_Node.First .. BB_Node.Last loop
         if I in Op_Ctx.Instr_To_Assertions_Map then
            ref Assertions => Op_Ctx.Instr_To_Assertions_Map[I]
            var Updated_VNs : VN_Set := []

            const Instr := Op_Ctx.Routine.Nth_Instr(I)

            //  "and" each of the assertions into its associated
            //  value set.
            for each Asrt of Assertions loop
               var Val : optional Value_Set+ for VN_Values := Assert_Is_True

               if Debug_Verbose then
                  Println(" Asserting: VN" | Asrt | ":" |
                    Op_Ctx.VNT[Asrt] | " is True")
               end if

               if Asrt in VN_Values then
                  Val and= VN_Values[Asrt]
                  if Is_Empty(Val) then
                     //  Empty set means that the check is certain to fail.
                     //  Report that fact.
                     Report_Failure(Op_Ctx, Instr, Asrt);

                     //  Don't update the entry in VN_Values
                     Val := null  //  Recover space -- TBD: shouldn't be needed
                     continue loop
                  end if
               end if

               if Asrt not in VN_Values
                 or else Val != VN_Values[Asrt]
               then
                  //  Value is changed, add Asrt to Updated_VNs
                  if Debug_Verbose then
                     Println(" New value set for VN" | Asrt | " is " |
                       To_String(Val))
                  end if
                  VN_Values[Asrt] <== Val
                  Updated_VNs |= Asrt
               else
                  Val := null  //  Recover space -- TBD: shouldn't be needed
               end if

            end loop

            if not Is_Empty(Updated_VNs) then
               //  Propagate to other VNs
               //  First propagate top down (from VN to its children)
               const VNs_To_Recompute :=
                 Propagate_Top_Down(Op_Ctx, VN_Values, Updated_VNs)

               //  Then propagate bottom up (from VN to its parents)
               //  Propagate_Bottom_Up returns #false on failure
               if VNs_To_Recompute is null
                 or else not Propagate_Bottom_Up
                        (Op_Ctx, VN_Values, VNs_To_Recompute)
               then
                  //  Report a failure and then go to next instruction.
                  //  TBD: Picking the first of Updated_VNs is arbitrary.
                  Report_Failure(Op_Ctx, Instr, First(Updated_VNs));
                  continue loop
               end if

            end if
         end if
      end loop

      //  Assert edge condition on each outgoing edge and then
      //  create a new VN-to-value-set map, and if different from
      //  prior one, add successor to Predecessor_Changed
      ref Out_Edges => BB_Node.Outgoing_Edges

      for each E of Out_Edges forward loop
         const To_Node_Id := Op_Ctx.CFG.Nth_Edge(E).To
         const First_Instr := Op_Ctx.CFG[To_Node_Id].First
         var New_Edge_Values for Op_Ctx.Edge_Values := VN_Values

         if E in Op_Ctx.Edge_Condition
           and then E not in Op_Ctx.Dead_Edges
         then
            ref Cond_VN => Op_Ctx.Edge_Condition[E]
            const Cond_Is_True : Value_Set+ for New_Edge_Values :=
              Assert_Is_True

            if Debug_Verbose then
               Println("Doing outgoing edge: " | E |
                " (BB" | BB | "->BB" | To_Node_Id | ")")
               Println(" Asserting on edge: VN" | Cond_VN | ":" |
                 Op_Ctx.VNT[Cond_VN] | " is True")
            end if

            if Cond_VN in New_Edge_Values then
               //  "And" in the new condition
               const Orig_Vals := New_Edge_Values[Cond_VN]

               New_Edge_Values[Cond_VN] and= Cond_Is_True

               if Debug_Verbose
                 and then Orig_Vals != New_Edge_Values[Cond_VN]
               then
                  Println(" New value set for VN" | Cond_VN |
                          " is " | To_String(New_Edge_Values[Cond_VN]))
               end if

               //  Give a warning if this makes the edge dead
               if Is_Empty(New_Edge_Values[Cond_VN]) then
                  //  Remember that edge is dead
                  Op_Ctx.Dead_Edges |= E
                  Put_Warning("Edge " | E | " is dead; cannot reach here",
                    Source_Pos =>
                      Op_Ctx.Routine.Nth_Instr(First_Instr).Source_Pos())
               end if
            else
               if Debug_Verbose then
                  Println(" New value set for VN" | Cond_VN |
                          " is " | To_String(Cond_Is_True))
               end if
               New_Edge_Values[Cond_VN] := Cond_Is_True
            end if
            if E not in Op_Ctx.Dead_Edges
              and then
                (Cond_VN not in VN_Values
                 or else New_Edge_Values[Cond_VN] != VN_Values[Cond_VN])
            then
               //  Propagate to other VNs
               const VNs_To_Recompute :=
                 Propagate_Top_Down(Op_Ctx, New_Edge_Values, [Cond_VN])

               if VNs_To_Recompute is null
                 or else not Propagate_Bottom_Up
                              (Op_Ctx, New_Edge_Values, VNs_To_Recompute)
               then
                  //  Edge is dead, detected either on top-down or bottom-up
                  //  propagation.
                  Op_Ctx.Dead_Edges |= E
                  Put_Warning("Edge " | E | " is dead; cannot reach here",
                    Source_Pos =>
                      Op_Ctx.Routine.Nth_Instr(First_Instr).Source_Pos())
               end if
            end if
         end if

         if not Is_Equal(New_Edge_Values, Op_Ctx.Edge_Values[E]) then
            //  Edge values have changed, update saved edge values
            Op_Ctx.Edge_Values[E] <== New_Edge_Values
            //  Remember that predecessor changed
            Predecessor_Changed |= To_Node_Id
         else
            //  Recover space (TBD: Should not be necessary)
            New_Edge_Values := null
         end if
      end loop
      
   end func Propagate_Values

   func Analyze_Operation
     (Op_Count : Univ_Integer; Item : Reflection::Decl) is
      //  Analyze one operation

      const Routine := Routine_For_Operation(Item);

      const Instr_Indices : Countable_Range<Code_Index> :=
        1 .. Routine.Num_Instrs()  //  Range of indices for current operation

      // Compute name
      const Module_Name := Reflection::Routine::Module_Name(Routine);
      var Op_Name := Id(Item);

      var Full_Name := Op_Name;
      if Module_Name not null and then Module_Name != "" then
         Full_Name := Module_Name | "::" | Op_Name;
      end if

      //  For overloading
      const Homonyms := Num_Prior_Homonyms(Item);
      if Homonyms > 0 then
         Full_Name |= "#" | (Homonyms+1)
      end if

      //  Establish a context for analysis
      ref var Op_Ctx : Analysis::Op_Ctx =>
        (Routine => Routine, Pass => #find_basic_blocks)

      //  First instruction starts a node
      Op_Ctx.Node_Starts |= Instr_Indices.First

      //  Analyze intructions in this routine, first pass (find basic blocks)
      for I in Instr_Indices forward loop
         Analyze_One_Instr(Op_Ctx, Routine, I);
      end loop

      //  Last exit/return of operation/nested block becomes an exit node
      Op_Ctx.Node_Starts |= Op_Ctx.Last_End_Instr
      Op_Ctx.CFG_Ends |= Op_Ctx.Last_End_Instr

      //  Build up CFG
      Op_Ctx.Pass := #build_cfg

      Op_Ctx.Cur_Entry_Node := null
      for I in Op_Ctx.Node_Starts forward loop
         //  Create node and fill in "First" instr and add to instr->node map
         const New_Node_Id := Op_Ctx.CFG.Add_Node()
         Op_Ctx.CFG[New_Node_Id].First := I
         Op_Ctx.Instr_To_Node_Map |= [I => New_Node_Id]

         if Op_Ctx.Cur_Entry_Node is null then
            //  This is an entry node
            Op_Ctx.Cur_Entry_Node := New_Node_Id
            Op_Ctx.CFG_Entry_Nodes |= New_Node_Id
         end if

         if I in Op_Ctx.CFG_Ends then
            //  This is an exit node
            Op_Ctx.CFG_Exit_Nodes |= New_Node_Id
            Op_Ctx.Entry_Node_To_Exit_Node_Map |=
              [Op_Ctx.Cur_Entry_Node => New_Node_Id]
            Op_Ctx.Cur_Entry_Node := null
         end if
      end loop

      //  Each CFG should have reached an exit node,
      //  so Cur_Entry_Node should now be null.
      {Op_Ctx.Cur_Entry_Node is null}

      //  Analyze intructions in this routine, second pass (build cfg)
      for I in Instr_Indices forward loop
         Analyze_One_Instr(Op_Ctx, Routine, I);
      end loop

      {|Op_Ctx.CFG| > 0}

      for N in Op_Ctx.CFG.All_Nodes() loop
         ref N_Node => Op_Ctx.CFG[N]
         if |N_Node.Incoming_Edges| == 0
           and then N != CFG::First_Node_Id
         then
            Println(" *** Node " | N | " (instrs " |
              N_Node.First | "-" | N_Node.Last | ") has no incoming edges")
         end if
      end loop

      const RPO_Order := Reverse_Postorder(Op_Ctx.CFG)
      if Debug then
         Print("Reverse Post-order of CFG:")
         for N => RPO_Order then N.Next while N not null loop
            Print(" " | N.Id)
         end loop
         Print('\n')
      end if

      Compute_Dominator_Tree(Op_Ctx.CFG)

      ref DT => Get_Dominator_Tree(Op_Ctx.CFG)

      //  Display control flow graph and dominator info
      Println("Dumping graph cfg" | Op_Count |
        ".gv for " | Full_Name)
      var IO := IO::Get_IO()
      var File : File_Output_Stream :=
        IO.Create("cfg" | Op_Count | ".gv")
      var Edge_Attrib_Map : Map<CFG::Edge_Id, Univ_String> := []
      //  Use "dashed" "forestgreen" lines for invocations of nested blocks
      //  Use "dotted" "red" lines for exit from nested blocks
      for E in Op_Ctx.CFG.All_Edges() loop
         ref Edge => Op_Ctx.CFG.Nth_Edge(E)
         if Edge.To in Op_Ctx.CFG_Entry_Nodes then
            Edge_Attrib_Map |= [E => "style=dashed,color=forestgreen"]
         end if
         if Edge.From in Op_Ctx.CFG_Exit_Nodes then
            Edge_Attrib_Map |= [E => "style=dotted,color=red"]
         end if
      end loop

      var Node_Attrib_Map : Map<CFG::Node_Id, Univ_String> := []
      //  Make headers of nested blocks "plum" color
      for N in Op_Ctx.CFG_Entry_Nodes loop
         if |Op_Ctx.CFG[N].Incoming_Edges| > 0 then
            //  An entry node that is not *the* entry node
            Node_Attrib_Map |= [N => "style=filled,fillcolor=plum"]
         end if
      end loop

      //  Dump the CFG with dominator tree and dominance frontier
      File.Dump_Graph(Op_Ctx.CFG, Routine, Full_Name,
        Node_Attrib_Map, Edge_Attrib_Map, DT => DT)
      File.Close()

      //  Value number the subprogram:
      //  For each distinct address value-number, we might have a distinct
      //  value in a given basic block.
      //  We need to know whether two objects with different address
      //  value-numbers might be aliased.  This is equivalent to asking
      //  whether their address value-numbers might be equal at run-time.
      //  This will generally come down to equality checks between indices.
      //  Note that operations that return "ref"s are the way that address
      //  value numbers are produced.
      //  
      //  Rather than creating "phi"s it would be nice to create phi-as-kappas
      //  directly.  This means having path conditions for each incoming
      //  edge of a join point, relative to the dominator of the join point.
      //  This implies maintaining in every basic block the path condition,
      //  organized by dominator.
      //
      //  Most value numbers will represent the result of a call.
      //  Class aggregates are one exception to this; these are best modeled
      //  as a series of assignments to selected components.
      //  If a call has exactly one output, or no outputs and one "var" param,
      //  then it makes sense to represent it directly by the call info.
      //  If it has multiple outputs, then it is probably worth creating
      //  a node that represents the set of outputs, and then selectors
      //  from that set on top.
      //  Selection is another exception to this; selection produces an
      //  address value number, then the "fetch" produces a derived value
      //  if the enclosing object has a new value number.

      //  Initialize the Input_VNs:
      //    NOTE: Nested blocks will be walked as part of enclosing routine.
      //    For each Input parameter, create an Input_VN for its value.
      //    Enter this Input_VN into the mapping from Addr_VN to value.

      Op_Ctx.VNT := []
      const Null_Lit := Null_Literal_VN::()
      Op_Ctx.Null_VN := Op_Ctx.VNT.Get_Unique_Id(Null_Lit)

      Op_Ctx.Addr_To_OID_Map := []
      Op_Ctx.OID_To_VN_Map := []

      for each [P => Info] of Parameters(Routine)
        {not Info.Is_Operation_Output} forward loop
         // Create an Input_VN if not an output
         const Source_Pos := Source_Pos (Op_Ctx.Routine.Nth_Instr(1));
         var Input_Addr := Op_Ctx.VNT.Get_Unique_Id
            (Param_Addr_VN::
               (Level => Level_Of_BB(Op_Ctx, DT.Root()),
                BB_Id => Entry_Node_For_BB(Op_Ctx, DT.Root()),
                Offset => P-1))
         if Info.Is_Passed_By_Ref then
            // Level of indirection
            const Deref_Of_Param := Op_Ctx.VNT.Get_Unique_Id
               (Input_VN::(Input_Addr => Input_Addr))

            Store_Value(Op_Ctx, Input_Addr, New_Val => Deref_Of_Param,
              Source_Pos => Source_Pos,
              Origin => Input_Origin::(Input_Addr => Input_Addr))

            // Now use Deref_Of_Param as address
            Input_Addr := Deref_Of_Param
         end if
         const Input_Value := Op_Ctx.VNT.Get_Unique_Id
            (Input_VN::(Input_Addr => Input_Addr))

         Store_Value(Op_Ctx, Input_Addr, New_Val => Input_Value,
           Source_Pos => Source_Pos,
           Origin => Input_Origin::(Input_Addr => Input_Addr))
      end loop

      if Debug then
         //  Dump the address-to-oid-to-value maps
         Println("Before value numbering " | Full_Name)
         Dump_Addr_OID_Value_Maps(Op_Ctx)
      end if

      //  Analyze intructions in this routine, third pass (value number).
      //  Walk basic blocks in reverse postorder, so blocks will follow
      //  their non-back-edge predecessors.
      Op_Ctx.Pass := #value_number
      for N => DT.Reverse_Postorder() then N.Next while N not null loop
         ref BB => Op_Ctx.CFG[N.Id]
         for I in BB.First .. BB.Last forward loop
            Analyze_One_Instr(Op_Ctx, Routine, I);
         end loop
      end loop

      //  Determine which VNs are compile-time-known
      //  NOTE: We are taking advantage of the fact that the children
      //        of a VN have lower numbers than the VN, so a "forward" loop
      //        here does things in the right order.
      for each [Id => VN] of Op_Ctx.VNT forward loop
         // Check if can be compile-time known
         case VN of
            [Param : Param_Addr_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Input : Input_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Local : Local_Addr_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Component : Component_Addr_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Unknown : Unknown_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Phi : Phi_VN] =>
               //  Cannot be compile-time known
               //  TBD: This might change some day
               continue loop
            [..] =>
               null
         end case

         const Children := Child_Vec(VN)
         if Is_Literal_VN(Op_Ctx.VNT, Id)
           or else Children is null
           or else (for all C of Children => C in Op_Ctx.CTK_VNs)
         then
            
            Op_Ctx.CTK_VNs |= Id
         end if
      end loop

      if Debug then
         //  Dump the address-to-oid-to-value maps
         Println("After value numbering " | Full_Name)
         Dump_Addr_OID_Value_Maps(Op_Ctx)
      end if

      if Debug then
         //  Indicate which instructions have assertions to be proved
         var Max_VN : VN_Id := null

         Println("Assertions associated with instructions:")
         for each [I => Assertions_Vec] of Op_Ctx.Instr_To_Assertions_Map
           forward loop
            Debugging::Dump_One_Instr
              (IO.Stdout, Routine.Nth_Instr(I), Indent => 1)
            for each Assert of Assertions_Vec forward loop
               //  Remember max VN seen in an assertion
               Println("  Assert: VN" | Assert)
               Max_VN := Max(Max_VN, Assert)
            end loop
         end loop
         Println("Conditions associated with edges:")
         for each [E => V] of Op_Ctx.Edge_Condition forward loop
            Println(" Edge: " | E | " => VN" | V)
            Max_VN := Max(Max_VN, V)
         end loop
         Dump_VNT(Op_Ctx, Max_VN)
      end if

      //  Now begin value-set propagation to produce a map
      //  of value-number to value-set for each edge in the graph.
      //  Then we will produce warnings for any checks that are not
      //  certain to pass given the saved value-set maps for the edges.

      //  Initialize mapping of VNs to Value-sets for each edge
      Op_Ctx.Edge_Values := Create(Op_Ctx.CFG.All_Edges(), [])

      //  Initialize mapping of VNs to the set of their immediate parent VNs
      Op_Ctx.VN_To_Parent_Set_Map := Create(Op_Ctx.VNT.All_Ids(), [])
      for each [Id => VN] of Op_Ctx.VNT loop
         //  Add Id to parent set of each child of VN
         const Children := VN.Child_Vec()

         if Children not null then
            for each C of Children {C not null} loop
               Op_Ctx.VN_To_Parent_Set_Map[C] |= Id
            end loop
         end if
      end loop

      //  Iterate over basic blocks, in each iteration we walk in reverse
      //  post-order those blocks with changed predecessors.
      for To_Be_Processed : Node_Set :=
          CFG::First_Node_Id .. Op_Ctx.CFG.Last_Node_Id()
        while not Is_Empty(To_Be_Processed)
      loop
         var Predecessor_Changed : Node_Set := []
         //  Set of nodes whose predecessors have changed

         //  Walk nodes in reverse postorder, propagating value sets.
         //  Only process those with a changed predecessor.
         for N => DT.Reverse_Postorder() then N.Next while N not null loop
            if N.Id in To_Be_Processed or else N.Id in Predecessor_Changed then
               Propagate_Values(Op_Ctx, N.Id, Predecessor_Changed)
            end if
         end loop

         continue loop with Predecessor_Changed
      end loop

   end func Analyze_Operation

   //  Analyze the declaration if it resides in the given source file
   func Analyze_One_Decl(var Op_Count : Univ_Integer; File_Name : String;
      Item : Reflection::Decl) -> Int is

      if Item is null or else
         (Context(Item) == #inherited or
          Kind(Item) == #type or
         (Kind(Item) == #operation
            and then Operation_Equiv_To(Item) not null) or
          File(Decl_Source_Pos(Item)) != File_Name) then
         return 0;
      end if

      var Count := 0;

      const Region := not Is_Spec(Item) and Kind(Item) == #operation?
                      Body_Region(Item) : Decl_Region(Item)
      if not Is_Spec(Item) and Kind(Item) == #module then
         const Spec := Spec(Item);
         if File(Decl_Source_Pos(Spec)) == File(Decl_Source_Pos(Item)) then
            //  This prevents double defining when interface and class
            //  are in the same file
            return Count;
         end if
      end if

      func Recurse_On_Region(R : Reflection::Region) is
         for I in 1 .. Num_Items(R) forward loop
            if Debug_Verbose then
               const Next_Item := R.Nth_Item(I);
               const This_Mod := Module_Name(Item);
               if Next_Item not null then
                  Println("Recursing from " |
                     Kind(Item) | " " |
                     (This_Mod is null? "" : This_Mod | "::") |
                     Id(Item) | " to " |
                     (Next_Item is null? "" : To_String(Kind(Next_Item))
                        | " ") |
                     (Next_Item is null or else
                        Module_Name(Next_Item) is null? ""
                        : Module_Name(Next_Item) | "::") |
                     (Id(Next_Item) is null? "null" : Id(Next_Item)));
               end if
            end if
            Count += Analyze_One_Decl(Op_Count, File_Name, R.Nth_Item(I));
         end loop
      end func Recurse_On_Region

      //  Recurse on this region, its nested region, and siblings.
      func Recurse_On_Nested_Regions(R : Reflection::Region) is
         if R not null then
            Recurse_On_Region(R);

            case Kind(R) of
               [#Module_Region_Kind | #Operation_Param_Region_Kind] =>
                  //  We don't need to recurse on the nested regions
                  //  because that is implicit in processing the nested
                  //  items.
                  null

               [..] =>
                  //  Recurse on the nested regions, because these aren't
                  //  necessarily reached from the items of the current region.
                  for I in 1 .. Num_Nested_Regions(R) forward loop
                     const Nested := R.Nth_Nested_Region(I);
                     if Nested not null then 
                        Recurse_On_Nested_Regions(Nested);
                        
                        var Sibling := Sibling_Region(Nested);
                        while Sibling not null loop
                           Recurse_On_Nested_Regions(Sibling);
                           Sibling := Sibling_Region(Sibling);
                        end loop;
                     end if
                  end loop
            end case
         end if
      end func Recurse_On_Nested_Regions;

      Recurse_On_Nested_Regions(Region);

      case Kind(Item) of
         [#object] =>
            const Val := Value_Of_Global_Const(Item);
            if Val not null then
               Count += 1
            end if
         [#operation] => 
            if Is_Spec(Item) then
               //  operation specs have no code, and "equiv_to" are not
               //  of interest
               return Count;
            end if

            Op_Count += 1
            Analyze_Operation(Op_Count, Item)
            Count += 1;
         [..] => null;
      end case;
      return Count;
   end func Analyze_One_Decl;

 exports

   func Is_Literal_VN(VN_Table; VN : VN_Id) -> Boolean is
      //  Return #true if VN is the value number for a literal VN
      case VN_Table[VN] of
         [Lit_VN : Literal_VN+] => return #true
         [..] => return #false
      end case
   end func Is_Literal_VN

   func Int_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_Integer is
      //  Return value of int literal, or null if VN is not an int-literal VN
      case VN_Table[VN] of
         [Lit_VN : Int_Literal_VN] => return Lit_VN.Value
         [..] => return null
      end case
   end func Int_Literal_Value

   func Enum_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_Enumeration is
      //  Return value of enum literal, or null if VN is not an enum-literal VN
      case VN_Table[VN] of
         [Lit_VN : Enum_Literal_VN] => return Lit_VN.Value
         [..] => return null
      end case
   end func Enum_Literal_Value

   func Str_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_String is
      //  Return value of string lit, or null if VN is not an str-literal VN
      case VN_Table[VN] of
         [Lit_VN : String_Literal_VN] => return Lit_VN.Value
         [..] => return null
      end case
   end func Str_Literal_Value

   func Get_Int_Literal_VN(var VN_Table; Int_Val : Univ_Integer) -> VN_Id is
      //  Return Int_Literal_VN for given int value
      return VN_Table.Get_Unique_Id (Int_Literal_VN::(Value => Int_Val))
   end func Get_Int_Literal_VN

   func Get_Bool_Literal_VN(var VN_Table; Bool_Val : Boolean) -> VN_Id is
      //  Return Bool_Literal_VN for given bool value
      return VN_Table.Get_Unique_Id (Bool_Literal_VN::(Value => Bool_Val))
   end func Get_Bool_Literal_VN

   func Boolean_Vals(VN_Values : VN_To_Value_Set_Map_Type; VN : VN_Id)
     -> Boolean_Value_Set is
      //  Return stored Boolean_Value_Set of VN, or return an anything-goes
      //  value set (Might be null/true/false) if nothing stored yet.
      if VN in VN_Values then
         ref Vals => VN_Values[VN]

         case Vals of
          [B : Boolean_Value_Set] =>
            return B

          [C : Countable_Value_Set] =>
            //  Convert countable to boolean
            return Boolean_Value_Set::(Might_Be_Null => Vals.Might_Be_Null,
                                       Might_Be_True =>
                                         1 in C.Possible_Values,
                                       Might_Be_False =>
                                         0 in C.Possible_Values)

          [..] => 
            //  Preserve might-be-null ness
            return Boolean_Value_Set::(Might_Be_Null => Vals.Might_Be_Null,
                                       Might_Be_True => #true,
                                       Might_Be_False => #true)
         end case
      end if
      //  Anything goes
      return Boolean_Value_Set::(Might_Be_Null => #true,
                                 Might_Be_True => #true,
                                 Might_Be_False => #true)
   end func Boolean_Vals

   func Countable_Vals(VN_Values : VN_To_Value_Set_Map_Type; VN : VN_Id)
     -> Countable_Value_Set is
      //  Return stored Countable_Value_Set of VN, or return an anything-goes
      //  value set (Might be null/-inf .. +inf) if nothing stored yet.
      if VN in VN_Values then
         ref Vals => VN_Values[VN]

         case Vals of
          [C : Countable_Value_Set] =>
            //  Return countable set
            return C

          [..] => 
            //  Preserve might-be-null ness
            return Countable_Value_Set::(Might_Be_Null => Vals.Might_Be_Null)
         end case
      end if
      //  Anything goes
      return Countable_Value_Set::(Might_Be_Null => #true)
   end func Countable_Vals

   func Put_Error (Message : Univ_String;
     Source_Pos : optional Reflection::Source_Position;
     Message_Kind : Univ_String := "Error") is
   //  Put out an error message on the standard error stream
   
      var IO := IO::Get_IO();
      if Source_Pos not null then
         IO.Stderr.Println(Source_Pos | ": " | Message_Kind | ": " | Message)
         if Msg_File_Name not null then
            //  Append message to Msg_File
            var Msg_File := File_Output_Stream::Append(IO, Msg_File_Name)
            if Msg_File not null then
               Msg_File.Println(Source_Pos | ": " |
                 Message_Kind | ": " | Message)
               Msg_File.Close()
            end if
         end if
      else
         IO.Stderr.Println(Message_Kind | ": " | Message)
      end if
   end func Put_Error

   func Compare_VN_Vectors(Left, Right : Vector<VN_Id>) -> Ordering is
      if Length(Left) != Length(Right) then
         return Length(Left) =? Length(Right);
      else
         for (each L of Left; each R of Right) forward loop
            if L != R then
               return L =? R;
            end if;
         end loop;
         return #equal;
      end if;
   end func Compare_VN_Vectors;

   func Analyze(File_Name : String) is
      //  Analyze the code (if any) in the file named File_Name
      var Op_Count := 0

      var Env := Reflection::Environment::Get_Current_Env()

      var Count := 0;

      for I in 1 .. Env.Num_Library_Items() forward loop
         const Item := Env.Nth_Library_Item(I);
        
         Count += Analyze_One_Decl(Op_Count, File_Name, Item)
      end loop

      if Count == 0 then
         Put_Warning("File not found (or contains no executable code): " |
           File_Name);
      end if

   end func Analyze
end class PSC::Analysis;

func Analyze(Files : Basic_Array<String>) is
   if PSC::Analysis::Msg_File_Name not null then
      //  Initialize the message file
      var IO := IO::Get_IO()
      var Msg_File :=
        File_Output_Stream::Create(IO, PSC::Analysis::Msg_File_Name)
      if Msg_File is null then
         IO.Stderr.Println("Cannot create message file \"" |
           PSC::Analysis::Msg_File_Name | '"')
      else
         Msg_File.Close()
      end if
   end if

   for each F of Files concurrent loop
      //if Analysis::Debug then
      Println("Analyzing " | F);
      //end if
      PSC::Analysis::Analyze(F)
      Println("Done with " | F);
   end loop
end func Analyze
