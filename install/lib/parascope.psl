// ParaScope: ParaSail Static Catcher of Programming Errors

// Copyright (C) 2011-2016, AdaCore, New York, NY
// This program is provided "as is" with no warranty.
// Report errors at http://groups.google.com/group/parasail-programming-language

import PSC::Reflection

class PSC::CFG is
   var Nodes : Vector<Node> := []
   var Edges : Vector<Edge> := []
   var Roots : Node_Set := [1]
   var Dom_Tree : optional Dominator_Tree := null

   const Debug_CFG : Boolean := #false
   const Debug_CFG_Verbose : Boolean := #false

   func Contains(Str, Substr : Univ_String) -> Boolean is
     //  Return #true if Substr appears within Str somewhere
     //  TBD: This should be in Univ_String module, perhaps as "in"
      const Str_Len := |Str|
      const Sub_Len := |Substr|
      for I in 1 .. Str_Len - Sub_Len + 1 loop
         if Str[I ..< I + Sub_Len] == Str then
            return #true
         end if
      end loop
   end func Contains

  exports

   op "[]"() -> CFG is
   //  Create an empty control-flow graph
      return ()
   end op "[]"

   func Add_Node(var CFG) -> Node_Id is
   //  Add node to control-flow graph
      CFG.Nodes |= (Incoming_Edges => [], Outgoing_Edges => [])
      CFG.Dom_Tree := null  //  Reset dominator tree to null
      return Node_Id::(|CFG.Nodes|)
   end func Add_Node

   func Last_Node_Id(CFG) -> Node_Id is
      return Node_Id::(|CFG.Nodes|)
   end func Last_Node_Id

   func Add_Edge(var CFG; From, To : Node_Id) -> Result : Edge_Id is
   //  Add edge to control-flow graph
      CFG.Edges |= (From => From, To => To)
      Result := Edge_Id::(|CFG.Edges|)

      //  Keep track of incoming and outgoing edges
      CFG.Nodes[From].Outgoing_Edges |= Result
      CFG.Nodes[To].Incoming_Edges |= Result

      CFG.Dom_Tree := null  //  Reset dominator tree to null
   end func Add_Edge

   func Remove_Edge(var CFG; E : Edge_Id) is
   //  Remove edge from Incoming_Edges and Outgoing_Edges of To/From nodes
      ref Edge => CFG.Edges[E]

      //  Replace Outgoing_Edges vector with all but those matching E
      var Old_Outgoing <== CFG.Nodes[Edge.From].Outgoing_Edges
      CFG.Nodes[Edge.From].Outgoing_Edges :=
        [for each Old_Edge of Old_Outgoing {Old_Edge != E} forward => Old_Edge]

      //  Replace Incoming_Edges vector with all but those matching E
      var Old_Incoming <== CFG.Nodes[Edge.To].Incoming_Edges
      CFG.Nodes[Edge.To].Incoming_Edges :=
        [for each Old_Edge of Old_Incoming {Old_Edge != E} forward => Old_Edge]
   end func Remove_Edge

   func Last_Edge_Id(CFG) -> Edge_Id is
      return Edge_Id::(|CFG.Edges|)
   end func Last_Edge_Id

   func Nth_Node(ref CFG; Node_Id) -> ref Node is
   //  Return reference to Node given Node_Id
      return CFG.Nodes[Node_Id]
   end func Nth_Node

   func Nth_Edge(ref CFG; Edge_Id) -> ref Edge is
   //  Return reference to Edge given Edge_Id
      return CFG.Edges[Edge_Id]
   end func Nth_Edge

   func Add_Root(var CFG; Root : Node_Id) is
   //  Add another Node to the set of roots
      CFG.Roots |= Root
   end func Add_Root

   func Roots(ref CFG) -> ref Node_Set is
   //  Return reference to set of root nodes
      return CFG.Roots
   end func Roots

   func Successors(CFG; Node_Id) -> Vector<Node_Id> is
      return [for each E of CFG[Node_Id].Outgoing_Edges => CFG.Edges[E].To]
   end func Successors

   func Predecessors(CFG; Node_Id) -> Vector<Node_Id> is
      return [for each E of CFG[Node_Id].Incoming_Edges => CFG.Edges[E].From]
   end func Predecessors

   func Reverse_Postorder
     (CFG; Connected_Nodes_Only : Boolean := #false)
     -> Result : optional Node_List is
     //  Return list of all nodes (or Connected_Nodes_Only if #true)
     //  in a reverse postorder 
      var Visited : Bit_Set<Node_Id> := Create(CFG.All_Nodes(), #false)
      var Visiting : Array<Node_Id, Indexed_By => Univ_Integer> :=
        Create(1 .. Last_Node_Id(CFG), 0)
      var Num_Edges_To_Traverse : Array<Univ_Integer,
                                    Indexed_By => Univ_Integer> :=
        Create(1 .. Last_Node_Id(CFG), 0)
      var Num_Visiting := 0

      func Push_Node(Id : Node_Id) is
         //  Add node to stack, unless already visited
         if Id not in Visited then
            //  Remember we have visited this node
            Visited |= Id
            //  Add Id to top of stack, along with its count of edges
            Num_Visiting += 1
            Visiting[Num_Visiting] := Id
            Num_Edges_To_Traverse[Num_Visiting] := |CFG[Id].Outgoing_Edges|
         end if
      end func Push_Node

      Result := null

      const Nodes_To_Visit := Connected_Nodes_Only? CFG.Roots() :
                                All_Nodes(CFG).First .. All_Nodes(CFG).Last
         //  If Connected_Nodes_Only is #false, then make sure to visit
         //  each node, even if graph is not fully connected

      for N in Nodes_To_Visit forward loop

         Push_Node(N)

         //  Loop until stack is empty
         while Num_Visiting > 0 loop
            ref Edge_Index => Num_Edges_To_Traverse[Num_Visiting]
            const Top_Node := Visiting[Num_Visiting]

            if Edge_Index == 0 then
               //  Done walking successors of top node.
               //  Add top node to front of reverse post-order
               Result := (Id => Top_Node, Next <== Result)

               //  Pop the stack
               Num_Visiting -= 1

            else
               //  Add another successor of Top_Node to stack
               //  NOTE: We traverse the edges of a node in reverse order
               //        so that in reverse post-order nodes typically end
               //        up in forward order.
               Push_Node
                 (CFG.Nth_Edge
                   (CFG[Top_Node].Outgoing_Edges[Edge_Index]).To)

               //  One less edge to traverse
               Edge_Index -= 1
            end if
         end loop

      end loop

      {|CFG| > 0 ==> Result not null}
   end func Reverse_Postorder

   func Dump_Graph(var File : Output_Stream+; CFG;
     Reflection::Routine; Label : Univ_String;
     Node_Attrib_Map : Map<CFG::Node_Id, Univ_String> := [];
     Edge_Attrib_Map : Map<CFG::Edge_Id, Univ_String> := [];
     DT : optional Dominator_Tree) is

      func Node_Name(N : Node_Id) -> Univ_String is
         //  Return node name to uniquely identify node with given Node_Id
         ref N_Node => CFG[N]
         return "BB" | N
      end func Node_Name

      func Node_Label(N : Node_Id) -> Univ_String is
         //  Return label to be displayed for node with given Node_Id
         ref N_Node => CFG[N]
         return "BB`(N): I`(N_Node.First)-I`(N_Node.Last),\n" |
           "L`(Source_Pos(Routine.Nth_Instr(N_Node.First)).Line())-L" |
           Source_Pos(Routine.Nth_Instr(N_Node.Last)).Line()
      end func Node_Label

      File.Println
        ("digraph G {\n label = \"`(Label.Replace('"', With => '$'))\";")
      //  Indicate the root node
      File.Println(" root = " |
        Node_Name(DT not null? DT.Primary_Root() : CFG::First_Node_Id) | ";")

      for E in CFG.All_Edges() loop
         ref Edge => CFG.Nth_Edge(E)
         var Style : Univ_String := ""
         if E in Edge_Attrib_Map then
            Style := "[label=E`(E),`(Edge_Attrib_Map[E])]"
         else
            Style := "[label=E`(E)]"
         end if
         File.Println(" `(Node_Name(Edge.From)) -> " |
                            Node_Name(Edge.To) | Style | ";")
      end loop

      for N in CFG.All_Nodes() forward loop
         var Style := ""
         if N in Node_Attrib_Map then
            Style := "," | Node_Attrib_Map[N]
         end if

         File.Println(" " | Node_Name(N) |
           "[label=\"`(Node_Label(N))\"`(Style)];")
      end loop

      //  Add edges to represent the dominator tree, if DT not null
      if DT not null then
         for N in CFG.All_Nodes() {DT.Is_Connected(N)} forward loop
            ref DF => DT.Dominance_Frontier(N)
            const Idom := DT.Immediate_Dominator(N)
            const Encl_Loop := DT.Enclosing_Loop(N)

            ref BB => CFG[N]
            const BB_Graph_Id := Node_Name(N)

            const DF_Image := "[" |
              (for (F in DF; Sep := "" then ", ") => <""> | Sep | F) | "]"

            if Idom != N then
               //  Use bold, blue arrows for dominator relationship;
               //  Suppress any self-dominators as they are not interesting.
               File.Println(" " | Node_Name(Idom) |
                 " -> `(BB_Graph_Id)[style=bold,color=blue];")
            end if

            //  Use dashed, light blue arrors for dominance frontier
            for F in DF loop
               File.Println(BB_Graph_Id | " -> " | Node_Name(F) |
                 "[style=dashed,color=lightblue];")
            end loop

            if DT.Is_Loop_Header(N) then
               if N not in Node_Attrib_Map
                 or else not Contains(Node_Attrib_Map[N], "fillcolor")
               then
                  //  Make loop headers pink (unless overridden)
                  File.Println(BB_Graph_Id |
                    "[style=filled,fillcolor=pink];")
               end if;

               //  Make each loop into a cluster
               File.Println("subgraph cluster_`(BB_Graph_Id){")
               File.Println("  label=\"Loop header: `(BB_Graph_Id)\";")
               for In_Loop in CFG.All_Nodes() {DT.Is_Within_Loop(In_Loop, N)}
               loop
                  File.Print(" " | Node_Name(In_Loop))
               end loop
               File.Println("\n}")
            end if

            if #false and then Encl_Loop not null then
               //  Add arrows for enclosing loop
               //  TBD: Suppressed for now
               ref Encl_Loop_Node => CFG[Encl_Loop]
               File.Println(BB_Graph_Id | " -> BB`(Encl_Loop)_" |
                 Encl_Loop_Node.First | "_" | Encl_Loop_Node.Last |
                 "[style=dashed,color=pink];")
            end if
            
         end loop
      end if
      File.Println("}")
      File.Flush()
   end func Dump_Graph

   class Dominator_Tree is
      interface Dominator_Info<> is
         // Dominator tree information
         type Order is new Integer<1 .. 100_000>  // reverse-postorder position

         var Immediate_Dominator : optional Node_Id := null
         var Immediate_Postdominator : optional Node_Id := null
         var Dominance_Frontier : Set<Node_Id> := []
         var Position : optional Order := null
         var Is_Loop_Header : Boolean := #false
         var Enclosing_Loop : optional Node_Id := null
           //  For a loop header, this is the enclosing loop, or null
           //  if this is an outermost loop.

      end interface Dominator_Info

      const Primary_Root : optional Node_Id
      const Tree_Roots : Node_Set
      const RP_Order : optional Node_List
      var Dom_Info : Array<Dominator_Info, Indexed_By => Node_Id>
      var Is_Back_Edge : Array<Boolean, Indexed_By => Edge_Id>
      var Postorder : optional Node_List := null
      
     exports

      func Dominates (Dominator_Tree; Dominator, Dominated : Node_Id)
        -> Boolean is
      //  Return true if Dominator dominates Dominated
         for Dom := Dominated
           then Dominator_Tree.Dom_Info[Dom].Immediate_Dominator
           while Dom != Dominator loop
            //  Look up the immediate-dominator chain
            if Dom in Dominator_Tree.Tree_Roots then
               //  Reached the end of the chain
               return #false
            end if
         end loop
         //  Found the dominator in the immediate-dominator chain
         return #true
      end func Dominates

      func Postdominates (Dominator_Tree;
                          Postdominator, Postdominated : Node_Id)
        -> Boolean is
      //  Return true if Postdominator postdominates Postdominated
         for Pdom := Postdominated
           then Dominator_Tree.Dom_Info[Pdom].Immediate_Postdominator
           while Pdom != Postdominator loop
            //  Look up the immediate-postdominator chain
            if Pdom ==
              Dominator_Tree.Dom_Info[Pdom].Immediate_Postdominator
            then
               //  Reached the end of the chain
               return #false
            end if
         end loop
         //  Found the postdominator in the immediate-postdominator chain
         return #true
      end func Postdominates

      func Primary_Root (Dominator_Tree) -> Node_Id
        is (Dominator_Tree.Primary_Root)
      //  Return the primary "root" of the dominator tree

      func Roots (Dominator_Tree) -> Node_Set
        is (Dominator_Tree.Tree_Roots)
      //  Return the set of roots of the dominator tree

      func Is_Connected (Dominator_Tree; Node_Id) -> Boolean is
      //  Return #true if Node is connected to the root
         return Dominator_Tree.Dom_Info[Node_Id].Position not null
      end func Is_Connected

      func Immediate_Dominator (Dominator_Tree; Node_Id) -> Node_Id is
      //  Return immediate dominator of given node.  Returns
      //  self only if node is the entry node of the CFG.
         return Dominator_Tree.Dom_Info[Node_Id].Immediate_Dominator
      end func Immediate_Dominator

      func Immediate_Postdominator (Dominator_Tree; Node_Id) -> Node_Id is
      //  Return immediate postdominator of given node.  Returns
      //  self only if node is the exit node of the CFG.
         return Dominator_Tree.Dom_Info[Node_Id].Immediate_Postdominator
      end func Immediate_Postdominator

      func Dominance_Frontier (ref const Dominator_Tree; Node_Id)
        -> ref const Set<Node_Id> is
         return Dominator_Tree.Dom_Info[Node_Id].Dominance_Frontier
      end func Dominance_Frontier

      func Reverse_Postorder(ref const Dominator_Tree)
        -> ref const Node_List is
      //  Return Node_List in Reverse Postorder for the CFG from which the
      //  control-flow graph was computed.
         return Dominator_Tree.RP_Order
      end func Reverse_Postorder

      func Postorder(ref const Dominator_Tree)
        -> ref const Node_List is
      //  Return Node_List in Postorder for the CFG from which the
      //  control-flow graph was computed.
         return Dominator_Tree.Postorder
      end func Postorder

      func Is_Loop_Header (Dominator_Tree; Node_Id) -> Boolean is
      //  Return #true if the specified node is a loop header
      //  (which is defined to be a node that has itself in its
      //  dominance frontier).
         return Dominator_Tree.Dom_Info[Node_Id].Is_Loop_Header
      end func Is_Loop_Header

      func Enclosing_Loop (Dominator_Tree; Node_Id) -> optional Node_Id is
      //  Return Node_Id of innermost loop header that (strictly) dominates
      //  the given node.  If Node_Id is itself a loop header, this is the
      //  enclosing loop, if any.  It is null if this is an outermost
      //  loop header, or the block is not inside any loop.
         return Dominator_Tree.Dom_Info[Node_Id].Enclosing_Loop
      end func Enclosing_Loop

      func Is_Within_Loop(DT : Dominator_Tree; Member, Loop_Header : Node_Id)
        -> Boolean is
      //  Return #true if Member is inside the loop headed by Loop_Header,
      //  directly or indirectly.
      //  Loop_Header is within its own loop, presuming it is a loop header.
      //  This returns false if Loop_Header is not in fact a loop header.

         return DT.Dom_Info[Loop_Header].Is_Loop_Header
           and then (for some LH := Member
                     then DT.Dom_Info[LH].Enclosing_Loop
                     while LH not null => LH == Loop_Header)
      end func Is_Within_Loop

      func Is_Back_Edge (Dominator_Tree; Edge_Id) -> Boolean is
      //  Return #true if the specified edge is a back edge
      //  (meaning its "From" is dominated by its "To" node).
         return Dominator_Tree.Is_Back_Edge[Edge_Id]
      end func Is_Back_Edge

      func Compute(var CFG) -> DT : Dominator_Tree is
        //  Compute the dominator tree for the given control-flow graph.
        //  Eliminate edges from disconnected nodes from the graph.
        //  This is based on the paper:
        //    A Simple, Fast Dominance Algorithm
        //  by: Keith D. Cooper, Timothy J. Harvey, and Ken Kennedy
        //      Rice University

        //  NOTE: we use a reverse-postorder numbering while the above paper
        //        uses a (forward) postorder numbering.

         {|CFG| > 0}
   
         func Common_Dominator (N1, N2 : Node_Id) -> Node_Id is
           //  Compute common dominator of N1 and N2
            var N1_Dom := N1
            var N2_Dom := N2
            while N1_Dom != N2_Dom loop
               
               //  Keep walking up N1's dominator chain as long as we haven't
               //  passed N2
               while DT.Dom_Info[N1_Dom].Position >
                 DT.Dom_Info[N2_Dom].Position loop
                  N1_Dom := DT.Dom_Info[N1_Dom].Immediate_Dominator
               end loop

               //  Keep walking up N2's dominator chain as long as we haven't
               //  passed N1
               while DT.Dom_Info[N2_Dom].Position >
                 DT.Dom_Info[N1_Dom].Position loop
                  N2_Dom := DT.Dom_Info[N2_Dom].Immediate_Dominator
               end loop
            end loop

            //  We found a common dominator
            return N1_Dom
         end func Common_Dominator

         func Common_Postdominator (N1, N2 : Node_Id) -> Node_Id is
           //  Compute common postdominator of N1 and N2
            var N1_Pdom := N1
            var N2_Pdom := N2
            while N1_Pdom != N2_Pdom loop
               
               //  Keep walking up N1's postdominator chain as long as
               //  we haven't passed N2
               while DT.Dom_Info[N1_Pdom].Position <
                 DT.Dom_Info[N2_Pdom].Position loop
                  N1_Pdom := DT.Dom_Info[N1_Pdom].Immediate_Postdominator
               end loop

               //  Keep walking up N2's postdominator chain as long as
               //  we haven't passed N1
               while DT.Dom_Info[N2_Pdom].Position <
                 DT.Dom_Info[N1_Pdom].Position loop
                  N2_Pdom := DT.Dom_Info[N2_Pdom].Immediate_Postdominator
               end loop
            end loop

            //  We found a common postdominator
            return N1_Pdom
         end func Common_Postdominator

         if Debug_CFG then
            Println(" Compute reverse-postorder for connected nodes only")
         end if
         const RP_Order := CFG.Reverse_Postorder(Connected_Nodes_Only => #true)
         if Debug_CFG then
            Println(" Done computing RPO")
         end if

         {RP_Order not null}

         //  Create initial dominator-tree info
         DT := (Primary_Root => CFG::First_Node_Id,
                Tree_Roots => CFG.Roots(),
                RP_Order => RP_Order,
                Dom_Info => Create(CFG.All_Nodes(), ()),
                Is_Back_Edge => Create(CFG.All_Edges(), #false))

         var Num_Connected := 0

         //  Initialize reverse-postorder Position in Dom_Info array
         for (N => RP_Order then N.Next while N not null;
              I in Dominator_Info::Order forward) loop
            DT.Dom_Info[N.Id].Position := I
            Num_Connected += 1

            //  Build up postorder as we go
            DT.Postorder := (Id => N.Id, Next <== DT.Postorder)
         end loop

         if Num_Connected < |CFG| then
            //  We have some disconnected nodes.
            //  Eliminate them from the graph
            var Edges_To_Remove : Ordered_Set<CFG::Edge_Id> := []

            if Debug_CFG then
               Println
                (" Removing edges from disconnected nodes to connected nodes")
            end if
            for N in CFG.All_Nodes()
              {DT.Dom_Info[N].Position is null}
            loop
               for each E of CFG[N].Outgoing_Edges loop
                  ref Edge_Info => CFG.Nth_Edge(E)
                  if DT.Dom_Info[Edge_Info.To].Position not null then
                     //  Found an edge from disconnected to connected.
                     Edges_To_Remove |= E
                  end if
               end loop
            end loop

            //  Remove troublesome edges
            for E in Edges_To_Remove loop
               CFG.Remove_Edge(E)
            end loop
         end if

         //  Root nodes have no predecessors, so we mark them as their own
         //  immediate dominator -- TBD: not clear this is a good idea,
         //  but the published algorithm does that!
         for R in DT.Tree_Roots loop
            DT.Dom_Info[R].Immediate_Dominator := R
         end loop

         if Debug_CFG then
            Println(" Find immediate dominators")
         end if

        *Find_Immediate_Dominators*
         loop
            var Changed : Boolean := #false

            //  Walk nodes in reverse post-order, skipping the root node(s)
            for N => RP_Order.Next then N.Next while N not null
              {N.Id not in DT.Tree_Roots}
            loop
               //  Compute a new dominator for N.Id
               var New_Idom : optional Node_Id := null

               for each Pred of Predecessors(CFG, N.Id) forward loop
                  const Pred_Idom := DT.Dom_Info[Pred].Immediate_Dominator
                  if Pred_Idom not null then
                     //  Found a predecessor that has been processed
                     if New_Idom is null then
                        //  This is the first predecessor already processed.
                        //  Start with this as the new dominator.
                        New_Idom := Pred
                     else
                        //  Second or subsequent predecessor.
                        //  Find a common dominator.
                        New_Idom := Common_Dominator(New_Idom, Pred)
                     end if
                  end if
               end loop 

               if DT.Dom_Info[N.Id].Immediate_Dominator is null
                 or else
                   New_Idom != DT.Dom_Info[N.Id].Immediate_Dominator
               then
                  //  We have a new dominator for this node
                  DT.Dom_Info[N.Id].Immediate_Dominator := New_Idom
                  Changed := #true  //  Need to iterate further
               end if
            end loop

            if not Changed then
               //  We are all done
               exit loop
            end if

         end loop Find_Immediate_Dominators

         //  Compute the postdominators starting at the end

         var Num_Null_Ipdoms := 0

         if Debug_CFG then
            Println(" Find immediate post-dominators")
         end if

        *Find_Immediate_Postdominators*
         for Num_Postdom_Iterations in 1 .. CFG.Last_Node_Id() forward loop
            var Changed : Boolean := #false

            //  Walk nodes in post-order, skipping exit nodes
            for N => DT.Postorder then N.Next while N not null loop
               //  Compute a new postdominator for N.Id
               const Succs := Successors(CFG, N.Id)

               if Debug_CFG_Verbose then
                  Print(" `(N.Id)(`(|Succs|))")
               end if

               var New_Ipdom : optional Node_Id := (|Succs| == 0? N.Id : null)
                 //  If |Succs| == 0 this is an exit node,
                 //  so make it its own immediate dominator

               for each Succ of Succs forward loop
                  const Succ_Ipdom := DT.Dom_Info[Succ].Immediate_Postdominator
                  if Succ_Ipdom not null then
                     //  Found a successor that has been processed
                     if New_Ipdom is null then
                        //  This is the first successor already processed.
                        //  Start with this as the new postdominator.
                        New_Ipdom := Succ
                     else
                        //  Second or subsequent successor.
                        //  Find a common postdominator.
                        New_Ipdom := Common_Postdominator(New_Ipdom, Succ)
                     end if
                  end if
               end loop 

               if New_Ipdom is null then
                  if Debug_CFG then
                     Println("\n ** `(N.Id) post-dom is null")
                  end if

                  Changed := #true
                  Num_Null_Ipdoms += 1
               elsif DT.Dom_Info[N.Id].Immediate_Postdominator is null
                 or else
                   New_Ipdom != DT.Dom_Info[N.Id].Immediate_Postdominator
               then
                  //  We have a new postdominator for this node
                  DT.Dom_Info[N.Id].Immediate_Postdominator := New_Ipdom
                  Changed := #true  //  Need to iterate further
               end if
            end loop

            if not Changed then
               //  We are all done

               if Debug_CFG then
                  if Debug_CFG_Verbose then
                     Print("\n")
                  end if

                  Println("Num Postdominator Iterations = " |
                    Num_Postdom_Iterations | " with " | Num_Null_Ipdoms |
                    " null Ipdoms.")
               end if

               exit loop
            end if

            if Debug_CFG_Verbose then
               Println("\n finishing iteration " | Num_Postdom_Iterations)
            end if

            if Num_Postdom_Iterations == CFG.Last_Node_Id() then
               Println(" *** Post-dominator computation halted after " |
                 Num_Postdom_Iterations)
            end if

         end loop Find_Immediate_Postdominators

         //  We will keep track of all of the loop headers
         var Loop_Headers : Node_Set := []

         if Debug_CFG then
            Println(" Compute dominance frontier")
         end if

         //  Now compute the dominance frontiers for each node.
         //  Algorithm: for each node with more than one predecessor,
         //             add it to each predecessor's dominance frontier
         //             unless the predecessor dominates the original node.
         //             Keep doing this up the immediate dominator chain
         //             until reaching the immediate dominator of the original
         //             node.
        *Compute_Dominance_Frontier*
         for N in CFG.All_Nodes() {DT.Dom_Info[N].Position not null} loop
            //  Walk connected nodes only
            if |CFG[N].Incoming_Edges| > 1 then
               //  Found a join point
               const Join_Point_Idom := DT.Dom_Info[N].Immediate_Dominator

               //  Add N to each node in dominator chain of each predecessor
               //  until it reaches the Join_Point_Idom.
               for each Pred of CFG.Predecessors(N) loop
                  //  Walk up the dominator chain
                  for Pred_Dom := Pred
                    then DT.Dom_Info[Pred_Dom].Immediate_Dominator
                    while Pred_Dom != Join_Point_Idom
                      and then N not in
                        DT.Dom_Info[Pred_Dom].Dominance_Frontier
                  loop
                     //  Add to dominance frontier of dominator of pred
                     DT.Dom_Info[Pred_Dom].Dominance_Frontier |= N
                     if Pred_Dom == N then
                        //  This must be a loop header, as it is in its own
                        //  dominance frontier
                        DT.Dom_Info[N].Is_Loop_Header := #true
                        Loop_Headers |= N
                     end if
                  end loop
               end loop
            end if
         end loop Compute_Dominance_Frontier

         if Debug_CFG then
            Println(" Find natural loops")
         end if

         //  Walk loop headers and build up natural loops by walking
         //  down all back edges.
        *Find_Enclosing_Loops*
         for LH in Loop_Headers loop
            var Preds_Visited : Node_Set := []
            var Preds_To_Be_Visited : Node_Set := []

            //  Identify all back edges and initialize Preds_To_Be_Visited
            for each Incoming of CFG[LH].Incoming_Edges loop
               const Pred := CFG.Nth_Edge(Incoming).From

               if DT.Dominates(LH, Pred) then
                  //  This is a back edge because its "From" is dominated
                  //  by its "To"
                  DT.Is_Back_Edge[Incoming] := #true
                  if Pred != LH then
                     //  Add this predecessor to set to be visited
                     Preds_To_Be_Visited |= Pred
                  end if
               end if
            end loop

            //  Keep visiting predecessors until Preds_To_Be_Visited is empty
            for Pred := Remove_Any(Preds_To_Be_Visited)
              then Remove_Any(Preds_To_Be_Visited)
              while Pred not null
            loop
               //  Pred is a (strictly) dominated predecessor.
               //  Set its Enclosing_Loop to LH if it is null or
               //  if it points to a loop header that dominates LH.
               ref Encl_Loop => DT.Dom_Info[Pred].Enclosing_Loop

               if Encl_Loop is null
                 or else DT.Dominates(Encl_Loop, LH)
               then
                  Encl_Loop := LH
               end if

               Preds_Visited |= Pred

               //  Visit all of the interesting predecessors of this node
               for each P of CFG.Predecessors(Pred) loop
                  if P != LH
                    and then P not in Preds_Visited
                    and then DT.Dominates(LH, P)
                  then
                     //  We have a strictly dominated (indirect) predecessor
                     //  that we have not already visited.
                     Preds_To_Be_Visited |= P
                  end if
               end loop
            end loop
         end loop Find_Enclosing_Loops
         
      end func Compute

   end class Dominator_Tree

   func Compute_Dominator_Tree(var CFG) is
   //  Compute dominator tree of CFG if not already computed;
      if |CFG| > 0 and then CFG.Dom_Tree is null then
         //  Compute the dominator tree
         CFG.Dom_Tree := Compute(CFG)
      end if
   end func Compute_Dominator_Tree

   func Get_Dominator_Tree(ref const CFG)
     -> ref const optional Dominator_Tree is
   //  Return reference to dominator tree.

      {|CFG| > 0 ==> CFG.Dom_Tree not null}
      return CFG.Dom_Tree
   end func Get_Dominator_Tree

end class PSC::CFG

import PSC::CFG::*, PSC::Reflection

func Test_CFG(N : Univ_Integer) is
   var Ran := Random::Start()
   var CFG := PSC::CFG::[]
   for I in 1 .. N loop
      const Ignore := Add_Node(CFG)
   end loop

   for I in 1 .. N*10 loop
      const Ran1 : Node_Id := Ran.Next() mod N + 1
      const Ran2 : Node_Id := Ran.Next() mod N + 1
      if (for all S of Successors(CFG, Ran1) => Ran2 != S) then
         // Println("Adding edge `(Ran1) -> " | Ran2)
         const Ignore := Add_Edge(CFG, From => Ran1, To => Ran2)
      end if
   end loop

   Println("Last_Node_Id = " | Last_Node_Id(CFG))
   Println("Last_Edge_Id = " | Last_Edge_Id(CFG))

   Println("digraph CFG {");
   for I in CFG.All_Edges() loop
      ref const Edge => Nth_Edge(CFG, I)
      Println("N`(Edge.From) -> N`(Edge.To);");
   end loop
   Println("}");

end func Test_CFG

import PSC::Reflection, PSC::Analysis::*
import PSC::CFG

class PSC::Analysis::Op_Ctx is

  exports

   func Entry_Node_For_BB(Op_Ctx; BB : CFG::Node_Id;
     Uplevel : Code_Nesting_Level := 0) -> CFG::Node_Id is
     // Return id of entry block for enclosing nested block/operation
     // given current basic block, and uplevel count, if any, from
     // Enclosing_Local_Area or Enclosing_Param_Area locator.
     // Return 0 for entry node if this is an up-level reference to an
     // enclosing operation.
      ref DT => Op_Ctx.CFG.Get_Dominator_Tree()
      var Remaining_Uplevel_Count := Uplevel

      if Debug_Verbose and then Uplevel > 0 then
         Print(" Entry_Node_For_BB(`(BB), Uplevel=>`(Uplevel)):")
      end if

     *Outer*
      for Dom := BB
        while Dom not null
      loop
         if Debug_Verbose and then Uplevel > 0 then
            Print(" Dom = " | Dom)
         end if

         if Dom in Op_Ctx.CFG_Entry_Nodes then
            if Remaining_Uplevel_Count > 0 then
               //  Haven't reached desired entry block yet
               Remaining_Uplevel_Count -= 1
            else
               if Debug_Verbose and then Uplevel > 0 then
                  Print("\n")
               end if
               if Debug and then Uplevel > 0 then
                  Println
                    ("Entry_Node_For_BB(`(BB), Uplevel=>`(Uplevel)) = `(Dom)")
               end if

               return Dom
            end if
         end if

         //  Check for case of nested block that dominates successor
         //  and skip over nested block.
        *Inner*
         for Dom_To_Use := Dom loop
            const Next_Dom := Immediate_Dominator(DT, Dom_To_Use)

            if Debug_Verbose and then Uplevel > 0 then
               Print(" Dom_To_Use = " | Dom_To_Use)
            end if

            if Next_Dom not null
              and then Next_Dom in Op_Ctx.CFG_Exit_Nodes
            then
               //  Dominated by an exit node.
               //  Skip to matching entry node.
               continue loop Inner with Dom_To_Use =>
                 Key_Of(Op_Ctx.Entry_Node_To_Exit_Node_Map, Next_Dom)
            end if

            if Dom_To_Use in Op_Ctx.Invoking_Block then
               //  We hit the root of an out-of-line block.
               //  Continue loop with invoker of out-of-line block
               continue loop Outer with Dom =>
                 Op_Ctx.Invoking_Block[Dom_To_Use]
            else
               //  Continue loop with immediate dominator
               continue loop Outer with Dom => Next_Dom
            end if
         end loop Inner

      end loop Outer

      {Remaining_Uplevel_Count > 0}
      return 0  //  Indicates a "true" up-level reference
   end func Entry_Node_For_BB

   func Level_Of_BB(Op_Ctx; BB : CFG::Node_Id;
     Uplevel : Code_Nesting_Level := 0) -> Code_Nesting_Level is
     // Return nesting level of enclosing nested block/operation
     // given current basic block, and uplevel, if any, from
     // Enclosing_Local_Area or Enclosing_Param_Area locator.
      const Entry_BB := Entry_Node_For_BB(Op_Ctx, BB, Uplevel)

      if Entry_BB == 0 then
         //  This is an up-level reference to an enclosing operation;
         //  just subtract the Uplevel from the current block's level
         //  (determined by calling Level_Of_BB recursively).
         {Uplevel > 0} // Must be non-zero to avoid infinite recursion
         return Level_Of_BB(Op_Ctx, BB, Uplevel => 0) - Uplevel

      elsif Entry_BB == CFG::First_Node_Id then
         //  Not in a nested block; return routine's nesting level
         return Op_Ctx.Routine.Nesting_Level()

      else
         //  The entry node for a nested block
         return Op_Ctx.Routine.Nth_Instr(Op_Ctx.CFG[Entry_BB].First).
           Nested_Code_Block().Nesting_Level
      end if
   end func Level_Of_BB

   func Enclosing_Node(Op_Ctx; I : Code_Index) -> CFG::Node_Id is
     //  Return ID of Node enclosing given Code_Index
       const Start := Op_Ctx.Node_Starts.Max_No_Greater(I)
       {Start not null}
       return Op_Ctx.Instr_To_Node_Map[Start]
   end func Enclosing_Node

end class PSC::Analysis::Op_Ctx

class PSC::Analysis::Boolean_Value_Set is
  exports
   op "|="(var Left : Boolean_Value_Set; Right : Boolean_Value_Set) is
      Left.Might_Be_Null  or= Right.Might_Be_Null
      Left.Might_Be_True  or= Right.Might_Be_True
      Left.Might_Be_False or= Right.Might_Be_False
   end op "|="
   
   op "and="(var Left : Boolean_Value_Set; Right : Boolean_Value_Set) is
      Left.Might_Be_Null  and= Right.Might_Be_Null
      Left.Might_Be_True  and= Right.Might_Be_True
      Left.Might_Be_False and= Right.Might_Be_False
   end op "and="

   func Set_Is_Null(var Vals : Boolean_Value_Set) is
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.
      Vals.Might_Be_True := #false
      Vals.Might_Be_False := #false
   end func Set_Is_Null

end class PSC::Analysis::Boolean_Value_Set

class PSC::Analysis::Countable_Value_Set is
  exports
   op "|="(var Left : Countable_Value_Set; Right : Countable_Value_Set) is
      Left.Might_Be_Null or= Right.Might_Be_Null
      Left.Possible_Values or= Right.Possible_Values
   end op "|="
   
   op "and="(var Left : Countable_Value_Set; Right : Countable_Value_Set) is
      Left.Might_Be_Null and= Right.Might_Be_Null
      Left.Possible_Values and= Right.Possible_Values
   end op "and="

   func Set_Is_Null(var Vals : Countable_Value_Set) is
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.
      Vals.Possible_Values := []
   end func Set_Is_Null

   func To_String(Vals : Countable_Value_Set) -> Univ_String is
      const Rngs := Ranges(Vals.Possible_Values)
      return "Countable::[" | (Vals.Might_Be_Null? "null " : "") |
        (for R in Rngs forward =>
            <""> | "`(R.First)..`(R.Last) ") | "]"
   end func To_String

   func Combine(Countable_Op : Univ_Operation; Op_Name : Univ_String;
     Left, Right : Countable_Value_Set)
     -> Result : Countable_Value_Set is
     //  Combine Value sets using countable op

       func Combine_Ranges(L_Rng, R_Rng : Countable_Range<Univ_Integer>)
         -> Countable_Set<Univ_Integer> is
         //  Combine ranges using countable op
          if -1 in L_Rng and then +1 in L_Rng then
             //  Split L_Rng into two ranges to avoid having +/- in same range
             return Combine_Ranges (L_Rng.First .. -1, R_Rng) |
               Combine_Ranges (0 .. L_Rng.Last, R_Rng)
          elsif -1 in R_Rng and then +1 in R_Rng then
             //  Split R_Rng into two ranges to avoid having +/- in same range
             return Combine_Ranges (L_Rng, R_Rng.First .. -1) |
               Combine_Ranges (L_Rng, 0 .. R_Rng.Last)
          else
             //  Combine low and high bounds and construct resulting range
             const Low_Low := Countable_Op(L_Rng.First, R_Rng.First)
             const Low_High := Countable_Op(L_Rng.First, R_Rng.Last)
             const High_Low := Countable_Op(L_Rng.Last, R_Rng.First)
             const High_High := Countable_Op(L_Rng.Last, R_Rng.Last)
             return Min(Min(Low_Low, Low_High), Min(High_Low, High_High)) ..
               Max(Max(Low_Low, Low_High), Max(High_Low, High_High))
          end if
       end func Combine_Ranges

       const Left_Ranges := Left.Possible_Values.Ranges()
       const Right_Ranges := Right.Possible_Values.Ranges()

       Result := Countable_Value_Set::
                   (Might_Be_Null => #false,
                    Possible_Values => [])

       for LR in Left_Ranges loop
          for RR in Right_Ranges loop
             Result.Possible_Values |= Combine_Ranges(LR, RR)
          end loop
       end loop
   end func Combine

   func Compare_Sets(Left, Right : Countable_Value_Set)
     -> Result : Countable_Value_Set is
     //  Combine Value sets using "=?" producing a set of ordering values

       Result := Countable_Value_Set::
                   (Might_Be_Null => #false,
                    Possible_Values => [])

       if not Left.Possible_Values.Is_Empty()
         and then not Right.Possible_Values.Is_Empty()
       then
          //  Determine what "ordering" values are possible
          if Left.Possible_Values.First() < Right.Possible_Values.Last() then
             // Smallest of Left is < Largest of Right, so #less is possible
             Result.Possible_Values |= [#less - Ordering::First()]
          end if

          if Left.Possible_Values.Last() > Right.Possible_Values.First() then
             // Largest of Left is > Smallest of Right, so #greater is possible
             Result.Possible_Values |= [#greater - Ordering::First()]
          end if

          if not Is_Empty(Left.Possible_Values and Right.Possible_Values) then
             // Intersection is non-empty, so equality is possible
             Result.Possible_Values |= [#equal - Ordering::First()]
          end if
       end if

       if Debug_Propagation then
          Println("Compare_Sets(`(Left), `(Right)) == `(Result)")
       end if
   end func Compare_Sets

end class PSC::Analysis::Countable_Value_Set

class PSC::Analysis::Object_Value_Set is
  exports
   op "|="(var Left : Object_Value_Set; Right : Object_Value_Set) is
      Left.Might_Be_Null  or= Right.Might_Be_Null
      Left.Might_Be_Non_Null or= Right.Might_Be_Non_Null
   end op "|="
   
   op "and="(var Left : Object_Value_Set; Right : Object_Value_Set) is
      Left.Might_Be_Null and= Right.Might_Be_Null
      Left.Might_Be_Non_Null and= Right.Might_Be_Non_Null
   end op "and="

   func Set_Is_Null(var Vals : Object_Value_Set) is
     // Makes sure everything but Might_Be_Null is #false.
     // This means Is_Empty should return #true if Might_Be_Null is #false.
      Vals.Might_Be_Non_Null := #false
   end func Set_Is_Null

end class PSC::Analysis::Object_Value_Set

//  Begin Literal Value Numbers

class PSC::Analysis::Int_Literal_VN is
  exports
   func Compute_Value_Set
     (Int_Lit : Int_Literal_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> Result : optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
     Result := Countable_Value_Set::(Might_Be_Null => #false,
                                     Possible_Values => [Int_Lit.Value])
   end func Compute_Value_Set
end class PSC::Analysis::Int_Literal_VN

class PSC::Analysis::Bool_Literal_VN is
  exports
   func Compute_Value_Set
     (Bool_Lit : Bool_Literal_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> Result : optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
     Result := Boolean_Value_Set::(Might_Be_Null => #false,
                                   Might_Be_True => Bool_Lit.Value,
                                   Might_Be_False => not Bool_Lit.Value)
   end func Compute_Value_Set
end class PSC::Analysis::Bool_Literal_VN

//  Begin Compound Value Numbers (VNs that contain one or more other VNs)

class PSC::Analysis::Call_VN is
  exports
   func Compute_Value_Set
     (Call : Call_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      //  For Call_VNs, we only worry about calls on builtins.
      //  TBD: Some day use postconditions to compute value set of result(s)
      const Opnds_Have_Vals :=
        (for all Opnd of Call.Operands => Opnd in VN_Values)
      const Routine_Id := VNT.Int_Literal_Value(Call.Routine_Id)

      if Routine_Id not null then

         const Routine := Reflection::Routine::Routine_At_Index(Routine_Id)

         //  Check to see if we are calling a built-in.
         const Desig := Routine.Built_In_Desig()
         if Desig not null then
            //  We have a call on a built-in
            case Desig of
             ["#identity" | "#integer_from_univ" | "#integer_to_univ"] =>
               // Identity operations
               if Opnds_Have_Vals then
                  return VN_Values[Call.Operands[1]]
               end if

             ["\"=?\""] =>
               // NOTE: if neither side is a literal, value numbering should
               //      convert to subtraction compared against zero
               // TBD: Do the comparison without converting to countable vals
               const Left_Vals := VN_Values.Countable_Vals (Call.Operands[1])
               const Right_Vals := VN_Values.Countable_Vals (Call.Operands[2])
               return Compare_Sets(Left_Vals, Right_Vals)
             ["\"*\""] =>
               // do compile-time calculation;
               //      (value numbering should re-order for canonicalization)
               const Left_Vals := VN_Values.Countable_Vals (Call.Operands[1])
               const Right_Vals := VN_Values.Countable_Vals (Call.Operands[2])
               return Combine
                        (Analysis::Saturating_Times,
                         Desig, Left_Vals, Right_Vals)
             [..] =>
               //  Fall through
               null
            end case
         end if
      end if

      //  See whether we know Routine returns a non-null value
      if not Call.Might_Be_Null then
         //  Known non-null
         return Object_Value_Set::(Might_Be_Null => #false,
                                   Might_Be_Non_Null => #true)
      else
         //  Might be anything
         return null
      end if
   end func Compute_Value_Set

   func Propagate_To_Operands
     (Call : Call_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.

      //  For Call_VNs, we only worry about calls on builtins.
      const Routine_Id := VNT.Int_Literal_Value(Call.Routine_Id)

      if Routine_Id is null then
         //  Can't propagate anything down without knowing the routine
         return []
      end if

      const Routine := Reflection::Routine::Routine_At_Index(Routine_Id)
      const Desig := Routine.Built_In_Desig()

      if Desig not null then
         //  We have a call on a built-in
         case Desig of
          ["#identity" | "#integer_from_univ" | "#integer_to_univ"] =>
            // Identity operations
            if Call.Operands[1] not in VN_Values then
               //  Just pass the value set down if no existing value set
               return [Call.Operands[1] => Val_Set]
            end if

            ref Operand_Set => VN_Values[Call.Operands[1]]
            if Value_Kind(Operand_Set) == Value_Kind(Val_Set) then
               //  Kinds match, just "and" the sets together
               var New_Operand_Set := Operand_Set
               New_Operand_Set and= Val_Set
               if Is_Empty(New_Operand_Set) then
                  //  Failure
                  return null
               else
                  //  Return the new combined set
                  return [Call.Operands[1] => New_Operand_Set]
               end if
            end if
            
            return []  //  TBD handle mismatch

          ["\"=?\""] =>
            // NOTE: if neither side is a literal, value numbering should
            //      convert to subtraction compared against zero
            // TBD: Do the propagation without converting to countable vals
            const CVal_Set := Countable_Vals (Val_Set)
            const First := Ordering::First()
            const Any_Ordering : Countable_Set<Univ_Integer> :=
                             [#less-First, #equal-First, #greater-First]

            if Debug_Propagation then
               Println("Call Propagate_To_Operands, " |
                 "about to compare Any_Ordering with " | CVal_Set)
            end if

            if Any_Ordering <= CVal_Set.Possible_Values then
               //  Not putting on any restriction
               return []
            end if

            var Left_Vals := VN_Values.Countable_Vals (Call.Operands[1])
            var Right_Vals := VN_Values.Countable_Vals (Call.Operands[2])

            //  Neither can be null
            Left_Vals.Might_Be_Null := #false
            Right_Vals.Might_Be_Null := #false

            if Is_Empty(Left_Vals) or else Is_Empty(Right_Vals) then
               //  Failure
               return null
            end if

            if #less-First not in CVal_Set.Possible_Values then
               //  Remove items from Left that are Less than all items of Right
               //  Remove items from Right that are Greater than all
               //  items of Left
               const Left_Last := Left_Vals.Possible_Values.Last()

               if Right_Vals.Possible_Values.First() >
                 Univ_Integer::First()
               then
                  if Debug_Propagation then
                     Println("Call Propagate_To_Operands: " |
                       "about to remove values < " |
                       Right_Vals.Possible_Values.First() | " from " |
                       Left_Vals)
                  end if
                  Left_Vals.Possible_Values -=
                    Univ_Integer::First() ..
                      Right_Vals.Possible_Values.First() - 1
               end if
               if Left_Last < Univ_Integer::Last() then
                  if Debug_Propagation then
                     Println("Call Propagate_To_Operands: about to " |
                       "remove values > `(Left_Last) from `(Right_Vals)")
                  end if
                  Right_Vals.Possible_Values -=
                    Left_Last + 1 .. Univ_Integer::Last()
               end if
            end if

            if Is_Empty(Left_Vals) or else Is_Empty(Right_Vals) then
               //  Failure
               return null
            end if

            if #greater-First not in CVal_Set.Possible_Values then
               //  Remove items from Left that are Greater than all
               //  items of Right
               //  Remove items of Right that are Less than all items of Left
               const Left_First := Left_Vals.Possible_Values.First()

               if Right_Vals.Possible_Values.Last() < Univ_Integer::Last() then
                  if Debug_Propagation then
                     Println("Call Propagate_To_Operands: " |
                       "about to remove values > " |
                       Right_Vals.Possible_Values.Last() | " from " |
                       Left_Vals)
                  end if
                  Left_Vals.Possible_Values -=
                    Right_Vals.Possible_Values.Last() + 1 ..
                      Univ_Integer::Last()
               end if
               if Left_First > Univ_Integer::First() then
                  if Debug_Propagation then
                     Println("Call Propagate_To_Operands: " |
                       "about to remove values < " | Left_First |
                       " from " | Right_Vals)
                  end if
                  Right_Vals.Possible_Values -=
                    Univ_Integer::First() .. Left_First - 1
               end if
            end if

            if #equal-First not in CVal_Set.Possible_Values then
               //  if Left or Right are singletons, remove those single
               //  values from the other set
               if Debug_Propagation then
                  Println("Call Propagate_To_Operands: about to get len of " |
                    Left_Vals | " and " | Right_Vals)
               end if
               if |Left_Vals.Possible_Values| == 1 then
                  //  Left is a singleton, remove from Right
                  Right_Vals.Possible_Values -= Left_Vals.Possible_Values
               elsif |Right_Vals.Possible_Values| == 1 then
                  //  Right is a singleton, remove from Left
                  Left_Vals.Possible_Values -= Right_Vals.Possible_Values
               end if
            end if

            if Is_Empty(Left_Vals) or else Is_Empty(Right_Vals) then
               //  Failure
               return null
            end if

            //  Propagate down what we have learned
            return [Call.Operands[1] => Left_Vals,
                    Call.Operands[2] => Right_Vals]

          ["\"*\""] =>
            // Propagate down
            null  //  **TBD**
          [..] =>
            //  Fall through
            null
         end case
      end if

      //  Nothing learned
      return []
   end func Propagate_To_Operands

end class PSC::Analysis::Call_VN

class PSC::Analysis::Input_VN is
  exports
   func Compute_Value_Set
     (I : Input_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      //  See whether we know Input has a non-null value
      if not I.Might_Be_Null then
         //  Known non-null
         return Object_Value_Set::(Might_Be_Null => #false,
                                   Might_Be_Non_Null => #true)
      else
         //  Might be anything
         return null
      end if
   end func Compute_Value_Set
end class PSC::Analysis::Input_VN

class PSC::Analysis::Not_Null_VN is
   //  Represents the boolean test "Tested_Val not null"
  exports
   func Compute_Value_Set
     (NN : Not_Null_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      if VNT.Is_Literal_VN(NN.Tested_Val) then
         //  A literal value is always of known nullness
         case VNT[NN.Tested_Val] of
          [N : Null_Literal_VN] =>
            //  Known to be null ==> Not_Null is #false
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True => #false,
                                       Might_Be_False => #true)
          [..] =>
            //  Known to be non-null ==> Not_Null is #true
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True => #true,
                                       Might_Be_False => #false)
         end case
      elsif NN.Tested_Val in VN_Values then
         //  Tested_Val has a value set; check its nullness
         ref Val_Set => VN_Values[NN.Tested_Val]
         case Val_Set of
          [B : Boolean_Value_Set] =>
            //  Tested value is itself a boolean.
            //  Not null is equivalent to being #true or #false
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True =>
                                         B.Might_Be_True or
                                           B.Might_Be_False,
                                       Might_Be_False =>
                                         B.Might_Be_Null)
          [..] =>
            //  Some other kind of value.  Look at "Might_Be_Null" 
            if not Val_Set.Might_Be_Null then
               //  Definitely not null
               return Boolean_Value_Set::(Might_Be_Null => #false,
                                          Might_Be_True => #true,
                                          Might_Be_False => #false)
            else
               //  See whether is known to be null, by checking whether
               //  setting Might_Be_Null to #false makes it empty.
               var Val_Set_Copy := Val_Set

               Val_Set_Copy.Might_Be_Null := #false
               //  If Val_Set_Copy is now Empty, then we know it is null.
               return Boolean_Value_Set::(Might_Be_Null => #false,
                                          Might_Be_True =>
                                            not Is_Empty(Val_Set_Copy),
                                          Might_Be_False => #true)
            end if
         end case
      end if
      //  Cannot be null
      return Boolean_Value_Set::(Might_Be_Null => #false,
                                 Might_Be_True => #true,
                                 Might_Be_False =>
                                   Can_Have_Null_Value
                                     (VNT[NN.Tested_Val]))
   end func Compute_Value_Set

   func Propagate_To_Operands
     (NN: Not_Null_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.
      case Val_Set of
       [B : Boolean_Value_Set] =>
         //  Adjust Might_Be_Null value of Tested_Val
         //  TBD: We can't do anything if Tested_Val doesn't already
         //       have a value set, since we don't know what kind to
         //       create.  Might eventually create a trivial kind of
         //       value set which just keeps track of nullness, but that
         //       doesn't seem necessary, because the value set of the
         //       Not_Null_VN captures that information.
         if NN.Tested_Val in VN_Values then
            var New_Tested_Val_Set := VN_Values[NN.Tested_Val]
            if B.Might_Be_True and not B.Might_Be_False then
               //  Not-Null returns #true => cannot be null
               New_Tested_Val_Set.Might_Be_Null := #false
            elsif B.Might_Be_False and not B.Might_Be_True then
               //  Not-Null returns #false => can only be null
               Set_Is_Null(New_Tested_Val_Set)
            end if

            if Is_Empty(New_Tested_Val_Set) then
               return null  //  Caller will report failure
            end if

            //  Return map of Tested_Val to its new value set
            return [NN.Tested_Val => New_Tested_Val_Set]
         else
            //  We knew nothing about value before.  Now we know
            //  whether it might be null.
            const New_Tested_Val_Set :=
              Object_Value_Set::(Might_Be_Null => B.Might_Be_False,
                                 Might_Be_Non_Null => B.Might_Be_True)
            return [NN.Tested_Val => New_Tested_Val_Set]
         end if
       [..] => null
      end case
      return []
   end func Propagate_To_Operands

end class PSC::Analysis::Not_Null_VN

class PSC::Analysis::Countable_Membership_VN is
   //  Represents the boolean test "Tested_Val in Tested_Set"
  exports
   func Compute_Value_Set
     (CM : Countable_Membership_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      const Tested_Vals := Countable_Vals(VN_Values, CM.Tested_Val)

      if Tested_Vals <= CM.Tested_Set then
         //  Known to be a subset ==> Countable_Membership is #true
         return Boolean_Value_Set::(Might_Be_Null => #false,
                                    Might_Be_True => #true,
                                    Might_Be_False => #false)
      elsif not (Tested_Vals.Might_Be_Null and CM.Tested_Set.Might_Be_Null)
        and then
          Is_Empty
            (Tested_Vals.Possible_Values and CM.Tested_Set.Possible_Values)
      then
         //  Known to have no overlap ==> Countable_Membership is #false
         return Boolean_Value_Set::(Might_Be_Null => #false,
                                    Might_Be_True => #false,
                                    Might_Be_False => #true)
      else
         //  Could be #true or #false
         return Boolean_Value_Set::(Might_Be_Null => #false,
                                    Might_Be_True => #true,
                                    Might_Be_False => #true)
      end if
   end func Compute_Value_Set

   func Propagate_To_Operands
     (CM: Countable_Membership_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.
      var New_Tested_Val_Set := Countable_Vals(VN_Values, CM.Tested_Val)

      New_Tested_Val_Set and= CM.Tested_Set
      if Is_Empty(New_Tested_Val_Set) then
         //  Failure
         return null
      elsif CM.Tested_Val in VN_Values then
         case VN_Values[CM.Tested_Val] of
            [Old_Tested_Val_Set : Countable_Value_Set] =>
               if New_Tested_Val_Set == Old_Tested_Val_Set then
                  //  No change
                  return []
               end if
            [..] =>
               //  Some change
               null
         end case
      end if

      //  Return map of Tested_Val to its new value set
      return [CM.Tested_Val => New_Tested_Val_Set]
   end func Propagate_To_Operands

end class PSC::Analysis::Countable_Membership_VN

class PSC::Analysis::Logical_Not_VN is
   //  Represents the boolean operation "not Tested_Val"
  exports
   func Compute_Value_Set
     (N : Logical_Not_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      if N.Tested_Val in VN_Values then
         ref Val_Set => VN_Values[N.Tested_Val]
         case Val_Set of
          [B : Boolean_Value_Set] =>
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True =>
                                         B.Might_Be_False,
                                       Might_Be_False =>
                                         B.Might_Be_True)
          [C : Countable_Value_Set] =>
            //  Convert countable to boolean and invert
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True =>
                                         0 in C.Possible_Values,
                                       Might_Be_False =>
                                         1 in C.Possible_Values)
          [..] =>
            //  Not boolean/countable, what could it be?
            return Boolean_Value_Set::(Might_Be_Null => #false,
                                       Might_Be_True => #true,
                                       Might_Be_False => #true)
         end case
      end if
      //  Cannot be null
      return Boolean_Value_Set::(Might_Be_Null => #false,
                                 Might_Be_True => #true,
                                 Might_Be_False => #true)
   end func Compute_Value_Set

   func Propagate_To_Operands
     (N: Logical_Not_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.
      case Val_Set of
       [B : Boolean_Value_Set] =>
         //  Invert value set of Val_Num and "and" into Tested_Val
         var New_Tested_Val_Set :=
           Boolean_Value_Set::(Might_Be_Null => #false,
                               Might_Be_True => B.Might_Be_False,
                               Might_Be_False => B.Might_Be_True)

         if N.Tested_Val in VN_Values then
            New_Tested_Val_Set and= Boolean_Vals(VN_Values, N.Tested_Val)
            if Is_Empty(New_Tested_Val_Set) then
               //  Empty set implies the check will fail
               return null  //  Caller will report check failure
            end if
         end if

         //  Return map of Tested_Val to its new value set
         return [N.Tested_Val => New_Tested_Val_Set]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands

end class PSC::Analysis::Logical_Not_VN

class PSC::Analysis::Logical_And_VN is
   //  Represents the boolean operation "Left and Right"
  exports
   func Compute_Value_Set
     (And : Logical_And_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      if And.Left in VN_Values and then And.Right in VN_Values then
         case VN_Values[And.Left] of
          [Left : Boolean_Value_Set] =>
            case VN_Values[And.Right] of
             [Right : Boolean_Value_Set] =>
               // Combine boolean value sets
               return Boolean_Value_Set::
                        (Might_Be_Null => #false,
                         Might_Be_True =>
                           Left.Might_Be_True and Right.Might_Be_True,
                         Might_Be_False =>
                           Left.Might_Be_False or Right.Might_Be_False)
               
             [..] => null
            end case
          [..] => null
         end case

      end if
      //  Cannot be null
      return Boolean_Value_Set::(Might_Be_Null => #false,
                                 Might_Be_True => #true,
                                 Might_Be_False => #true)
   end func Compute_Value_Set

   func Propagate_To_Operands
     (And: Logical_And_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.

      case Val_Set of
       [B : Boolean_Value_Set] =>
         var Left_Bools := VN_Values.Boolean_Vals(And.Left)
         var Right_Bools := VN_Values.Boolean_Vals(And.Right)
         //  Neither operand can be null
         Left_Bools.Might_Be_Null := #false
         Right_Bools.Might_Be_Null := #false
         if not B.Might_Be_False then
            //  If result cannot be false, then neither operand can be
            Left_Bools.Might_Be_False := #false
            Right_Bools.Might_Be_False := #false
         end if
         if Is_Empty(Left_Bools) or else Is_Empty(Right_Bools) then
            //  Failure
            return null
         end if
         //  Return mapping from operands to their new value sets
         return [And.Left => Left_Bools, And.Right => Right_Bools]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands
end class PSC::Analysis::Logical_And_VN

class PSC::Analysis::Logical_Or_VN is
   //  Represents the boolean operation "Left or Right"
  exports
   func Compute_Value_Set
     (Or : Logical_Or_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      if Or.Left in VN_Values and then Or.Right in VN_Values then
         case VN_Values[Or.Left] of
          [Left : Boolean_Value_Set] =>
            case VN_Values[Or.Right] of
             [Right : Boolean_Value_Set] =>
               // Combine boolean value sets
               return Boolean_Value_Set::
                        (Might_Be_Null => #false,
                         Might_Be_True =>
                           Left.Might_Be_True or Right.Might_Be_True,
                         Might_Be_False =>
                           Left.Might_Be_False and Right.Might_Be_False)
               
             [..] => null
            end case
          [..] => null
         end case

      end if
      //  Cannot be null
      return Boolean_Value_Set::(Might_Be_Null => #false,
                                 Might_Be_True => #true,
                                 Might_Be_False => #true)
   end func Compute_Value_Set

   func Propagate_To_Operands
     (Or: Logical_Or_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.

      case Val_Set of
       [B : Boolean_Value_Set] =>
         var Left_Bools := VN_Values.Boolean_Vals(Or.Left)
         var Right_Bools := VN_Values.Boolean_Vals(Or.Right)
         //  Neither operand can be null
         Left_Bools.Might_Be_Null := #false
         Right_Bools.Might_Be_Null := #false
         if not B.Might_Be_True then
            //  If result cannot be true, then neither operand can be
            Left_Bools.Might_Be_True := #false
            Right_Bools.Might_Be_True := #false
         end if
         if Is_Empty(Left_Bools) or else Is_Empty(Right_Bools) then
            //  Failure
            return null
         end if
         //  Return mapping from operands to their new value sets
         return [Or.Left => Left_Bools, Or.Right => Right_Bools]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands
end class PSC::Analysis::Logical_Or_VN

class PSC::Analysis::Negate_VN is
   //  Represents the countable operation "- Operand"
  exports
   func Compute_Value_Set
     (N : Negate_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      if N.Operand in VN_Values then
         ref Val_Set => VN_Values[N.Operand]
         case Val_Set of
          [C : Countable_Value_Set] =>
            //  Negate each value
            return Countable_Value_Set::(Might_Be_Null => #false,
                     Possible_Values => [for X in C.Possible_Values => -X])
          [..] =>
            //  Not countable -- just turn off Might_Be_Null
            var Val_Set_Copy for Result := Val_Set

            Val_Set_Copy.Might_Be_Null := #false
            return Val_Set_Copy
         end case
      end if
      //  Cannot be null
      return Object_Value_Set::(Might_Be_Null => #false,
                                Might_Be_Non_Null => #true)
   end func Compute_Value_Set

   func Propagate_To_Operands
     (N: Negate_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.
      case Val_Set of
       [C : Countable_Value_Set] =>
         //  Invert value set of Val_Num and "and" into Operand
         var New_Operand_Set : Value_Set+ for Result :=
           Countable_Value_Set::(Might_Be_Null => #false,
             Possible_Values => [for X in C.Possible_Values => -X])

         if N.Operand in VN_Values
           and then Value_Kind(VN_Values[N.Operand]) == #Countable
         then
            New_Operand_Set and= VN_Values[N.Operand]
            if Is_Empty(New_Operand_Set) then
               //  Empty set implies the check will fail
               return null  //  Caller will report check failure
            end if
         end if

         //  Return map of Operand to its new value set
         return [N.Operand => New_Operand_Set]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands

end class PSC::Analysis::Negate_VN

class PSC::Analysis::Addition_VN is
   //  Represents the countable operation "Left + Right"
  exports
   func Compute_Value_Set
     (Add : Addition_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      if Add.Left in VN_Values and then Add.Right in VN_Values then
         case VN_Values[Add.Left] of
          [Left : Countable_Value_Set] =>
            case VN_Values[Add.Right] of
             [Right : Countable_Value_Set] =>
               // Combine countable value sets
               return Combine(Analysis::Saturating_Plus, "\"+\"", Left, Right)
             [..] => null
            end case
          [..] => null
         end case

         //  Result cannot be null
         return Object_Value_Set::(Might_Be_Null => #false,
                                   Might_Be_Non_Null =>
                                       not Is_Empty(VN_Values[Add.Left])
                                     and then
                                       not Is_Empty(VN_Values[Add.Right]))
      end if
      //  Result cannot be null
      return Object_Value_Set::(Might_Be_Null => #false,
                                Might_Be_Non_Null => #true)
   end func Compute_Value_Set

   func Propagate_To_Operands
     (Add: Addition_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.

      case Val_Set of
       [C : Countable_Value_Set] =>
         var Left_Set := VN_Values.Countable_Vals(Add.Left)
         var Right_Set := VN_Values.Countable_Vals(Add.Right)
         //  Neither operand can be null
         Left_Set.Might_Be_Null := #false
         Right_Set.Might_Be_Null := #false

         // Left = C - Right, Right = C - Left
         const Left_Set_Copy := Left_Set
         Left_Set := Combine(Analysis::Saturating_Minus, "\"-\"", C, Right_Set)
         Right_Set := Combine
                        (Analysis::Saturating_Minus, "\"-\"", C, Left_Set_Copy)

         if Is_Empty(Left_Set) or else Is_Empty(Right_Set) then
            //  Failure
            return null
         end if
         //  Return mapping from operands to their new value sets
         return [Add.Left => Left_Set, Add.Right => Right_Set]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands
end class PSC::Analysis::Addition_VN

class PSC::Analysis::Subtraction_VN is
   //  Represents the countable operation "Left - Right"
  exports
   func Compute_Value_Set
     (Sub : Subtraction_VN; VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type)
     -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN
      if Sub.Left in VN_Values and then Sub.Right in VN_Values then
         case VN_Values[Sub.Left] of
          [Left : Countable_Value_Set] =>
            case VN_Values[Sub.Right] of
             [Right : Countable_Value_Set] =>
               // Combine countable value sets
               return Combine(Analysis::Saturating_Minus, "\"-\"", Left, Right)
               
             [..] => null
            end case
          [..] => null
         end case

         //  Result cannot be null
         return Object_Value_Set::(Might_Be_Null => #false,
                                   Might_Be_Non_Null =>
                                       not Is_Empty(VN_Values[Sub.Left])
                                     and then
                                       not Is_Empty(VN_Values[Sub.Right]))
      end if
      //  Result cannot be null
      return Object_Value_Set::(Might_Be_Null => #false,
                                Might_Be_Non_Null => #true)
   end func Compute_Value_Set

   func Propagate_To_Operands
     (Sub: Subtraction_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> Result : optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.

      case Val_Set of
       [C : Countable_Value_Set] =>
         var Left_Set := VN_Values.Countable_Vals(Sub.Left)
         var Right_Set := VN_Values.Countable_Vals(Sub.Right)
         //  Neither operand can be null
         Left_Set.Might_Be_Null := #false
         Right_Set.Might_Be_Null := #false

         // Left = Right + C, Right = Left - C
         const Left_Set_Copy := Left_Set
         Left_Set := Combine(Analysis::Saturating_Plus, "\"+\"", Right_Set, C)
         Right_Set := Combine
                        (Analysis::Saturating_Minus, "\"-\"", Left_Set_Copy, C)

         //  Return mapping from operands to their new value sets
         return [Sub.Left => Left_Set, Sub.Right => Right_Set]
       [..] =>
         return []
      end case
   end func Propagate_To_Operands
end class PSC::Analysis::Subtraction_VN

class PSC::Analysis::Condition_Mask_VN is
   //  Represents the boolean test "Tested_Val satisfies Mask"
  exports
   func Compute_Value_Set
     (C_Mask_VN : Condition_Mask_VN;
      VNT : VN_Table;
      VN_Values : VN_To_Value_Set_Map_Type) -> optional Value_Set+ is
     //  Do a bottom-up computation of the value set of the given VN

      if C_Mask_VN.Tested_Val in VN_Values then
         //  Subrange of ordering known, so possible
         //  bool values are computable.
         const Ordering_Vals := VN_Values[C_Mask_VN.Tested_Val]
         const Ordering_Mask := To_Rep(C_Mask_VN.Mask)
         case Ordering_Vals of
          [C_Vals : Countable_Value_Set] =>
            //  Checking if ordering mask has proper bit on
            const Possible_Vals := C_Vals.Possible_Values and (0..3)
            const Might_Be_True :=
              (for some Val in Possible_Vals =>
                 (Ordering_Mask >> Val) mod 2 != 0)
            const Must_Be_True := Might_Be_True and then
              (for all Val in Possible_Vals =>
                 (Ordering_Mask >> Val) mod 2 != 0)
            return Boolean_Value_Set::
              (Might_Be_Null => #false,
               Might_Be_True => Might_Be_True,
               Might_Be_False => not Must_Be_True)
          [B_Vals : Boolean_Value_Set] =>
             if C_Mask_VN.Mask == #compare_equal then
                return Ordering_Vals
             else
                return Boolean_Value_Set::
                          (Might_Be_Null => #false,
                           Might_Be_True => B_Vals.Might_Be_False,
                           Might_Be_False => B_Vals.Might_Be_True)
             end if
          [..] =>
             null
         end case
      end if
      //  Cannot be null
      return Boolean_Value_Set::(Might_Be_Null => #false,
                                 Might_Be_True => #true,
                                 Might_Be_False => #true)
   end func Compute_Value_Set

   func Propagate_To_Operands
     (CM: Condition_Mask_VN; Val_Set : Value_Set+;
      VNT : VN_Table; VN_Values : VN_To_Value_Set_Map_Type)
     -> optional VN_To_Value_Set_Map_Type is
     //  Do a top-down propagation to operands of value number.
     //  Return null if top-down propagation fails.
     //  Otherwise, return a mapping of operands to their new value sets.
      var New_Tested_Val_Set := Countable_Vals(VN_Values, CM.Tested_Val)
      const Bool_Val_Set := Boolean_Vals(Val_Set)
      const Ordering_Mask := To_Rep(CM.Mask)

      //  Cannot be null
      New_Tested_Val_Set.Might_Be_Null := #false

      if Debug_Propagation then
         Println("About to \"and\" `(New_Tested_Val_Set) with 0 .. " |
           Ordering::Last() - Ordering::First())
      end if

      //  Reduce to range of Ordering
      New_Tested_Val_Set.Possible_Values and=
        0 .. Ordering::Last() - Ordering::First()

      const Vals_Giving_True : Countable_Set<Univ_Integer> :=
              [for Val in New_Tested_Val_Set.Possible_Values
                {(Ordering_Mask >> Val) mod 2 != 0} => Val]

      if not Bool_Val_Set.Might_Be_True then
         //  Remove values that might cause it to return true
         New_Tested_Val_Set.Possible_Values -= Vals_Giving_True
      end if

      if not Bool_Val_Set.Might_Be_False then
         //  Restrict to values that will return True
         New_Tested_Val_Set.Possible_Values and= Vals_Giving_True
      end if

      if Is_Empty(New_Tested_Val_Set) then
         //  Failure
         return null
      elsif CM.Tested_Val in VN_Values then
         case VN_Values[CM.Tested_Val] of
            [Old_Tested_Val_Set : Countable_Value_Set] =>
               if New_Tested_Val_Set == Old_Tested_Val_Set then
                  //  No change
                  return []
               end if
            [..] =>
               //  Some change
               null
         end case
      end if

      //  Return map of Tested_Val to its new value set
      return [CM.Tested_Val => New_Tested_Val_Set]
   end func Propagate_To_Operands

end class PSC::Analysis::Condition_Mask_VN

class PSC::Analysis::Cond_VN is
   //  Represents the conditional expression "Cond? Then : Else"
  exports
   op "=?"(Left, Right : Cond_VN) -> Ordering is
      const Left_VNs : Vector<VN_Id> := [Left.Cond, Left.Then, Left.Else];
      const Right_VNs : Vector<VN_Id> := [Right.Cond, Right.Then, Right.Else];
      return Compare_VN_Vectors(Left_VNs, Right_VNs);
   end op "=?";
end class PSC::Analysis::Cond_VN;

class PSC::Analysis::Updated_Value is
  exports
   op "=?"(Left, Right : Updated_Value) -> Ordering is
      if Left.Base_Val != Right.Base_Val
        or else
         Left.Kind_Of_Selectors != Right.Kind_Of_Selectors
        or else
         |Left.Component_OIDs| != |Right.Component_OIDs|
      then
         //  Mismatch in basic info
         return #unordered
      else
         //  Same number of components, compare if equal.
         for each [C => O] of Left.Component_OIDs loop
            if C not in Right.Component_OIDs
              or else
               Right.Component_OIDs[C] != O
            then
               //  A component mismatch
               return #unordered
            end if
         end loop
         //  All components match
         return #equal
      end if
   end op "=?"

   func Hash(Updated_Value) -> Univ_Integer is
      return Hash(Updated_Value.Base_Val) +
        Hash(Updated_Value.Kind_Of_Selectors) +
        |Updated_Value.Component_OIDs|
   end func Hash

   func To_String(Updated_Value) -> Univ_String is
      //  Return a string representation
      return "Updated_Value::(Base => VN" | Updated_Value.Base_Val |
                           ", Kind_Of_Selectors => " |
                                            Updated_Value.Kind_Of_Selectors |
                           ", Component_OIDs => [" |
             (for (each [C => O] of Updated_Value.Component_OIDs;
                  Sep := "" then ", ") =>
                    <""> | Sep | "VN`(C)=>OID`(O)") | "])"
   end func To_String

end class PSC::Analysis::Updated_Value

func Test_VN() is
   var VNT : PSC::Analysis::VN_Table := []

   const VN1 : PSC::Analysis::Local_Addr_VN :=
     (Level => 0, BB_Id => 0, Offset => 3)
   const VN1_Id := VNT.Get_Unique_Id(VN1);
   Println("Val1:(Local_Area, 3) Id = " | VN1_Id)

   const VN2 : PSC::Analysis::Param_Addr_VN :=
     (Level => 0, BB_Id => 0, Offset => 2)
   const VN2_Id := VNT.Get_Unique_Id(VN2)
   Println("Val2:(Param_Area, 2) Id = " | VN2_Id)

   const VN3 : PSC::Analysis::Int_Literal_VN :=
      (Value => 42)
   const VN3_Id := VNT.Get_Unique_Id(VN3)
   Println("Val3:(Value => 42) Id = " | VN3_Id)

   const VN4_1 : PSC::Analysis::Indexed_Selector_VN :=
     (Indexing_Routine_Id => VN3_Id,
      Indexing_Operands => [VN2_Id],
      Is_Indexing_Op => #true,
      Is_Static_Indexing => #false)
   const VN4_1_Id := VNT.Get_Unique_Id(VN4_1)
   const OID_1 : OID := 31
   const VN4 : PSC::Analysis::Component_Addr_VN :=
     (Base_Obj => OID_1, Selector => VN4_1_Id,
      Comp_Type => null, Comp_Might_Be_Null => #false)
   const VN4_Id := VNT.Get_Unique_Id(VN4)
   Println("Val4_1:(Indexed_Selector, call #42, Val2) Id = " | VN4_1_Id)
   Println("Val4:(Component_Addr, OID1, Val4_1) Id = " | VN4_Id)

   const VN5 : PSC::Analysis::Param_Addr_VN :=
     (Level => 0, BB_Id => 0, Offset => 2)
   const VN5_Id := VNT.Get_Unique_Id(VN5)
   Println("Val5:(Param_Area, 2) Id = " | VN5_Id)

   {VN5_Id == VN2_Id}

   const VN6_1 : PSC::Analysis::Named_Selector_VN := (Offset => 7)
   const OID_2 : OID := 42
   const VN6 : PSC::Analysis::Component_Addr_VN := (Base_Obj => OID_2,
     Selector => VNT.Get_Unique_Id(VN6_1),
     Comp_Type => null, Comp_Might_Be_Null => #false)
   const VN6_Id := VNT.Get_Unique_Id(VN6)
   Println("Val6:(Component, OID`(OID_2), 7) Id = `(VN6_Id)")

   const VN7 : PSC::Analysis::String_Literal_VN :=
      (Value => "hi there")
   const VN7_Id := VNT.Get_Unique_Id(VN7)
   Println("Val7:(Value => \"hi there\") Id = " | VN7_Id)

   for each [Id => VN] of VNT forward loop
      Println ("Found VN`(Id):`(VN)")
   end loop

   Println("About to call From_String");
   const FS_VN := PSC::Analysis::Param_Addr_VN::From_String("hi there")
   Println("From_String returned " | FS_VN)
end func Test_VN

import PSC::*

class PSC::Analysis is
   //  Analyze the declaration if it resides in the given source file
   func Analyze_One_Decl(File_Name : Univ_String;
      Item : Reflection::Decl) -> Univ_Integer is

      if Item is null or else
         (Context(Item) == #inherited or
          Kind(Item) == #type or
         (Kind(Item) == #operation
            and then Operation_Equiv_To(Item) not null) or
          File(Decl_Source_Pos(Item)) != File_Name) then
         return 0;
      end if

      var Count := 0;

      const Region := not Is_Spec(Item) and Kind(Item) == #operation?
                      Body_Region(Item) : Decl_Region(Item)
      if not Is_Spec(Item) and Kind(Item) == #module then
         const Spec := Spec(Item);
         if File(Decl_Source_Pos(Spec)) == File(Decl_Source_Pos(Item)) then
            //  This prevents double defining when interface and class
            //  are in the same file
            return Count;
         end if
      end if

      func Recurse_On_Region(R : Reflection::Region) is
         for I in 1 .. Num_Items(R) forward loop
            if Debug_Verbose then
               const Next_Item := R.Nth_Item(I);
               const This_Mod := Module_Name(Item);
               if Next_Item not null then
                  Println("Recursing from " |
                     Kind(Item) | " " |
                     (This_Mod is null? "" : This_Mod | "::") |
                     Id(Item) | " to " |
                     (Next_Item is null? "" : To_String(Kind(Next_Item))
                        | " ") |
                     (Next_Item is null or else
                        Module_Name(Next_Item) is null? ""
                        : Module_Name(Next_Item) | "::") |
                     (Id(Next_Item) is null? "null" : Id(Next_Item)));
               end if
            end if
            Count += Analyze_One_Decl(File_Name, R.Nth_Item(I));
         end loop
      end func Recurse_On_Region

      //  Recurse on this region, its nested region, and siblings.
      func Recurse_On_Nested_Regions(R : Reflection::Region) is
         if R not null then
            Recurse_On_Region(R);

            case Kind(R) of
               [#Module_Region_Kind | #Operation_Param_Region_Kind] =>
                  //  We don't need to recurse on the nested regions
                  //  because that is implicit in processing the nested
                  //  items.
                  null

               [..] =>
                  //  Recurse on the nested regions, because these aren't
                  //  necessarily reached from the items of the current region.
                  for I in 1 .. Num_Nested_Regions(R) forward loop
                     const Nested := R.Nth_Nested_Region(I);
                     if Nested not null then 
                        Recurse_On_Nested_Regions(Nested);
                        
                        var Sibling := Sibling_Region(Nested);
                        while Sibling not null loop
                           Recurse_On_Nested_Regions(Sibling);
                           Sibling := Sibling_Region(Sibling);
                        end loop;
                     end if
                  end loop
            end case
         end if
      end func Recurse_On_Nested_Regions;

      Recurse_On_Nested_Regions(Region);

      case Kind(Item) of
         [#object] =>
            const Val := Value_Of_Global_Const(Item);
            if Val not null then
               Count += 1
            end if
         [#operation] => 
            if Is_Spec(Item) then
               //  operation specs have no code, and "equiv_to" are not
               //  of interest
               return Count;
            end if

            Analyze_Operation(Item)
            Count += 1;
         [..] => null;
      end case;
      return Count;
   end func Analyze_One_Decl;

  exports

   func Is_Literal_VN(VN_Table; VN : VN_Id) -> Boolean is
      //  Return #true if VN is the value number for a literal VN
      case VN_Table[VN] of
         [Lit_VN : Literal_VN+] => return #true
         [..] => return #false
      end case
   end func Is_Literal_VN

   func Int_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_Integer is
      //  Return value of int literal, or null if VN is not an int-literal VN
      case VN_Table[VN] of
         [Lit_VN : Int_Literal_VN] => return Lit_VN.Value
         [..] => return null
      end case
   end func Int_Literal_Value

   func Enum_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_Enumeration is
      //  Return value of enum literal, or null if VN is not an enum-literal VN
      case VN_Table[VN] of
         [Lit_VN : Enum_Literal_VN] => return Lit_VN.Value
         [..] => return null
      end case
   end func Enum_Literal_Value

   func Str_Literal_Value(VN_Table; VN : VN_Id) -> optional Univ_String is
      //  Return value of string lit, or null if VN is not an str-literal VN
      case VN_Table[VN] of
         [Lit_VN : String_Literal_VN] => return Lit_VN.Value
         [..] => return null
      end case
   end func Str_Literal_Value

   func Get_Int_Literal_VN(var VN_Table; Int_Val : Univ_Integer) -> VN_Id is
      //  Return Int_Literal_VN for given int value
      return VN_Table.Get_Unique_Id (Int_Literal_VN::(Value => Int_Val))
   end func Get_Int_Literal_VN

   func Get_Bool_Literal_VN(var VN_Table; Bool_Val : Boolean) -> VN_Id is
      //  Return Bool_Literal_VN for given bool value
      return VN_Table.Get_Unique_Id (Bool_Literal_VN::(Value => Bool_Val))
   end func Get_Bool_Literal_VN

   func Boolean_Vals(Vals : Value_Set+) -> Boolean_Value_Set is
      //  Convert value set to Boolean_Vals if possible
      case Vals of
       [B : Boolean_Value_Set] =>
         return B

       [C : Countable_Value_Set] =>
         //  Convert countable to boolean
         return Boolean_Value_Set::(Might_Be_Null => Vals.Might_Be_Null,
                                    Might_Be_True =>
                                      1 in C.Possible_Values,
                                    Might_Be_False =>
                                      0 in C.Possible_Values)

       [..] => 
         //  Preserve might-be-null ness and empty-ness
         const Set_Is_Empty := Is_Empty(Vals)
         return Boolean_Value_Set::(Might_Be_Null => Vals.Might_Be_Null,
                                    Might_Be_True => not Set_Is_Empty,
                                    Might_Be_False => not Set_Is_Empty)
      end case

   end func Boolean_Vals

   func Boolean_Vals(VN_Values : VN_To_Value_Set_Map_Type; VN : VN_Id)
     -> Boolean_Value_Set is
      //  Return stored Boolean_Value_Set of VN, or return an anything-goes
      //  value set (Might be null/true/false) if nothing stored yet.
      if VN in VN_Values then
         //  Convert to Boolean_Value_Set
         return Boolean_Vals(VN_Values[VN])
      end if
      //  Anything goes
      return Boolean_Value_Set::(Might_Be_Null => #true,
                                 Might_Be_True => #true,
                                 Might_Be_False => #true)
   end func Boolean_Vals

   func Countable_Vals(Vals : Value_Set+) -> Countable_Value_Set is
      //  Convert value set to Countable_Vals if possible
      case Vals of
       [C : Countable_Value_Set] =>
         //  Return countable set
         return C

       [B : Boolean_Value_Set] =>
         //  Return countable set, #true => 1, #false => 0
         return Countable_Value_Set::
                 (Might_Be_Null   => B.Might_Be_Null,
                  Possible_Values => (B.Might_Be_True? [1] : []) |
                                   (B.Might_Be_False? [0] : []))

       [..] => 
         //  Preserve might-be-null ness
         //  and empty-ness
         const Set_Is_Empty := Is_Empty(Vals)
         return Countable_Value_Set::(Might_Be_Null => Vals.Might_Be_Null,
                  Possible_Values => Set_Is_Empty? []: [..])
      end case
   end func Countable_Vals

   func Countable_Vals(VN_Values : VN_To_Value_Set_Map_Type; VN : VN_Id)
     -> Countable_Value_Set is
      //  Return stored Countable_Value_Set of VN, or return an anything-goes
      //  value set (Might be null/-inf .. +inf) if nothing stored yet.
      if VN in VN_Values then
         //  Convert to Countable_Value_Set
         return Countable_Vals(VN_Values[VN])
      end if
      //  Anything goes
      return Countable_Value_Set::(Might_Be_Null => #true)
   end func Countable_Vals

   func Union_In_Vals
     (var Merged_VSet : optional Value_Set+;
      New_Vals : Value_Set+) is
      //  Union New_Vals into Merged_VSet.  Value_Kind might change.

      if Merged_VSet is null then
         //  Already the "universal" set so unioning is a no-op
         return
      end if

      const Merged_Kind := Value_Kind(Merged_VSet)
      const New_Val_Kind := Value_Kind(New_Vals)

      if Merged_Kind != New_Val_Kind then
         //  Convert one set to match the other
         case Merged_VSet of
            [CMV : Countable_Value_Set] =>
               CMV |= Countable_Vals(New_Vals)
            [BMV : Boolean_Value_Set] =>
               BMV |= Boolean_Vals(New_Vals)
            [OMV : Object_Value_Set] =>
               case New_Val_Kind of
                  [#Countable] =>
                     Merged_VSet := Countable_Vals(Merged_VSet)
                  [#Boolean] =>
                     Merged_VSet := Boolean_Vals(Merged_VSet)
                  [..] => {#false}
               end case
               Merged_VSet |= New_Vals
            [..] => {#false}
         end case
      else
         //  Kinds already match
         Merged_VSet |= New_Vals
      end if
   end func Union_In_Vals

   func Intersect_With_Vals
     (var Shared_VSet : optional Value_Set+;
      New_Vals : Value_Set+;
      Restore_If_Empty : Boolean := #false) -> How_Reduced is
      //  Intersect New_Vals with Shared_VSet.  Value_Kind might change.
      //  Return #reduced or #reduced_to_empty if Shared_VSet shrinks.
      //  If Restore_If_Empty is #true, and Shared_VSet would go to empty,
      //  restore it to its original value (though possibly converted to
      //  Boolean or Countable set)

      if Shared_VSet is null then
         //  Shared_VSet is null; just replace it with New_Vals
         Shared_VSet := New_Vals
         //  Indicate whether VSet shrunk
         if New_Vals is null then
            return #unchanged
         elsif Is_Empty(New_Vals) then
            if Restore_If_Empty then
               //  Restore to non-empty state
               Shared_VSet := null
            end if
            return #reduced_to_empty
         else
            return #reduced
         end if
      end if

      const Shared_Kind := Value_Kind(Shared_VSet)
      const New_Val_Kind := Value_Kind(New_Vals)
      var Orig_VSet := Shared_VSet  //  Remember original values

      if Shared_Kind != New_Val_Kind then
         //  Convert one set to match the other
         case Shared_VSet of
            [CSV : Countable_Value_Set] =>
               CSV and= Countable_Vals(New_Vals)
            [BSV : Boolean_Value_Set] =>
               BSV and= Boolean_Vals(New_Vals)
            [OSV : Object_Value_Set] =>
               case New_Val_Kind of
                  [#Countable] =>
                     Shared_VSet := Countable_Vals(Shared_VSet)
                     Orig_VSet := Shared_VSet
                  [#Boolean] =>
                     Shared_VSet := Boolean_Vals(Shared_VSet)
                     Orig_VSet := Shared_VSet
                  [..] => {#false}
               end case
               Shared_VSet and= New_Vals
            [..] => {#false}
         end case
      else
         //  Kinds already match
         Shared_VSet and= New_Vals
      end if

      //  Indicate whether VSet shrunk
      if Shared_VSet == Orig_VSet then
         return #unchanged
      elsif Is_Empty (Shared_VSet) then
         if Restore_If_Empty then
            //  Restore to original set
            Shared_VSet := Orig_VSet
         end if
         return #reduced_to_empty
      else
         return #reduced
      end if
   end func Intersect_With_Vals

   func Intersect_Value_Maps
     (var Combined_VN_Values : VN_To_Value_Set_Map_Type;
      VN_Values : VN_To_Value_Set_Map_Type) -> Changed_VNs : VN_Set is
     //  Combine Combined_VN_Values and VN_Values by intersecting
     //  their value sets
     //  Return set of VNs that have their value set reduced
      Changed_VNs := []

      for each [VN => VSet] of VN_Values loop
         if VN in Combined_VN_Values then
            //  Combine into the existing value set
            if Intersect_With_Vals(Combined_VN_Values[VN], VSet) !=
                 #unchanged
            then
               //  VN has had its set reduced
               Changed_VNs |= VN
            end if
         else
            //  No prior value set; set its value from VN_Values
            Combined_VN_Values[VN] := VSet
            if VSet not null then
               //  Value set changed
               Changed_VNs |= VN
            end if
         end if
      end loop
   end func Intersect_Value_Maps

   func Union_Value_Maps
     (var Join_Point_Vals : optional VN_To_Value_Set_Map_Type;
      Edge_Vals : optional VN_To_Value_Set_Map_Type) is
     //  Union Edge_Vals into Join_Point_Vals
     //  If Join_Point_Vals is null, replace with Edge_Vals.
     //  If Edge_Vals is null, this is a no-op.
      if Edge_Vals is null then
         null  //  Nothing to do
      elsif Join_Point_Vals is null then
         //  First edge of join point
         Join_Point_Vals := Edge_Vals
      else
         //  Combine value sets for each VN.  A missing VN is considered
         //  to have no restriction.
         for each [VN => VSet] of Join_Point_Vals loop
            if VN not in Edge_Vals then
               //  No restriction on edge, means no restriction on join
               Join_Point_Vals -= VN
            else
               //  Combine value sets
               Union_In_Vals(VSet, Edge_Vals[VN])
            end if
         end loop
      end if
     
   end func Union_Value_Maps

   //  Routines that do "careful" operations to avoid overflow
   func Saturating_Plus(Left, Right : Univ_Integer) -> Univ_Integer is
      const Half := Left/2 + Right/2
      if Half >= Univ_Integer::Last()/2 then
         return Univ_Integer::Last()
      elsif Half <= Univ_Integer::First()/2 then
         return Univ_Integer::First()
      else
         return Left + Right
      end if
   end func Saturating_Plus

   func Saturating_Minus(Left, Right : Univ_Integer) -> Univ_Integer is
      const Half := Left/2 - Right/2
      if Half >= Univ_Integer::Last()/2 then
         return Univ_Integer::Last()
      elsif Half <= Univ_Integer::First()/2 then
         return Univ_Integer::First()
      else
         return Left - Right
      end if
   end func Saturating_Minus

   func Saturating_Times(Left, Right : Univ_Integer) -> Univ_Integer is
      const Abs_Left := abs(Left)
      if Abs_Left > 1 then
         //  Check for overflow
         if abs(Right) > Univ_Integer::Last()/Abs_Left then
            //  Will overflow; determine sign
            if (Left > 0) == (Right > 0) then
               return Univ_Integer::Last()
            else
               return Univ_Integer::First()
            end if
         end if
      end if
      return Left * Right
   end func Saturating_Times

   func Put_Error (Message : Univ_String;
     Source_Pos : optional Reflection::Source_Position;
     Message_Kind : Univ_String := "Error") is
   //  Put out an error message on the standard error stream
   
      var IO := IO::Get_IO();
      if Source_Pos not null then
         IO.Stderr.Println("`(Source_Pos): `(Message_Kind): `(Message)")
         if Msg_File_Name not null then
            //  Append message to Msg_File
            var Msg_File := File_Output_Stream::Append(IO, Msg_File_Name)
            if Msg_File not null then
               Msg_File.Println("`(Source_Pos): `(Message_Kind): `(Message)")
               Msg_File.Close()
            end if
         end if
      else
         IO.Stderr.Println(Message_Kind | ": " | Message)
      end if
   end func Put_Error

   func Compare_VN_Vectors(Left, Right : Vector<VN_Id>) -> Ordering is
      if Length(Left) != Length(Right) then
         return Length(Left) =? Length(Right);
      else
         for (each L of Left; each R of Right) forward loop
            if L != R then
               return L =? R;
            end if;
         end loop;
         return #equal;
      end if;
   end func Compare_VN_Vectors;

   func Analyze_Operation (Item : Reflection::Decl) is
      //  Analyze one operation

      const Routine := Routine_For_Operation(Item);

      //  Establish a context for analysis
      var Op_Ctx : Analysis::Op_Ctx :=
        (Routine => Routine, Pass => #find_basic_blocks)

      Analysis::ParaScope::Analyze_Operation(Item, Op_Ctx)

   end func Analyze_Operation

   func Analyze(File_Name : Univ_String) is
      //  Analyze the code (if any) in the file named File_Name
      var Env := Reflection::Environment::Get_Current_Env()

      var Count := 0;

      for I in 1 .. Env.Num_Library_Items() forward loop
         const Item := Env.Nth_Library_Item(I);
        
         Count += Analyze_One_Decl(File_Name, Item)
      end loop

      if Count == 0 then
         Put_Warning("File not found (or contains no executable code): " |
           File_Name);
      end if

   end func Analyze
end class PSC::Analysis

import PSC::Reflection, PSC::Analysis::*
import PSC::CFG, PSC::Debugging

class PSC::Analysis::ParaScope is
   type Code_Offset is Reflection::Routine::Code_Offset

   const Zero_Base  := Object_Locator::Zero_Base;
   const Local_Area := Object_Locator::Local_Area;
   const Param_Area := Object_Locator::Param_Area;
   const Type_Area  := Object_Locator::Type_Area;
   const Const_Area := Object_Locator::Const_Area;
   const Enclosing_Param_Areas :=
      Object_Locator::Enclosing_Param_Areas;
   const Enclosing_Local_Areas :=
      Object_Locator::Enclosing_Local_Areas;
   const Enclosing_Type_Areas :=
      Object_Locator::Enclosing_Type_Areas;
   const Base_Registers := Object_Locator::Base_Registers;
   const Phys_Base_Registers :=
      Object_Locator::Phys_Base_Registers;

   func Is_Equal(Left, Right : VN_To_Value_Set_Map_Type) -> Boolean is
     //  Return True if Left and Right are equivalent maps
      if |Left| != |Right| then
         return #false
      else
         return (for all [K => V] of Left =>
            K in Right and then V == Right[K])
      end if
   end func Is_Equal

   func Unwrapped_Type_Desc (Type_Desc : Reflection::Type_Descriptor)
     -> Reflection::Type_Descriptor is
     //  Return a non-wrapper type descriptor, following op maps and wrappers
      if Type_Desc is null then
         return Type_Desc
      elsif Has_Op_Map (Type_Desc) then
         return Unwrapped_Type_Desc (Actual_Type (Type_Desc))
      elsif Is_Wrapper (Type_Desc) then
         return Unwrapped_Type_Desc (Components (Type_Desc)[1].Type_Desc)
      else
         return Type_Desc
      end if
   end func Unwrapped_Type_Desc

   func Dump_VNT (Op_Ctx; Max_VN : optional VN_Id) is
      //  Dump Value Number Table up to Max
      ref VNT => Op_Ctx.VN_Data.Table

      if Max_VN not null then
         for V in 1 .. Max_VN forward loop
            if V in VNT then
               var Attribs := ""
               if V in Op_Ctx.Boolean_VNs then
                  if V in Op_Ctx.CTK_VNs then
                     Attribs := "[BC]"
                  else
                     Attribs := "[B]"
                  end if
               elsif V in Op_Ctx.CTK_VNs then
                  Attribs := "[C]"
               end if
                  
               case VNT[V] of
                  [Call : Call_VN] =>
                     //  Try to print out name of routine being called
                     Print("  VN" | V | Attribs | ":" | Call)
                     const Routine_Id :=
                       Int_Literal_Value (VNT, Call.Routine_Id)
                     if Routine_Id not null then
                        const Routine :=
                          Reflection::Routine::Routine_At_Index(Routine_Id)
                        if Routine not null then
                           Print(" = " | Routine.Name())
                           const Desig := Routine.Built_In_Desig();
                           if Desig not null then
                              if Desig[1] != '#' then
                                 Print(" (#`(Desig))")
                              else
                                 Print(" (`(Desig))")
                              end if
                           end if
                        end if
                     end if
                     Print('\n')
                  [Phi : Phi_VN] =>
                     //  Print out input vector for phi
                     Print("  VN`(V | Attribs):`(Phi)")
                     ref Inputs => Op_Ctx.VN_Data.Phi_Id_Inputs[V]
                     Println("[" | (for (each Input of Inputs forward;
                                         Sep := "" then ", ") =>
                                      <""> | Sep | "VN" | Input) | "]")

                  [..] =>
                     Println("  VN`(V | Attribs):`(VNT[V])")
               end case
            end if
         end loop
      end if
   end func Dump_VNT

   func Dump_OIT (Op_Ctx; Max_OID : optional OID) is
      //  Dump OID Table up to Max
      ref OIT => Op_Ctx.OI_Data.Table

      if Max_OID not null then
         for O in 1 .. Max_OID forward loop
            if O in OIT then
               case OIT[O] of
                  [Phi : Phi_Origin] =>
                     //  Print out input vector for phi
                     Print("  OID`(O):`(Phi)")
                     ref Inputs => Op_Ctx.OI_Data.Phi_Id_Inputs[O]
                     Println("[" | (for (each Input of Inputs forward;
                                         Sep := "" then ", ") =>
                                      <""> | Sep | "OID" | Input) | "]")

                  [..] =>
                     Println("  OID`(O):`(OIT[O])")
               end case
            end if
         end loop
      end if
   end func Dump_OIT

   func Dump_UVT (Op_Ctx; var Max_OID_Seen : optional OID) is
      //  Dump Updated-Value Table
      ref UVT => Op_Ctx.OID_To_UV_Map

      for each [O => UV] of UVT loop
         Println("  OID`(O) => `(UV)")
         Max_OID_Seen := Max(Max_OID_Seen, O)
      end loop
   end func Dump_UVT

   func Dump_Addr_OID_Value_Maps(Op_Ctx) is
      //  Dump mapping of addresses to OIDs to value numbers,
      //  and the definition of each value number.
      ref A2O => Op_Ctx.Addr_To_OID_Map
      ref O2V => Op_Ctx.OID_To_VN_Map
      ref O2UV => Op_Ctx.OID_To_UV_Map
      ref VNT => Op_Ctx.VN_Data.Table

      var Max_VN_Seen : optional VN_Id := null
      var Max_OID_Seen : optional OID := null
      Println ("Addr to Value Map:")
      for each [A => O] of A2O forward loop
         Println(" [VN`(A) => OID`(O)]")
         Max_VN_Seen := Max(Max_VN_Seen, A)
         Max_OID_Seen := Max(Max_OID_Seen, O)
      end loop
      for each [O => V] of O2V forward loop
         Println(" [OID`(O) => VN`(V)]")
         if Op_Ctx.Has_Updated_Value(O) then
            Println("    => UV ");
         end if;
         Max_OID_Seen := Max(Max_OID_Seen, O)
         Max_VN_Seen := Max(Max_VN_Seen, V)
      end loop
      Dump_UVT (Op_Ctx, Max_OID_Seen);
      Dump_VNT (Op_Ctx, Max_VN_Seen)
      Dump_OIT (Op_Ctx, Max_OID_Seen)
   end func Dump_Addr_OID_Value_Maps

   func Report_Failure
     (var Op_Ctx; Instr_Index : optional Code_Index;
      Failing_VN : VN_Id;
      Source_Pos : Reflection::Source_Position;
      Certain_To_Fail : Boolean) is
     //  Generate a message based on assertion about VN failing.
     //  If not yet in error-generating phase, this merely keeps
     //  track that some error was found, so a final error-generating
     //  pass is worthwhile.

      var Is_Not_Null_Check : Boolean := #false

      func Source_Pos_For_Exit(Exit_Instr : Code_Index)
        -> Reflection::Source_Position is
        //  Exit instructions don't generally have source positions
        //  so here we try to figure out what it is.
         const Exit_Node := Op_Ctx.Enclosing_Node(Exit_Instr)
         const Nested_Block_Entry := Op_Ctx.Entry_Node_For_BB(Exit_Node)
         const Nested_Block_Preds :=
           Op_Ctx.CFG.Predecessors(Nested_Block_Entry)
         {|Nested_Block_Preds| == 1}  //  Should be only one caller
         const Nested_Block_Caller_BB := Nested_Block_Preds[1]
         const Check_Block_Instr := Op_Ctx.CFG[Nested_Block_Caller_BB].Last
         
         return Source_Pos(Op_Ctx.Routine.Nth_Instr(Check_Block_Instr))
      end func Source_Pos_For_Exit

      func Default_Msg() is
         if Certain_To_Fail then
            //  Look at VN to determine appropriate message
            if Is_Not_Null_Check then
               Put_Error("Null value not allowed here",
                 Source_Pos => Source_Pos)
            else
               Put_Error("Check will fail here (" |
                   Op_Ctx.VN_Data.Table[Failing_VN] | ")",
                 Source_Pos => Source_Pos)
            end if
         else
            //  Look at VN to determine appropriate message
            if Is_Not_Null_Check then
               Put_Warning("Value might be null",
                 Source_Pos => Source_Pos)
            else
               Put_Warning("Check might fail here (" |
                   Op_Ctx.VN_Data.Table[Failing_VN] | ")",
                 Source_Pos => Source_Pos)
            end if
         end if
      end func Default_Msg

      if Op_Ctx.Propagating_Values then
         //  Don't report errors now; report them in the final pass
         Op_Ctx.Error_Found_During_Propagation := #true
         return  /////// return now ////////
      end if

      //  Check for kind of Failing_VN
      case Op_Ctx.VN_Data.Table[Failing_VN] of
         [NN : Not_Null_VN] =>
            case Op_Ctx.VN_Data.Table[NN.Tested_Val] of
               [UN : Unknown_VN] =>
                  if Debug then
                     Println("Report_Failure called with Unknown_VN VN" |
                       Failing_VN | ":" | UN)
                  end if
                  return  //  Ignore errors involving Unknown_VNs, as these
                          //  have already been reported.

               [..] =>
                  null
            end case
            Is_Not_Null_Check := #true

         [UN : Unknown_VN] =>
            if Debug then
               Println("Report_Failure called with Unknown_VN VN" |
                 Failing_VN | ":" | UN)
            end if
            return  //  Ignore errors involving Unknown_VNs, as these have
                    //  already been reported.

         [..] =>
            null
      end case

      if Instr_Index is null then
         //  Used for uninitialized variable retrieval
         //  TBD: Should have a better way of indicating this
         case Op_Ctx.VN_Data.Table[Failing_VN] of
            [PA : Param_Addr_VN] =>
               Put_Error("Uninitialized function result", Source_Pos)
            [..] =>
               Put_Error("Fetch of undefined value at VN" |
                 Failing_VN | ':' |
                 Op_Ctx.VN_Data.Table[Failing_VN], Source_Pos)
         end case
      elsif Certain_To_Fail then
         //  Treat these as errors
         case Opcode(Op_Ctx.Routine.Nth_Instr(Instr_Index)) of
            [#Check_Not_Null_Op] =>
               Put_Error("Null value not allowed here",
                 Source_Pos => Source_Pos)
            [#Check_Nested_Block_Op] =>
               Put_Error("Assertion will fail here",
                 Source_Pos => Source_Pos)
            [#Exit_Op] =>
               Put_Error("Assertion will fail here",
                 Source_Pos => Source_Pos_For_Exit(Instr_Index))
            [#Call_Op | #Start_Parallel_Call_Op |
              #Add_Parallel_Call_Op] =>
               Put_Error("Precondition not satisfied here",
                 Source_Pos => Source_Pos)
            [#Return_Op] =>
               Put_Error("Postcondition not satisfied here",
                 Source_Pos => Source_Pos)
            [..] =>
               Default_Msg()
         end case
      else
         //  Treat these as warnings
         case Opcode(Op_Ctx.Routine.Nth_Instr(Instr_Index)) of
            [#Check_Not_Null_Op] =>
               Put_Warning("Value might be null",
                 Source_Pos => Source_Pos)
            [#Check_Nested_Block_Op] =>
               Put_Warning("Assertion might fail",
                 Source_Pos => Source_Pos)
            [#Exit_Op] =>
               Put_Warning("Assertion might fail",
                 Source_Pos => Source_Pos_For_Exit(Instr_Index))
            [#Call_Op | #Start_Parallel_Call_Op |
              #Add_Parallel_Call_Op] =>
               if Is_Not_Null_Check then
                  Put_Warning("Operand might be null",
                    Source_Pos => Source_Pos)
               else
                  Put_Warning("Precondition might fail here",
                    Source_Pos => Source_Pos)
               end if
            [#Return_Op] =>
               Put_Warning("Postcondition might fail here",
                 Source_Pos => Source_Pos)
            [..] =>
               Default_Msg()
         end case
      end if

   end func Report_Failure

   func Component_Selector_Kind(Op_Ctx; Selector : VN_Id)
     -> optional Component_Selector_VN::Selector_Kind is
     //  Return #named, #static_index, #dynamic_index, #referenced_part,
     //  or null, depending on kind of Selector.
      case Op_Ctx.VN_Data.Table[Selector] of
         [Comp : Component_Selector_VN+] =>
            return Kind(Comp)
         [..] =>
            return null
      end case
   end func Component_Selector_Kind

   func Might_Overlap(var Op_Ctx;
     New_Selector : VN_Id; Existing_Components : VN_To_VN_Map_Type)
     -> Boolean is
     //  Return #true if there is a possibility that the component identified
     //  by New_Selector might overlap with one of the components currently
     //  identified by the selectors in the Existing_Components map
      for each [Sel => Val] of Existing_Components loop
         case Op_Ctx.VN_Data.Table[New_Selector] of
            [Named : Named_Selector_VN] =>
               case Op_Ctx.VN_Data.Table[Sel] of
                  [Existing_Named : Named_Selector_VN] =>
                     if Sel == New_Selector then
                        //  A definite overlap
                        return #true
                     end if

                     //  These don't match, keep checking for an overlap ...
                  [Existing_Indexed : Indexed_Selector_VN] =>
                     //  Named and indexed always conflict
                     return #true
                  [..] => {#false}
               end case
            [Indexed : Indexed_Selector_VN] =>
               case Op_Ctx.VN_Data.Table[Sel] of
                  [Existing_Named : Named_Selector_VN] =>
                     //  Named and indexed always conflict
                     return #true
                  [Existing_Indexed : Indexed_Selector_VN] =>
                     //  Two indexed, these might overlap unless
                     //  everything is static and different
                     //  and this is an "indexing" operation.
                     if not Indexed.Is_Indexing_Op 
                       or else not Existing_Indexed.Is_Indexing_Op
                       or else not Indexed.Is_Static_Indexing
                       or else not Existing_Indexed.Is_Static_Indexing
                       or else
                         Indexed.Indexing_Routine_Id !=
                           Existing_Indexed.Indexing_Routine_Id
                       or else
                         |Indexed.Indexing_Operands| !=
                           |Existing_Indexed.Indexing_Operands|
                     then
                        //  Not all static and for same indexing dimension
                        return #true
                     else
                        //  All indexing operands are literals.
                        //  They overlap only if all operands match.
                        if (for all I in 1 .. |Indexed.Indexing_Operands|
                             => Indexed.Indexing_Operands[I] ==
                                  Existing_Indexed.Indexing_Operands[I]) then
                           //  All match, so we have an overlap
                           return #true
                        end if

                        //  These are for different indices; keep checking ...
                     end if
                  [..] => {#false}
               end case
            [..] => {#false}  //  Should not occur
         end case
      end loop
      //  Doesn't overlap with anything
      return #false
   end func Might_Overlap

   func Assert_Non_Null(var Op_Ctx; VN : VN_Id; Instr_Index : Code_Index) is
     //  Add an assertion that VN does not have the null value, associated
     //  with the given instruction.
      const NN_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
                       (Not_Null_VN::(Tested_Val => VN))

      Op_Ctx.Boolean_VNs |= NN_Val

      if Instr_Index not in Op_Ctx.Instr_To_Assertions_Map then
         Op_Ctx.Instr_To_Assertions_Map[Instr_Index] := [NN_Val]
      else
         Op_Ctx.Instr_To_Assertions_Map[Instr_Index] |= NN_Val
      end if
   end func Assert_Non_Null

   func Aggr_Base(Op_Ctx; Aggr_Val : VN_Id) -> Result : VN_Id is
     //  If Aggr_Val is an Aggregate_VN with a non-null Base, follow
     //  that until a non-Aggregate_VN is found or an Aggregate_VN with
     //  a null base.
      Result := Aggr_Val
      
      loop
         case Op_Ctx.VN_Data.Table[Result] of
            [Aggr : Aggregate_VN] =>
                if Aggr.Base_Val is null then
                   //  We reached an Aggregate with a null base
                   return
                end if

                //  Continue with base of this aggregate
                Result := Aggr.Base_Val
            [..] =>
                //  Not an aggregate vn
                return
         end case
      end loop
   end func Aggr_Base

   func Remember_Fetched_Value
     (var Op_Ctx; Source_Addr : Addr_VN_Id; Result : VN_Id) is
     //  Remember that a fetch from locator for Source_Addr gave Result
     //  which might be of interest to LLVM code generator.

      Op_Ctx.Addr_Fetch_VNs |= [Source_Addr => Op_Ctx.Aggr_Base(Result)]
   end func Remember_Fetched_Value

   func Get_Indexing_Routine_Index (Array_Type : Reflection::Type_Descriptor)
     -> optional Reflection::Routine_Index is
     //  Return "indexing" Routine given some instance of Basic_Array
      for each Op of Operations (Array_Type) loop
         //  See whether routine has name "indexing"
         const Routine_For_Op :=
           Reflection::Routine::Routine_At_Index (Op.Index)
         const Desig := Built_In_Desig (Routine_For_Op)

         if Desig not null and then Desig == "#basic_array_indexing" then
            //  Found it
            return Op.Index
         end if
      end loop

      //  Not found

      Println(" ** Get_Indexing_Routine_Index: indexing op not found for " |
        Name (Array_Type))

      for each Op of Operations (Array_Type) loop
         //  Show names of routines actually found
         const Routine_For_Op :=
           Reflection::Routine::Routine_At_Index (Op.Index)

         Println("   Found: " | Name (Routine_For_Op))
      end loop

      {*indexing_op_not_found* #false}
      return null
   end func Get_Indexing_Routine_Index

   func Fetch_OID_Value(var Op_Ctx; Source_OID : OID;
      Source_Pos : Reflection::Source_Position;
      Instr_Index : Code_Index;
      Source_Addr : optional Addr_VN_Id := null) -> VN_Id
     // Fetch VN at given OID

   func Fetch_Value(var Op_Ctx; Source_Addr : Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+;
      Might_Be_Null : Boolean := #true) -> VN_Id
     // Fetch VN at given address

   func Fetch_OID_Base_Value(var Op_Ctx; Source_OID : OID;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+;
      Source_Addr : optional Addr_VN_Id := null) -> VN_Id is
     // Fetch VN at given OID only to determine whether it is null,
     // or to look "beneath" updates of Updated_Value.
     // If addr has Updated_Value, fetch underlying value of Updated value.

      if Source_OID in Op_Ctx.OID_To_UV_Map then
         //  Fetch Base_Val of Updated_Value
         return Op_Ctx.OID_To_UV_Map[Source_OID].Base_Val
      else
         //  No Updated_Value, just fetch current value
         return Fetch_OID_Value (Op_Ctx, Source_OID, Source_Pos,
                                   Instr_Index (Origin), Source_Addr)
      end if;
   end func Fetch_OID_Base_Value

   func Fetch_Base_Value(var Op_Ctx; Source_Addr : Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+;
      Might_Be_Null : Boolean := #true) -> Source_Base_Value : VN_Id is
     // Fetch VN at given address only to determine whether it is null.
     // If addr has Updated_Value, fetch underlying value of Updated value.
     // Remember fetched value in table used by compiler

      Source_Base_Value := Fetch_OID_Base_Value
        (Op_Ctx,
         Get_OID (Op_Ctx, Source_Addr, Source_Pos, Origin, Might_Be_Null),
         Source_Pos,
         Origin)

      //  Remember Source_Addr contained Source_Base_Value
      Op_Ctx.Remember_Fetched_Value (Source_Addr, Source_Base_Value)
   end func Fetch_Base_Value

   func Get_Updated_Value (ref var Op_Ctx; Base_Obj : OID;
     Selector : Component_Selector_VN::Component_Selector_VN_Id;
     Source_Pos : Reflection::Source_Position;
     Instr_Index : Code_Index) -> ref var Updated_Value is
     //  Return Updated_Value associated with Base_Obj, which uses same
     //  Kind_Of_Selector as Selector.
     //  Create one if necessary.

      //  Determine Kind of Selector (null if not a selector)
      const Kind := Op_Ctx.Component_Selector_Kind(Selector)
         
      if Kind not null
        and then (Base_Obj not in Op_Ctx.OID_To_UV_Map
                    or else
                  Op_Ctx.OID_To_UV_Map[Base_Obj].Kind_Of_Selectors != Kind)
      then
         //  Create a new Updated_Value with appropriate kind of selector
         var New_UV : optional Updated_Value for Op_Ctx := 
             (Base_Val => Op_Ctx.Fetch_OID_Value
                            (Base_Obj, Source_Pos, Instr_Index),
              Kind_Of_Selectors => Kind)
         Op_Ctx.OID_To_UV_Map[Base_Obj] <== New_UV
      end if

      //  Return ref to Updated_Value
      return Op_Ctx.OID_To_UV_Map[Base_Obj]
   end func Get_Updated_Value

   func Store_OID
     (var Op_Ctx;
      Dest_Addr : Addr_VN_Id; New_OID : OID;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) is
      //  Add [Dest_Addr => OID] into Op_Ctx.Addr_To_OID_Map
      //  Deal with assignments to base objects and their components
      //  
      case Op_Ctx.VN_Data.Table[Dest_Addr] of
         [Component  : Component_Addr_VN] =>
            // Storing through a component address
            // * TBD: Add an assertion that the base object is not null
            //   (that might have been done when address VN was created).
            // * Find/Create Updated value representing object
            //   - This might involve recursion if base object is itself
            //     identified by a component address
            // * Add new OID to appropriate map/stack of updated value.
            const Base_Obj := Component.Base_Obj
            const Selector := Component.Selector
            ref Base_Val =>
              Get_Updated_Value
                (Op_Ctx, Base_Obj, Selector, Source_Pos, Instr_Index (Origin))

            //  Updated value has mapping from selector to OID
            //  The basic block's OID=>VN and OID=>Updated_Value maps are
            //  used both for components and for whole objects.
            Base_Val.Component_OIDs |= [Selector => New_OID]
            Op_Ctx.Component_OID_To_Addr_Map |= [New_OID => Dest_Addr]
            if Debug then
               Println("Store_OID adding [VN" | Dest_Addr |
                 " <=> OID" | New_OID | "] to two-way component map")
            end if

            if Debug then
               Println("Store_OID adding [VN`(Selector) => OID`(New_OID)]" |
                 " to UV for OID" | Base_Obj)
            end if
         [..] =>
            //  Not a component address;
            null
      end case

      //  Add new value to the AO map for Dest_Addr
      Op_Ctx.Addr_To_OID_Map |= [Dest_Addr => New_OID]

      if Debug then
         Println
           ("Store_OID adding [VN`(Dest_Addr) => OID`(New_OID)] to AO map")
      end if

      if Debug then
         Println("Storing OID`(New_OID):`(Op_Ctx.OI_Data.Table[New_OID])" |
           " into VN`(Dest_Addr):`(Op_Ctx.VN_Data.Table[Dest_Addr])")
      end if
   end func Store_OID

   func Store_OID_Value
     (var Op_Ctx;
      Dest_OID : OID; New_Val : VN_Id;
      Source_Pos : Reflection::Source_Position) is
      //  Add [Dest_OID => New_Val] into Op_Ctx.OID_To_VN_Map
      //  Deal with assignments to base objects and their components
      //  
      if Dest_OID in Op_Ctx.OID_To_VN_Map
        and then Op_Ctx.OID_To_VN_Map[Dest_OID] == New_Val
      then
         //  Redundant assignment
         case Op_Ctx.VN_Data.Table[New_Val] of
            [Null_Val : Null_Literal_VN] =>
               //  Ignore redundant assign of null
               null
            [..] =>
               Put_Warning("Redundant assign to OID`(Dest_OID):" |
                 Op_Ctx.OI_Data.Table[Dest_OID] |
                 " of value it already has -- VN`(New_Val):" |
                 Op_Ctx.VN_Data.Table[New_Val],
                 Source_Pos)
         end case
         return
      end if

      //  Add new value to the OV map for Dest_Addr
      Op_Ctx.OID_To_VN_Map |= [Dest_OID => New_Val]

      if Debug then
         Println("Storing VN`(New_Val):`(Op_Ctx.VN_Data.Table[New_Val]) into" |
          " OID`(Dest_OID):`(Op_Ctx.OI_Data.Table[Dest_OID])")
      end if
   end func Store_OID_Value

   func Has_Updated_Value
     (Op_Ctx; Composite_OID : OID;
      Selector :
        optional Component_Selector_VN::Component_Selector_VN_Id := null)
     -> Boolean is
     //  Return #true if given Composite_OID has an updated value.
     //  If selector is non-null, return #true only if Selector kind
     //  matches UV selector kind.
      if Composite_OID not in Op_Ctx.OID_To_UV_Map then
         return #false
      elsif Selector is null then
         return #true
      else
         //  Check for match of selector kinds
         const Kind := Op_Ctx.Component_Selector_Kind(Selector)
         return Kind not null
           and then
               Op_Ctx.OID_To_UV_Map[Composite_OID].Kind_Of_Selectors == Kind
      end if
   end func Has_Updated_Value

   func Freeze_Updated_Value(var Op_Ctx;
      Composite_OID : OID;
      Source_Pos : Reflection::Source_Position;
      Instr_Index : Code_Index) is
     //  Freeze updated value of given Composite_OID, if any
      if Composite_OID in Op_Ctx.OID_To_UV_Map then
         ref UV => Op_Ctx.OID_To_UV_Map[Composite_OID]
         var Components : VN_To_VN_Map_Type := []
         var Base_Val := UV.Base_Val;
         const Selector_Kind := UV.Kind_Of_Selectors
         if Debug then
            Println("Freezing OID`(Composite_OID) => `(UV)")
         end if

         var Type_Info : Object_Locator;
              
         if Base_Val not null then
            //  Check whether selector kinds match
            case Op_Ctx.VN_Data.Table[Base_Val] of
               [Agg : Aggregate_VN] =>
                  //  See whether can integrate Base_Val with the updates
                  if Agg.Kind_Of_Selectors == Selector_Kind then
                     //  Kind of selectors match, use Base of Base
                     Base_Val := Agg.Base_Val;
                     Components := Agg.Components;
                  end if
                  Type_Info := Agg.Type_Info;
               [TVN : Typed_VN+] =>
                  //  Base_Val not an aggregate
                  Type_Info := TVN.Type_Info;
               [..] =>
                  //  Base_Val not a Typed_VN --> Should not happen
                  {#false}
            end case
         end if
         //  Build up new Aggregate VN
         for each [Selector => Comp_OID] of UV.Component_OIDs loop
            const Comp_Val := Fetch_OID_Value
                                (Op_Ctx, Comp_OID, Source_Pos, Instr_Index)
            Components |= [Selector => Comp_Val]
         end loop
         const Comp_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id
                               (Aggregate_VN::
                                (Type_Info => Type_Info,
                                 Might_Be_Null => #false,
                                 Base_Val => Base_Val,
                                 Kind_Of_Selectors => Selector_Kind,
                                 Components => Components));
         Op_Ctx.OID_To_UV_Map -= Composite_OID
         Store_OID_Value(Op_Ctx, Composite_OID, Comp_Value, Source_Pos)
      end if
   end func Freeze_Updated_Value

   func Get_Component_OID
     (var OIT : OID_Table;
      var All_Component_OIDs : Set<OID>;
      Component_Addr : VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+) -> Result : OID is
     //  Get OID for a component.  Defer getting value in case
     //  component is itself a composite object.
     //  NOTE: We don't take Op_Ctx as a whole to avoid aliasing problems.

      Result := OIT.Get_Unique_Id (Origin)
      //  Add component to list of component OIDs
      All_Component_OIDs |= Result
      if Debug then
         Println("Get_Component_OID adding OID`(Result) " |
           "(Addr: VN`(Component_Addr)) to All_Component_OIDs set")
      end if
   end func Get_Component_OID

   func Set_Component_OID
     (var All_Component_OIDs : Set<OID>;
      Component_Addr : VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+; New_OID : OID) is

      //  Add New_OID to set of components
      All_Component_OIDs |= New_OID

      if Debug then
         Println("Set_Component_OID adding OID`(New_OID) " |
           "(Addr VN`(Component_Addr)) to All_Component_OIDs")
      end if
   end func Set_Component_OID

   func Create_Phi_OID (var OI_Data : OI_Data_Record; CFG;
      Node : CFG::Node_Id;
      Source_Addr : Addr_VN_Id;
      Common_OID : OID) -> Result : OID is
     //  Create a Phi_Origin OID in the given Node, for the given Source_Addr.
     //  Initialize its vector of input OIDs to the given Common_OID value

      Result := OI_Data.Table.Get_Unique_Id
                  (Phi_Origin::(Phi_Block => Node,
                                Phi_Addr => Source_Addr))

      //  Remember we created a Phi OID in this node
      if Node not in OI_Data.Node_Phi_Id_Maps then
         OI_Data.Node_Phi_Id_Maps[Node] := [Source_Addr => Result]
      else
         OI_Data.Node_Phi_Id_Maps[Node] |= [Source_Addr => Result]
      end if

      //  Initialize the input vector for the Phi OID
      const Num_In_Edges := |CFG[Node].Incoming_Edges|

      OI_Data.Phi_Id_Inputs |=
        [Result => Create(Num_In_Edges, Common_OID)]

      if Debug_Phis then
         Println(" Create_Phi_OID`(Result) in BB`(Node)," |
                   " Addr VN`(Source_Addr)," |
                   " Initial input = OID`(Common_OID)")
      end if
   end func Create_Phi_OID

   func Get_OID(var Op_Ctx; Source_Addr : Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+;
      Might_Be_Null : Boolean := #true) -> OID is
     // Fetch/Create OID associated with given address

      func Get_OID_From_Block(var AO_Map : VN_To_OID_Map_Type;
        Node : CFG::Node_Id) -> OID is
        //  Get an OID starting from the given block.  If a block has
        //  multiple predecessors, check whether they all produce the same OID.
        //  If not, create a phi OID.
        //  Ignore back-edges at this time.  When finishing a block with an
        //  outgoing back edge, we will check whether a phi needs to be
        //  created, or already has been.  We will at that time fill in the
        //  OID for the incoming back edge.
        //  If we reach the entry node, then create either an input OID or
        //  an unknown OID as appropriate, with an appropriate error message.
        //  TBD: Handle aggregates properly, and also "obviously" dead edges.

         if AO_Map is null then
            if Debug then
               Println("AO_Map null in Getting OID from block BB`(Node)" |
                 " for VN`(Source_Addr):" |
                 Op_Ctx.VN_Data.Table[Source_Addr])
            end if
            AO_Map := []
         end if

         //  First check if we already have an OID for the Source_Addr.
         if Source_Addr in AO_Map then
            //  Address already in the block's AO map
            const Existing_OID := AO_Map[Source_Addr]

            if not Might_Be_Null then
               //  Check whether we might lose information about nullness
               case Op_Ctx.OI_Data.Table[Existing_OID] of
                  [Input : Input_Origin] =>
                     if Source_Addr not in Op_Ctx.Non_Null_Inputs then
                        // Source_Addr has wrong sense for might-be-null
                        // perhaps due to use in a Store_Null_Of_Same_Stg_Rgn.
                        // Add it to the non-null inputs set now.
                        Op_Ctx.Non_Null_Inputs |= Source_Addr;
                        if Debug then
                           Println(" Adding Addr-VN`(Source_Addr):" |
                             Op_Ctx.VN_Data.Table[Source_Addr] |
                             " to set of non-null inputs")
                        end if
                     end if
                  [..] =>
                     null
               end case
            end if

            if Debug then
               Println("Getting OID`(Existing_OID):" |
                 Op_Ctx.OI_Data.Table[Existing_OID] |
                 " from VN`(Source_Addr):" |
                 Op_Ctx.VN_Data.Table[Source_Addr])
            end if
            return Existing_OID
         end if

         var Is_Input : Boolean := #false
         var Result : optional OID := null

         //  Handle special sorts of addresses (components; type-relative)
         case Op_Ctx.VN_Data.Table[Source_Addr] of
            [Component : Component_Addr_VN] =>
               // A component address
               // Associate it with an OID

               Result := Op_Ctx.OI_Data.Table.Get_Component_OID
                           (Op_Ctx.All_Component_OIDs,
                            Source_Addr, Source_Pos, Origin)

               //  Record address associated with OID in op-wide map
               //  when we fetch from a component.
               //  TBD: Is this the best way to remember this?
               Op_Ctx.Component_OID_To_Addr_Map |= [Result => Source_Addr]
               
               if Debug then
                  Println("Fetching (component) OID`(Result):" |
                    Op_Ctx.OI_Data.Table[Result] |
                    " from VN`(Source_Addr):" |
                    Op_Ctx.VN_Data.Table[Source_Addr])
               end if

            [Type_Rel : Type_Addr_VN] =>
               //  This is an input
               Is_Input := #true
               
            [Const : Const_Area_VN] =>
               Is_Input := #true
               
            [..] =>
               null
         end case

         if Is_Input then
            Result := Op_Ctx.OI_Data.Table.Get_Unique_Id
                                (Input_Origin::(Input_Addr => Source_Addr))
         end if

         if Result is null then
            //  See how many incoming edges we have
            ref In_Edges => Op_Ctx.CFG[Node].Incoming_Edges

            case |In_Edges| of
               [0] =>
                  // Entry block, fall through
                  null

               [1] =>
                  // Recurse
                  ref Only_Edge => Op_Ctx.CFG.Nth_Edge(In_Edges[1])
                  Result := Get_OID_From_Block
                                    (Op_Ctx.OI_Data.Node_To_Id_Map
                                                        [Only_Edge.From],
                                     Only_Edge.From)

               [..] =>
                  // Multiple incoming edges, see whether all produce same OID
                  var Common_OID : optional OID := null
                  ref DT => Op_Ctx.CFG.Get_Dominator_Tree()

                  if Node in Op_Ctx.OI_Data.Node_Phi_Id_Maps
                    and then
                      Source_Addr in Op_Ctx.OI_Data.Node_Phi_Id_Maps[Node]
                  then
                     //  Phi already created.  Re-use it.
                     Result :=
                       Op_Ctx.OI_Data.Node_Phi_Id_Maps[Node][Source_Addr]
                  end if

                  for each [In_Edge_Num => In_Edge_Id] of In_Edges
                    {not DT.Is_Back_Edge(In_Edge_Id)}  //  Ignore back edges
                  loop
                     ref In_Edge => Op_Ctx.CFG.Nth_Edge(In_Edge_Id)

                     const In_OID := Get_OID_From_Block
                                    (Op_Ctx.OI_Data.Node_To_Id_Map
                                                        [In_Edge.From],
                                     In_Edge.From)

                     
                     if Result not null then
                        //  Have already created a phi, just continue
                        //  to initialize the vector of input OIDs
                        Op_Ctx.OI_Data.Phi_Id_Inputs[Result][In_Edge_Num] :=
                          In_OID

                     elsif Common_OID is null then
                        //  First edge, just remember the OID
                        Common_OID := In_OID

                     elsif In_OID != Common_OID then
                        //  First edge that doesn't equal Common_OID
                        //  Need to create a phi
                        Result :=
                          Op_Ctx.OI_Data.Create_Phi_OID
                            (Op_Ctx.CFG, Node, Source_Addr, Common_OID)

                        //  Fill in this edge's input OID
                        Op_Ctx.OI_Data.Phi_Id_Inputs[Result][In_Edge_Num] :=
                          In_OID

                     end if
                  end loop

                  if Result is null then
                     //  Got same value from all (non-back-edge) inputs
                     {Common_OID not null} // Common_OID should have been set
                     Result := Common_OID
                     if DT.Is_Loop_Header(Node) then
                        //  Remember the value we got at this loop header
                        //  so when we process the block with an outgoing
                        //  back edge to this block, we can check whether
                        //  the OID there matches the Common_OID
                        if Node not in Op_Ctx.OI_Data.Loop_Header_Id_Map then
                           Op_Ctx.OI_Data.Loop_Header_Id_Map[Node] :=
                             [Source_Addr => Result]
                        else
                           Op_Ctx.OI_Data.Loop_Header_Id_Map[Node] |=
                             [Source_Addr => Result]
                        end if
                        if Debug_Phis then
                           Println(" Recording common OID" | Result |
                                   " for Addr VN" | Source_Addr |
                                   " in loop header BB" | Node)
                        end if
                     end if
                     
                  end if

            end case
         end if

         if Result is null then
            // Straight shot from entry block, and no definitions
            // See whether Source_Addr is an "Input" VN, in which
            // case the content of such a VN is itself an input.
            case Op_Ctx.VN_Data.Table[Source_Addr] of
               [Input : Input_VN] =>
                  //  Address is an input, so initial value must be as well
                  Is_Input := #true

               [Param : Param_Addr_VN] =>
                  //  Treat as an input if for a root or for a nested block
                  //  outside the current out-of-line block.
                  Is_Input := Param.BB_Id in Op_Ctx.CFG.Roots()
                                 or else
                              Param.Level < Op_Ctx.Cur_Out_Of_Line_Level
                        

               [Local : Local_Addr_VN] =>
                  //  Treat as an input if not from the current out-of-line
                  //  block.
                  Is_Input := Local.Level < Op_Ctx.Cur_Out_Of_Line_Level
                  
               [..] =>
                   null  //  Fall through
                
            end case

            if Is_Input then
               //  Treat as an input
               Result := Op_Ctx.OI_Data.Table.Get_Unique_Id
                                   (Input_Origin::(Input_Addr => Source_Addr))
               if Debug then
                  Println("Fetching (input) OID`(Result):" |
                    Op_Ctx.OI_Data.Table[Result] |
                    " from VN`(Source_Addr):" | 
                    Op_Ctx.VN_Data.Table[Source_Addr])
               end if

            elsif Result is null then
               //  Should have been initialized

               case Op_Ctx.VN_Data.Table[Source_Addr] of
                  [PA : Param_Addr_VN] =>
                     Put_Error("Uninitialized function result", Source_Pos)
                  [..] =>
                     Put_Error("Fetch of undefined value at VN" |
                       Source_Addr | ':' |
                       Op_Ctx.VN_Data.Table[Source_Addr], Source_Pos)
               end case

               Result := Op_Ctx.OI_Data.Table.Get_Unique_Id (Origin)

               //  Record an Unknown_VN in OV Map
               const Unknown_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
                              (Unknown_VN::(Type_Info => null,
                                            Might_Be_Null => #true,
                                            Unknown => Source_Addr))

               if Node == Op_Ctx.Cur_Node_Id then
                  //  Current block
                  Op_Ctx.OID_To_VN_Map |= [Result => Unknown_Val]
               else
                  //  Some predecessor block
                  Op_Ctx.VN_Data.Node_To_Id_Map[Node] |=
                    [Result => Unknown_Val]
               end if
            end if
         end if

         {Result not null}

         if Is_Input and not Might_Be_Null then
            //  Add Source_Addr to set of non-null inputs
            Op_Ctx.Non_Null_Inputs |= Source_Addr
         end if

         //  Record result in AO map
         //  NOTE: We record this in this block's AO_Map rather than that
         //        for the current block, as our lazy approach
         //        for creating phis depends on that.
         AO_Map |= [Source_Addr => Result]

         return Result
      end func Get_OID_From_Block

      //  Call recursive routine to get OID associated with Source_Addr
      return Get_OID_From_Block(Op_Ctx.Addr_To_OID_Map, Op_Ctx.Cur_Node_Id)

   end func Get_OID

   func Store_Value
     (var Op_Ctx;
      Dest_Addr : Addr_VN_Id; New_Val : VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+;
      Make_Copy : Boolean := #false) is
      //  Create a new OID based on Origin, and then
      //  Add [Dest_Addr => New_OID] into Op_Ctx.Addr_To_OID_Map
      //  and [New_OID => New_Val] into Op_Ctx.OID_To_VN_Map.
      //  Deal with assignments to base objects and their components
      //  Get a new OID
      const New_OID := Op_Ctx.OI_Data.Table.Get_Unique_Id (Origin)
      // Set new OID and value for destination
      Store_OID(Op_Ctx, Dest_Addr, New_OID => New_OID,
        Source_Pos => Source_Pos,
        Origin => Origin)
      if Make_Copy then
         ref New_Val_Info => Op_Ctx.VN_Data.Table[New_Val]

         const Val_Copy := Op_Ctx.VN_Data.Table.Get_Unique_Id
           (Copied_VN::(Type_Info => null,  // TBD?
                        Might_Be_Null =>
                          Can_Have_Null_Value(New_Val_Info),
                        Orig_Val => New_Val,
                        New_OID => New_OID))
         Store_OID_Value(Op_Ctx, New_OID, Val_Copy, Source_Pos => Source_Pos)
      else
         Store_OID_Value(Op_Ctx, New_OID, New_Val, Source_Pos => Source_Pos)
      end if
   end func Store_Value

   func Create_Phi_VN (var VN_Data : VN_Data_Record; CFG;
      OI_Data : OI_Data_Record;
      Node : CFG::Node_Id;
      Phi_OID : OID;
      Common_VN : VN_Id;
      Source_Addr : optional Addr_VN_Id := null) -> Result : VN_Id is
     //  Create a Phi_VN in the given Node, for the given Phi_OID.
     //  Initialize its vector of input VNs to the given Common_VN value

      var Type_Info : optional Object_Locator := null
      var Might_Be_Null : Boolean := #true

      case VN_Data.Table[Common_VN] of
         [TVN : Typed_VN+] =>
            Type_Info := TVN.Type_Info
            Might_Be_Null := TVN.Might_Be_Null
         [..] =>
            null
      end case

      Result := VN_Data.Table.Get_Unique_Id
                  (Phi_VN::(Type_Info => Type_Info,
                            Might_Be_Null => Might_Be_Null,
                            Phi_Block => Node,
                            Phi_OID => Phi_OID,
                            Phi_Addr => Source_Addr))

      //  Remember we created a Phi VN in this node
      if Node not in VN_Data.Node_Phi_Id_Maps then
         VN_Data.Node_Phi_Id_Maps[Node] := [Phi_OID => Result]
      else
         VN_Data.Node_Phi_Id_Maps[Node] |= [Phi_OID => Result]
      end if

      //  Initialize the input vector for the Phi VN
      const Num_In_Edges := |CFG[Node].Incoming_Edges|

      VN_Data.Phi_Id_Inputs |=
        [Result => Create(Num_In_Edges, Common_VN)]

      if Debug_Phis then
         Println(" Create_Phi_VN`(Result) in BB`(Node)," |
                   " OID`(Phi_OID):`(OI_Data.Table[Phi_OID])," |
                   " Initial input = VN" | Common_VN |
                   (Source_Addr not null?
                      ", Source_Addr = VN" | Source_Addr : ""))
         if Source_Addr is null then
            //  Check whether OID has an address
            case OI_Data.Table[Phi_OID] of
               [Phi : Phi_Origin] =>     null
               [Input : Input_Origin] => null
               [..] => {*OID_Lacks_Address* #false}
            end case
         end if
      end if
   end func Create_Phi_VN

   func Fetch_OID_Value(var Op_Ctx; Source_OID : OID;
      Source_Pos : Reflection::Source_Position;
      Instr_Index : Code_Index;
      Source_Addr : optional Addr_VN_Id := null) -> VN_Id is
     // Fetch VN at given OID

      func Fetch_OID_Value_From_Block
        (Node : CFG::Node_Id; Pred_OID : OID) -> VN_Id is
         var Result : optional VN_Id := null
        //  Recursive routine to get VN associated with Pred_OID, looking in
        //  predecessors as necessary, creating a Phi if appropriate.

         if Node != Op_Ctx.Cur_Node_Id
           and then Pred_OID in Op_Ctx.VN_Data.Node_To_Id_Map[Node]
         then
            //  Value already looked up, just return it
            Result := Op_Ctx.VN_Data.Node_To_Id_Map[Node][Pred_OID]
         else
            //  Look at each non-back-edge predecessor
            //  Treat remaining input cases as Input_VNs for now

            //  See how many incoming edges we have
            ref In_Edges => Op_Ctx.CFG[Node].Incoming_Edges

            case |In_Edges| of
               [0] =>
                  // Entry block, fall through
                  null

               [1] =>
                  // Recurse
                  ref Only_Edge => Op_Ctx.CFG.Nth_Edge(In_Edges[1])
                  Result := Fetch_OID_Value_From_Block
                              (Only_Edge.From, Pred_OID)

               [..] =>
                  // Multiple incoming edges, see whether all produce same VN
                  var Common_VN : optional VN_Id := null
                  ref DT => Op_Ctx.CFG.Get_Dominator_Tree()

                  if Node in Op_Ctx.VN_Data.Node_Phi_Id_Maps
                    and then Pred_OID in Op_Ctx.VN_Data.Node_Phi_Id_Maps[Node]
                  then
                     //  Phi already created.  Re-use it.
                     Result := Op_Ctx.VN_Data.Node_Phi_Id_Maps[Node][Pred_OID]
                  end if

                  for each [In_Edge_Num => In_Edge_Id] of In_Edges
                    {not DT.Is_Back_Edge(In_Edge_Id)}  //  Ignore back edges
                  loop
                     ref In_Edge => Op_Ctx.CFG.Nth_Edge(In_Edge_Id)

                     //  See whether we have a Phi_OID for this node
                     var Edge_OID := Pred_OID
                              // By default all edges use same OID

                     case Op_Ctx.OI_Data.Table[Pred_OID] of
                        [Phi : Phi_Origin] =>
                           if Phi.Phi_Block == Node then
                              //  This is a Phi_OID for this node;
                              //  each edge has its own OID
                              Edge_OID :=
                                Op_Ctx.OI_Data.Phi_Id_Inputs[Pred_OID]
                                  [In_Edge_Num]
                           end if
                        [..] =>
                           null
                     end case

                     //  Recurse on predecessor
                     const In_VN :=
                        Fetch_OID_Value_From_Block
                           (In_Edge.From, Pred_OID => Edge_OID)

                     if Result not null then
                        //  Have already created a phi, just continue
                        //  to initialize the vector of input VNs
                        Op_Ctx.VN_Data.Phi_Id_Inputs[Result][In_Edge_Num] :=
                          In_VN

                     elsif Common_VN is null then
                        //  First edge, just remember the In_VN
                        Common_VN := In_VN

                     elsif In_VN != Common_VN then
                        //  First edge that doesn't equal Common_VN
                        //  Need to create a phi
                        if Debug_Phis then
                            Println("Creating phi in Fetch_OID_Value, " |
                              "Common_VN = VN" | Common_VN |
                               (Source_Addr is null? "" :
                                ", Source_Addr = VN" | Source_Addr))
                        end if
                        Result :=
                          Op_Ctx.VN_Data.Create_Phi_VN
                            (Op_Ctx.CFG, Op_Ctx.OI_Data, Node,
                             Pred_OID,
                             Common_VN => Common_VN,
                             Source_Addr => Source_Addr)

                        //  Fill in this edge's input VN
                        Op_Ctx.VN_Data.Phi_Id_Inputs[Result][In_Edge_Num] :=
                          In_VN

                     end if
                  end loop

                  if Result is null then
                     //  Got same value from all (non-back-edge) inputs
                     {Common_VN not null} // Common_VN should have been set
                     Result := Common_VN
                     if DT.Is_Loop_Header(Node) then
                        //  Remember the value we got at this loop header
                        //  so when we process the block with an outgoing
                        //  back edge to this block, we can check whether
                        //  the VN there matches the Common_VN
                        if Node not in Op_Ctx.VN_Data.Loop_Header_Id_Map then
                           Op_Ctx.VN_Data.Loop_Header_Id_Map[Node] :=
                             [Pred_OID => Result]
                        else
                           Op_Ctx.VN_Data.Loop_Header_Id_Map[Node] |=
                             [Pred_OID => Result]
                        end if
                        if Debug_Phis then
                           Println(" Recording common VN" | Result |
                                   " for OID" | Pred_OID |
                                   " in loop header BB" | Node)
                        end if
                     end if
                     
                  end if

            end case
         end if

         if Result is null then
            // Straight shot from entry block, and no definitions
            // See whether Pred_OID is an "Input" OID, in which
            // case the content of such an OID is itself an input.
            case Op_Ctx.OI_Data.Table[Pred_OID] of
               [Input : Input_Origin] =>
                  Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
                     (Input_VN::(Type_Info => null, // TBD
                                 Might_Be_Null =>
                                   Input.Input_Addr not in
                                     Op_Ctx.Non_Null_Inputs,
                                 Input_Addr => Input.Input_Addr))

                  if Input.Input_Addr in Op_Ctx.Deref_Non_Null then
                     //  Deref of Input_Addr is address of a non-null object
                     Op_Ctx.Non_Null_Inputs |= Result
                  end if

                  if Debug then
                     Println("Fetching (input) VN`(Result):" |
                       Op_Ctx.VN_Data.Table[Result] |
                       " from OID`(Pred_OID):" |
                       Op_Ctx.OI_Data.Table[Pred_OID] |
                       (Input.Input_Addr in Op_Ctx.Deref_Non_Null?
                         "(Deref_Non_Null)" : ""))
                  end if

               [..] =>
                  //  Not clear where this OID came from.
                  //  Return an Unknown VN
                  Put_Error("Fetch of undefined value at OID`(Pred_OID):" |
                    Op_Ctx.OI_Data.Table[Pred_OID], Source_Pos)
                  Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                 (Unknown_VN::(Type_Info => null,
                                               Might_Be_Null => #true,
                                               Unknown => Op_Ctx.Null_VN))

            end case
         end if

         if Node != Op_Ctx.Cur_Node_Id then
            //  Remember VN in this block
            Op_Ctx.VN_Data.Node_To_Id_Map[Node] |= [Pred_OID => Result]
         end if

         return Result

      end func Fetch_OID_Value_From_Block

      if Op_Ctx.Has_Updated_Value(Source_OID) then
         //  Parts of Source_OID were updated, freeze the overall value
         Op_Ctx.Freeze_Updated_Value(Source_OID, Source_Pos, Instr_Index);
      end if;

      if Source_OID in Op_Ctx.OID_To_VN_Map then
         //  We already looked up the value
         return Op_Ctx.OID_To_VN_Map[Source_OID]  //  TBD: Handle all cases
      end if

      //  Not in OID_To_VN map.  See whether is a constant or a component
      var Result : optional VN_Id := null

      const Source_Addr_Img : Univ_String := Source_Addr is null? "null VN" :
                               ("VN`(Source_Addr):" |
                               Op_Ctx.VN_Data.Table[Source_Addr])

      case Op_Ctx.OI_Data.Table[Source_OID] of
       [Input : Input_Origin] =>
         //  Handle special sorts of Inputs (constants; type-relative)
         const Input_Addr := Input.Input_Addr

         case Op_Ctx.VN_Data.Table[Input_Addr] of
          [Type_Rel : Type_Addr_VN] =>
            //  TBD: Treat all of these as unknown (non-null) inputs for now
            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                 (Input_VN::(Type_Info => null, // TBD
                                             Might_Be_Null => #false,
                                             Input_Addr => Input_Addr))

          [Const : Const_Area_VN] =>
            //  Get contents of given constant area
            const Const_Loc : Object_Locator :=
              Create (Const_Area, Const.Offset);
            const Info :=
              Reflection::Const_Info::Const_Info_At_Locator(Const_Loc);

            func VN_For_Precomputed_Const (Data : Reflection::Element_Info)
              -> VN_Id is
               //  Create a VN to represent the precomputed value of Data
               //  If type is a wrapper, unwrap it because the ParaSail VM
               //  manipulates the underlying type.
               //  TBD: Is that really true?
               const Const_Type := Unwrapped_Type_Desc (Data.Type_Desc);
               const Const_Value := Data.Value;
               var Const_VN : optional VN_Id := null;

               if Is_Small (Const_Type) then
                  //  A small object, treat each kind of
                  //  value appropriately
                  case Type_Kind (Const_Type) of
                     [#univ_integer | #normal] =>
                        if Const_Value is null then
                           //  Leave the null value
                           null;
                        elsif Name (Const_Type) == "PSL::Core::Boolean" then
                           //  Special case -- Boolean type
                           Const_VN := Op_Ctx.VN_Data.Table.Get_Bool_Literal_VN
                                         (Const_Value != 0);
                        else
                           Const_VN := Op_Ctx.VN_Data.Table.Get_Int_Literal_VN
                                           (Const_Value);
                        end if
                     [#univ_enum] =>
                        const Const_Enum :=
                          Reflection::Interpret_As_Univ_Enum (Const_Value);
                        if Const_Enum not null then
                           Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                             (Enum_Literal_VN:: (Value => Const_Enum))
                        end if
                     [#univ_real] =>
                        const Const_Real :=
                          Reflection::Interpret_As_Univ_Real (Const_Value)
                        if Const_Real not null then
                           Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                             (Real_Literal_VN:: (Value => Const_Real))
                        end if
                     [#univ_char] =>
                        const Const_Char :=
                          Reflection::Interpret_As_Univ_Char (Const_Value)
                        if Const_Char not null then
                           Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                             (Char_Literal_VN:: (Value => Const_Char))
                        end if
                     [..] =>
                        //  ** TBD **
                        Put_Error("Fetch of const of type " |
                          Name (Const_Type) |
                          ", kind " | Type_Kind (Const_Type) |
                          " at " | Source_Addr_Img, Source_Pos)
                        Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                           (Unknown_VN::(Type_Info => null,
                                         Might_Be_Null => #true,
                                         Unknown => Source_Addr))
                  end case
               elsif Type_Kind (Const_Type) == #univ_string then
                  const Const_Str :=
                    Reflection::Interpret_As_String (Const_Value)
                  if Const_Str not null then
                     Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                       (String_Literal_VN:: (Value => Const_Str))
                  end if
               elsif Reflection::Const_Is_Large_Null (Const_Value) then
                  //  Leave Const_VN null
                  null
               elsif Type_Kind (Const_Type) == #basic_array then
                  //  A non-null basic array, create an array aggregate
                  const Component_Values :=
                    Large_Const_Component_Values (Data)
                     //  First value is length, remaining values are array
                     //  components.
                  const Array_Len := Component_Values[1]
                  const Indexing_Routine_Index :=
                    Get_Indexing_Routine_Index (Const_Type)
                  const Indexing_Routine_VN_Id :=
                    Op_Ctx.VN_Data.Table.Get_Int_Literal_VN
                      (Indexing_Routine_Index)

                  //  Stored length (+1) should match number of components
                  {Array_Len + 1 == |Component_Values|}

                  const Array_Component_Type :=
                    Parameters(Const_Type)[1].Data.Type_Desc

                  var Components : VN_To_VN_Map_Type := []

                  //  Build up map from selector to component VN
                  //  Ignore first element, which is the length
                  for each [I => Component] of Component_Values {I != 1} loop
                     const Sel_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                       (Indexed_Selector_VN::
                          (Indexing_Routine_Id => Indexing_Routine_VN_Id,
                           Indexing_Operands =>
                             [Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(I - 1)],
                           Is_Indexing_Op => #true,
                           Is_Static_Indexing => #true))

                     //  Recurse to get VN to represent pre-computed component
                     if Debug or Debug_Value_Numbering then
                        Println(" VN_For_Precomputed_Const: " |
                          "about to recurse on array component " | I-1 |
                          " of `(Const_Value) which is " | Component);
                     end if

                     Components[Sel_VN] :=
                       VN_For_Precomputed_Const
                         ((Type_Desc => Array_Component_Type,
                           Addr => 0,
                           Value => Component))
                  end loop

                  //  Number of components in aggregate should match array len
                  {|Components| == Array_Len}

                  Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                    (Aggregate_VN::(Type_Info =>
                                      Create(Base => Zero_Base,
                                             Offset => [[Index(Const_Type)]]),
                                    Might_Be_Null => #false,
                                    Base_Val => null,
                                    Kind_Of_Selectors => #static_index,
                                    Components => Components))
               else
                  //  A non-null large object, create an aggregate value
                  const Component_Values :=
                    Large_Const_Component_Values (Data)
                  const Component_Infos := Components(Const_Type)

                  var Components : VN_To_VN_Map_Type := []

                  //  Build up map from selector to component VN
                  for each [I => Component] of Component_Values loop
                     const Sel_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                       (Named_Selector_VN::(Offset => I))

                     //  Recurse to get VN to represent pre-computed component
                     if Debug or Debug_Value_Numbering then
                        Println(" VN_For_Precomputed_Const: " |
                          "about to recurse on named component " | I |
                          " of `(Const_Value) which is " | Component);
                     end if

                     Components[Sel_VN] :=
                       VN_For_Precomputed_Const
                         ((Type_Desc => Component_Infos[I].Type_Desc,
                           Addr => 0,
                           Value => Component))
                  end loop

                  Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                    (Aggregate_VN::(Type_Info =>
                                      Create(Base => Zero_Base,
                                             Offset => [[Index(Const_Type)]]),
                                    Might_Be_Null => #false,
                                    Base_Val => null,
                                    Kind_Of_Selectors => #named,
                                    Components => Components))

               end if

               if Const_VN is null then
                  //  Create a unique null literal VN
                  Const_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                   (Null_Literal_VN::(Origin => Instr_Index))
               end if

               return Const_VN
            end func VN_For_Precomputed_Const
            
            //  Call recursive routine to build VN for precomputed constant
            Result := VN_For_Precomputed_Const (Info.Data)

            if Debug or Debug_Value_Numbering then
               Println("Fetching (const) VN`(Result):" |
                 Op_Ctx.VN_Data.Table[Result] |
                 " from " | Source_Addr_Img)
            end if

          [..] =>
            null
         end case

       [..] =>
         //  See whether is an OID for a component
         if Source_OID in Op_Ctx.All_Component_OIDs then
            //  Get VN or UV for enclosing object
            const Addr_Id := Op_Ctx.Component_OID_To_Addr_Map[Source_OID]

            if Debug then
               Println("Fetch_OID_Value for component with Addr VN" | Addr_Id)
            end if
            case Op_Ctx.VN_Data.Table[Addr_Id] of
             [Component : Component_Addr_VN] =>
               const Base_OID := Component.Base_Obj
               const Selector := Component.Selector
               const Selector_Kind := Op_Ctx.Component_Selector_Kind(Selector)
               var Base_Val : VN_Id 

               if Op_Ctx.Has_Updated_Value(Base_OID, Selector) then
                  //  OK to look "through" updated values
                  ref Base_UV => Op_Ctx.Get_Updated_Value
                                   (Base_OID, Selector, Source_Pos, Instr_Index)

                  //  This selector should not be in the updated value,
                  //  because the OID is not in the OID_To_VN_Map.
                  //  It might be in the Base_Val.
                  if Debug then
                     if Selector in Base_UV.Component_OIDs then
                        Println("For Source_OID" | Source_OID |
                          " Selector VN" | Selector |
                          " *is* in Base_UV.Component_OIDs: " |
                          (for each [Comp_VN => Comp_OI]
                            of Base_UV.Component_OIDs => <""> |
                              "[VN`(Comp_VN)=>OID`(Comp_OI)]"))
                     end if
                  end if
                  {Selector not in Base_UV.Component_OIDs}

                  Base_Val := Base_UV.Base_Val
                  if Debug then
                     Println("Fetch_OID_Value where Base OID" | Base_OID |
                       " has UV " | Base_UV)
                  end if
               else
                  //  Get value, incorporating any updates
                  Base_Val := Op_Ctx.Fetch_OID_Value
                                (Base_OID, Source_Pos, Instr_Index)
               end if

               case Op_Ctx.VN_Data.Table[Base_Val] of
                  [Aggr : Aggregate_VN] =>
                     //  Fetch value from aggregate if selector kinds match
                     //  and selector is present.
                     if Debug then
                        Println("Fetch_OID_Value with Base VN" | Base_Val |
                          " being " | Aggr)
                     end if

                     if Aggr.Kind_Of_Selectors == Selector_Kind
                       and then Selector in Aggr.Components
                     then
                        Result := Aggr.Components[Selector]
                     end if
                  [..] => null
               end case

               if Result is null then
                  //  Create a component value VN
                  Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                   (Component_Value_VN::
                                     (Type_Info =>
                                        Component.Comp_Type,
                                      Might_Be_Null =>
                                        Component.Comp_Might_Be_Null,
                                      Base_Val => Base_Val,
                                      Selector => Selector))
               end if
               
             [..] =>
               if Debug then
                  Println(" Expected component addr for VN" | Addr_Id |
                    ", found: " | Op_Ctx.VN_Data.Table[Addr_Id])
               end if
               {*addr_should_be_component* #false}  //  Shouldn't happen
            end case
         end if

      end case

      if Result is null then
         //  Call recursive routine, which might create a Phi_VN
         Result := Fetch_OID_Value_From_Block
                     (Op_Ctx.Cur_Node_Id, Pred_OID => Source_OID)
      end if

      //  Record Result in OV Map
      Store_OID_Value (Op_Ctx, Source_OID,
                       New_Val => Result,
                       Source_Pos => Source_Pos)

      return Result

   end func Fetch_OID_Value

   func Fetch_Value(var Op_Ctx; Source_Addr : Addr_VN_Id;
      Source_Pos : Reflection::Source_Position;
      Origin : Origin_Info+;
      Might_Be_Null : Boolean := #true) -> Result : VN_Id is
     // Fetch VN at given address

      Result := Fetch_OID_Value
        (Op_Ctx,
         Get_OID (Op_Ctx, Source_Addr, Source_Pos, Origin, Might_Be_Null),
         Source_Pos, Instr_Index (Origin), Source_Addr)

      // Remember Result associated with address
      Op_Ctx.Remember_Fetched_Value (Source_Addr, Result)
   end func Fetch_Value

   func All_Are_Literals (Op_Ctx; Operands : Vector<VN_Id>) -> Boolean is
     //  Return #true if all of the operands are literals, if any.
     //  Return #false if any operand is not a literal.
     //  NOTE: We might allow other kinds of compile-time-known values
     //        at some point.
      return (for all Op of Operands =>
                               Is_Literal_VN (Op_Ctx.VN_Data.Table, Op))
   end func All_Are_Literals

   func Possible_Uplevel_Ref(var Op_Ctx; Node : CFG::Node_Id) is
     //  Record that there is a possible up-level reference in the given node.
     //  and in all enclosing loop headers
      ref DT => Op_Ctx.CFG.Get_Dominator_Tree()
      for Encl := Node then DT.Enclosing_Loop(Encl)
        while Encl not null
          and then Encl not in Op_Ctx.Loops_With_Uplevel_Refs
        {DT.Is_Loop_Header(Encl)}
      loop
         //  Found another loop header that has an up-level reference
         Op_Ctx.Loops_With_Uplevel_Refs |= Encl
      end loop
   end func Possible_Uplevel_Ref

   func Value_Number_Locator(var Op_Ctx; Locator : Object_Locator;
     I : Code_Index; Which_Output : Output_Index := 1;
     Might_Be_Null : Boolean := #true)
     -> Addr_VN_Id is
      //  Return an addr value number for given object locator
      //  Add a non-null assertion if locator implies a non-null base obj

      var Result : optional Addr_VN_Id := null;
      const Instr := Op_Ctx.Routine.Nth_Instr(I);
      const Source_Pos := Source_Pos (Instr)
      const Origin : Origin_Info+ := Code_Origin::(I, Which_Output)

      case Locator.Base() of
         [Zero_Base] => {#false}

         [Local_Area] =>
            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Local_Addr_VN::
                (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                 BB_Id => Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                 Offset => Locator.Offset()))

         [Enclosing_Local_Areas.First .. Enclosing_Local_Areas.Last] =>
            const Uplevel : Code_Nesting_Level :=
              [[Locator.Base() - Enclosing_Local_Areas.First]]
            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Local_Addr_VN::
                (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel),
                 BB_Id =>
                   Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel),
                 Offset => Locator.Offset()))

         [Param_Area |
          Enclosing_Param_Areas.First .. Enclosing_Param_Areas.Last] =>

            const Uplevel : Code_Nesting_Level :=
              Locator.Base() == Param_Area? 0 :
                [[Locator.Base() - Enclosing_Param_Areas.First]]

            //  If this is referring to the param area for a nested block,
            //  we will substitute in the location of its param area in
            //  the enclosing block.
            const Cur_Entry_Node :=
              Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel)

            if Cur_Entry_Node in Op_Ctx.Nested_Block_Param_Area then
               //  We saved the offset in the enclosing block's local area
               //  of this block's param area.
               //  Create the up-level Local_Addr VN for the address
               Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
                 (Local_Addr_VN::
                   (Level => Level_Of_BB
                               (Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel + 1),
                    BB_Id => Entry_Node_For_BB
                               (Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel + 1),
                    Offset =>
                      Op_Ctx.Nested_Block_Param_Area[Cur_Entry_Node] +
                        Locator.Offset()))
            else
               //  Normal case, just create a Param_Addr_VN
               Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
                 (Param_Addr_VN::
                   (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id, Uplevel),
                    BB_Id => Cur_Entry_Node,
                    Offset => Locator.Offset()))
            end if

         [Base_Registers.First .. Base_Registers.Last] =>
            // Select a component
            const Local_Offset : Reflection::Offset_Within_Area :=
                  [[Locator.Base() - Base_Registers.First]]
            const Local_Loc : Object_Locator :=
              Create(Base => Local_Area, Offset => Local_Offset)
            const Local_Addr :=
               Op_Ctx.VN_Data.Table.Get_Unique_Id(Local_Addr_VN::
                 (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  BB_Id => Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  Offset => Local_Offset))

            //  Remember local locator's address VN
            Op_Ctx.Locator_To_Addr[Local_Loc] := Local_Addr

            const Base_Obj :=
              Get_OID(Op_Ctx, Local_Addr, Source_Pos, Origin)

            const Base_Value :=
              Fetch_OID_Base_Value(Op_Ctx, Base_Obj, Source_Pos, Origin)

            //  Remember that fetch of Local_Addr produced Base_Value
            Op_Ctx.Remember_Fetched_Value (Local_Addr, Base_Value)

            //  Add assertion that base value is not null
            Op_Ctx.Assert_Non_Null(Base_Value, I)

            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id(Component_Addr_VN::
                 (Base_Obj => Base_Obj,
                  Selector => Op_Ctx.VN_Data.Table.Get_Unique_Id
                    (Named_Selector_VN::(Offset => Locator.Offset())),
                  Comp_Type => null,  //  TBD
                  Comp_Might_Be_Null => Might_Be_Null))

            if Debug then
               Println("** Value_Number_Locator => Component: " |
                 Op_Ctx.VN_Data.Table[Result])
            end if

         [Phys_Base_Registers.First .. Phys_Base_Registers.Last] =>
            // Level of indirection
            const Offset : Reflection::Offset_Within_Area :=
              [[Locator.Base() - Phys_Base_Registers.First]]
            const Local_Loc : Object_Locator :=
              Create(Base => Local_Area, Offset => Offset)
            const Local_Addr := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Local_Addr_VN::
                 (Level => Level_Of_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  BB_Id => Entry_Node_For_BB(Op_Ctx, Op_Ctx.Cur_Node_Id),
                  Offset => Offset))

            //  Remember local locator's address VN
            Op_Ctx.Locator_To_Addr[Local_Loc] := Local_Addr

            const Base_Obj :=
              Get_OID(Op_Ctx, Local_Addr, Source_Pos, Origin,
                Might_Be_Null => #false)

            const Base_Value :=
              Fetch_OID_Base_Value(Op_Ctx, Base_Obj, Source_Pos, Origin)
               //  NOTE: This is unlikely to be a composite object
               //        since we currently only use "physical" base registers
               //        for pure indirections.  It is almost certainly just
               //        a "bare" address.  Even if it is a field of a "ref"
               //        object, it is still just a pointer.

            //  Remember that fetch of Local_Addr produced Base_Value
            Op_Ctx.Remember_Fetched_Value (Local_Addr, Base_Value)

            //  NOTE: We are not checking for a null value here, because
            //        the Store_Address_Op never produes a null reference.

            if Locator.Offset() == 0 then
               //  A pure indirection
               Result := Base_Value
            else
               //  Selecting a component -- only used for parameters
               //  that follow a TCB created by a Create_Tcb_Op.
               Result := Op_Ctx.VN_Data.Table.Get_Unique_Id(Component_Addr_VN::
                    (Base_Obj => Base_Obj,
                     Selector => Op_Ctx.VN_Data.Table.Get_Unique_Id
                       (Named_Selector_VN::(Offset => Locator.Offset())),
                     Comp_Type => null,
                     Comp_Might_Be_Null => Might_Be_Null))
            end if

         [Type_Area] =>
            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Type_Addr_VN::
                 (Uplevel => 0,
                  Offset => Locator.Offset()))

         [Enclosing_Type_Areas.First .. Enclosing_Type_Areas.Last] =>
            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Type_Addr_VN::
                 (Uplevel => [[Locator.Base() - Enclosing_Type_Areas.First]],
                  Offset => Locator.Offset()))

         [Const_Area] =>
            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Const_Area_VN::
                 (Offset => Locator.Offset()))

         [..] =>
            Println("Locator `(Locator) NYI")
            //  Fall through to return an unknown addr
      end case

      if Result is null then
         //  Return an unknown address
         Result :=
           Op_Ctx.VN_Data.Table.Get_Unique_Id
             (Unknown_VN::(Type_Info => null,
                           Might_Be_Null => #true,
                           Unknown => Op_Ctx.Null_VN))
      end if
      if Debug_Value_Numbering then
         Println (" Value_Number_Locator(`(Locator)) -> VN`(Result):" |
           Op_Ctx.VN_Data.Table[Result])
      end if

      //  Remember this result temporarily
      Op_Ctx.Locator_To_Addr[Locator] := Result

      return Result
   end func Value_Number_Locator

   func Value_Number_Builtin(var Op_Ctx;
     Routine_Id : VN_Id; Desig : Univ_String;
     Operands : Vector<VN_Id>; Source_Pos : Reflection::Source_Position)
     -> optional VN_Id is
      //  Return value number for result of call on builtin.
      //  Return null if should be treated like normal call.
      case Desig of
       ["#identity" | "#integer_from_univ" | "#integer_to_univ"] =>
         // Identity operations
         return Operands[1]
       ["#ordering_to_bool"] =>
         const Ordering_Mask :=
           Int_Literal_Value(Op_Ctx.VN_Data.Table, Operands[2])
         {Ordering_Mask not null}

         //  See whether value is known
         const Ordering_Val :=
           Int_Literal_Value(Op_Ctx.VN_Data.Table, Operands[1])
         if Ordering_Val is null then
            //  Not known, create a Condition_Mask_VN
            return Op_Ctx.VN_Data.Table.Get_Unique_Id
                               (Condition_Mask_VN::
                                 (Tested_Val => Operands[1],
                                  Mask => From_Rep(Ordering_Mask)))
         end if
         //  Evaluate now, by checking if ordering mask has proper bit on
         const Bool_Val := (Ordering_Mask >> Ordering_Val) mod 2 != 0
         //  Return boolean result
         return Op_Ctx.VN_Data.Table.Get_Bool_Literal_VN(Bool_Val)
       ["#bool_from_univ"] =>
         const Lit_Val := Enum_Literal_Value(Op_Ctx.VN_Data.Table, Operands[1])
         if Lit_Val not null then
            case Lit_Val of
              [#false] =>
               return Op_Ctx.VN_Data.Table.Get_Bool_Literal_VN(#false)
              [#true] =>
               return Op_Ctx.VN_Data.Table.Get_Bool_Literal_VN(#true)
              [..] =>
               Put_Error("Not a Boolean literal: " | Lit_Val, Source_Pos)
               return null
            end case
         end if
       ["#ordering_from_univ"] =>
         const Lit_Val := Enum_Literal_Value(Op_Ctx.VN_Data.Table, Operands[1])
         if Lit_Val not null then
            case Lit_Val of
             [#less] =>
               return Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(0)
             [#equal] =>
               return Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(1)
             [#greater] =>
               return Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(2)
             [#unordered] =>
               return Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(3)
             [..] =>
               Put_Error("Not an Ordering value: " | Lit_Val, Source_Pos)
               return null
            end case
         end if
       ["\"and\""] =>
         return Op_Ctx.VN_Data.Table.Get_Unique_Id
                         (Logical_And_VN::(Left => Operands[1],
                                           Right => Operands[2]))
       ["\"or\""] =>
         return Op_Ctx.VN_Data.Table.Get_Unique_Id
                         (Logical_Or_VN::(Left => Operands[1],
                                           Right => Operands[2]))
       ["\"not\""] =>
         return Op_Ctx.VN_Data.Table.Get_Unique_Id
                         (Logical_Not_VN::(Tested_Val => Operands[1]))
       ["#negate"] =>
         // TBD: do compile-time calculation
         // TBD: check for associativity, where operand is itself an
         //      addition, subtraction, or negation.
         return Op_Ctx.VN_Data.Table.Get_Unique_Id
                         (Negate_VN::(Operand => Operands[1]))
       ["\"=?\""] =>
         //  if neither side is a literal, convert to subtraction
         //  compared against zero
         if not Op_Ctx.VN_Data.Table.Is_Literal_VN(Operands[1])
           and then
            not Op_Ctx.VN_Data.Table.Is_Literal_VN(Operands[2])
         then
            //  Worth converting to a subtraction
            const Zero := Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(0)
            return Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Call_VN::(Type_Info => null,
                         Might_Be_Null => #false,
                         Routine_Id => Routine_Id,
                         Operands =>
                           [Op_Ctx.Value_Number_Builtin
                              (Routine_Id => 0,
                               Desig => "\"-\"",
                               Operands => Operands,
                               Source_Pos => Source_Pos),
                            Zero]))
         else
            //  Default is OK
            return null
         end if
       ["\"-\""] =>
         // TBD: do compile-time calculation
         // TBD: check for associativity, where operand is itself an
         //      addition, subtraction, or negation.
         return Op_Ctx.VN_Data.Table.Get_Unique_Id
                  (Subtraction_VN::(Left => Operands[1],
                                    Right => Operands[2]))
       ["\"+\""] =>
         // TBD: do compile-time calculation; re-order for canonicalization
         // TBD: check for associativity, where operand is itself an
         //      addition, subtraction, or negation.
         return Op_Ctx.VN_Data.Table.Get_Unique_Id
                  (Addition_VN::(Left => Operands[1],
                                 Right => Operands[2]))
       [..] =>
         return null
      end case
      return null   //  TBD
   end func Value_Number_Builtin

   func Value_Number_Call(var Op_Ctx; Target_Index : Reflection::Routine_Index;
     Param_Start : Object_Locator; I : Code_Index) is
      //  Add value numbers to VNT and AO/OV Maps to represent effects of call 
      const Routine : Reflection::Routine :=
        Routine_At_Index (Target_Index)
      const Instr := Op_Ctx.Routine.Nth_Instr(I);
      const Source_Pos := Source_Pos (Instr)

      //  TBD: We need parameter info, which is not yet on calls
      //       through operation descriptors.
      {*op_desc_NYI* Routine not null}

      const Desig := Routine.Built_In_Desig();
      //  TBD: Some subset of the built-ins have "known" effects.

      const Params := Parameters(Routine)

      //  Count number of outputs
      //  TBD: Handle up-level references properly
      const Num_Updated :=
        (for each P of Params
          {P.Is_Operation_Output or else P.Is_Var} => <0> + 1)

      const First_Updated :=
        (for each [I => P] of Params
          {P.Is_Operation_Output or else P.Is_Var} => Min(<null>, I))

      if Debug_Verbose then
         Println(Source_Pos | ": Call of " | Routine.Name() |
           (Desig not null? "(`(Desig)) ": "") |
           " has " |
           Num_Updated | " updated.")
      end if

      //  See whether this returns a "ref" (not a "ref object")
      const Returns_A_Ref := |Params| > 0
        and then Params[1].Is_Operation_Output
        and then Params[1].Is_Declared_Ref
        and then Params[1].Is_Passed_By_Ref

      //  Accumulate "ref" and non-ref operands if returns a "ref"
      var Ref_Operands     : Vector<Addr_VN_Id> := []
      var Non_Ref_Operands : Vector<VN_Id> := []
      var First_Ref_Addr   : optional Addr_VN_Id := null

      //  Create a value number to represent the effects of this
      //  call.
      const Num_Inputs :=
        (for each P of Params {not P.Is_Operation_Output} => <0> + 1)

      //  Get location of parameter area in local area
      const Start : Object_Locator := Param_Start
      {Start.Base() == Local_Area}

      const Param_Area_Offset := Start.Offset() - 1

      //  Create a Call value number using call target and
      //  each input.
      var Routine_Id : VN_Id :=
                         Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(Target_Index)

      //  Build up the list of operands
      var Call_Operands : Vector<VN_Id> := []

      //  Look at inputs
      for each [J => P] of Params {not P.Is_Operation_Output}
        forward loop
         const Param_Locator : Object_Locator :=
           Create(Local_Area, Param_Area_Offset + J);
         const Param_Addr : Addr_VN_Id :=
           Value_Number_Locator (Op_Ctx, Param_Locator, I,
             Which_Output => J)
         //  Now get the value passed (might be an address)
         const Passed_Value : VN_Id :=
           Fetch_Value(Op_Ctx, 
             Source_Addr    => Param_Addr,
             Source_Pos     => Source_Pos,
             Origin         => Code_Origin::(I, Which_Output => J))

         if Debug_Verbose then
            if P.Is_Passed_By_Ref then
               Println(Source_Pos | ": Param `(J) is by-ref, will fetch.")
            end if
         end if

         var Value_To_Check :=
            (not P.Is_Passed_By_Ref? Passed_Value :
               //  Insert an extra level of indirection
               Fetch_Value(Op_Ctx, Passed_Value,
                 Source_Pos  => Source_Pos,
                 Origin      => Code_Origin::(I, Which_Output => J)))

         //  Add to Call_Operands only if needed
         if not Returns_A_Ref or else Num_Updated > 1 then
            Call_Operands |= Value_To_Check
         end if

         if not P.Is_Optional then
            //  Assert non-optional parameter is not null
            Op_Ctx.Assert_Non_Null(Value_To_Check, I)
         end if

         if Returns_A_Ref then
            //  Keep track of ref and non-ref operands
            if P.Is_Declared_Ref then
               //  Include address in Ref_Operands if returns a ref
               if |Ref_Operands| > 0 then
                  Put_Error
                    ("NYI: Multiple \"ref\" inputs",
                     Source_Pos);
                  Non_Ref_Operands |= Passed_Value
               else
                  Ref_Operands |= Passed_Value
                  if First_Ref_Addr is null then
                     //  Remember addr of first ref operand
                     First_Ref_Addr :=
                       P.Is_Passed_By_Ref? Passed_Value: Param_Addr
                  end if
               end if
            else
               Non_Ref_Operands |= Passed_Value
            end if
         end if
      end loop

      if Num_Updated == 0 and then Nesting_Level (Routine) == 0 then
         return  //  Nothing more to do (TBD: check precond)
         //  NOTE: We need to do this after fetching parameters so 
         //        info used by VN_IL is initialized.
      end if

      if Nesting_Level(Routine) > Nesting_Level(Op_Ctx.Routine) then
         //  Remember that we might have an up-level reference here.
         //  TBD: Make this more precise.
         const Cur_Node := Op_Ctx.Cur_Node_Id;

         Possible_Uplevel_Ref(Op_Ctx, Cur_Node)
      end if

      //  Get value number for call if needed
      var Call_Val : optional VN_Id := null

      //  Check for built-in
      //  TBD: What about a builtin that returns a ref?  E.g. basic_array_index
      if Desig not null then
         Call_Val :=
           Op_Ctx.Value_Number_Builtin
             (Routine_Id, Desig, Call_Operands, Source_Pos)
      end if

      if Call_Val is null
        and then (not Returns_A_Ref or else Num_Updated > 1)
      then
         const Call_Info :=
           Call_VN::(Type_Info => (Num_Updated == 1?
                                      Params[First_Updated].Type_Info : null),
                      Might_Be_Null => Num_Updated == 1
                        and then Params[First_Updated].Is_Optional,
                      Routine_Id => Routine_Id,
                      Operands => Call_Operands)

         Call_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id(Call_Info)

         if Output_Inited_Null(Instr) then
            //  Value might be a composite object, since null passed in to
            //  indicate target region.
            //  Wrap the call in a "copy" to prevent sharing 
            Call_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Copied_VN::(Type_Info => Call_Info.Type_Info,
                           Might_Be_Null => Call_Info.Might_Be_Null,
                           Orig_Val => Call_Val,
                           New_OID => Op_Ctx.OI_Data.Table.Get_Unique_Id
                              (Code_Origin::(I, Which_Output => 1))))
         end if
      end if

      var Indexed_Selector : optional VN_Id := null
      var Indexed_Addr_Val : optional Addr_VN_Id := null

      if Returns_A_Ref then
         //  Should be at least one "ref" operand if called
         //  routine returns a "ref"
         {|Ref_Operands| > 0}
         Indexed_Selector := Op_Ctx.VN_Data.Table.Get_Unique_Id
            (Indexed_Selector_VN::
              (Indexing_Routine_Id => Routine_Id,
               Indexing_Operands => Non_Ref_Operands,
               Is_Indexing_Op => Routine.Name() == "\"indexing\"",
                 //  TBD: Not necessarily reliable indicator of "Is_Indexing"
               Is_Static_Indexing =>
                 All_Are_Literals (Op_Ctx, Non_Ref_Operands)))

      end if

      //  Now use this new value number for the result(s) of the call
      for each [J => P] of Params
        {P.Is_Operation_Output or else P.Is_Var} reverse loop
         //  Update the var params and then output(s), doing the output(s) last
         //  so a ref output can be a function of an updated ref input.

         const Param_Locator : Object_Locator :=
           Create(Local_Area, Param_Area_Offset + J);
         var Param_Addr : Addr_VN_Id :=
           Value_Number_Locator (Op_Ctx, Param_Locator, I, Which_Output => J)
         const Output_OID := Op_Ctx.OI_Data.Table.Get_Unique_Id
                              (Code_Origin::(I, Which_Output => J))

         if not P.Is_Operation_Output and then P.Is_Passed_By_Ref then
            //  Get address of var that is updated
            {P.Is_Var}  //  This should be marked as a variable
            Param_Addr := Fetch_Value(Op_Ctx, 
              Source_Addr    => Param_Addr,
              Source_Pos     => Source_Pos,
              Origin         => Code_Origin::(I, Which_Output => J))
         end if

         if P.Is_Operation_Output and then Output_Inited_Null(Instr) then
            //  If output is inited to null, fetch it so compiler will have
            //  the associated value number.
            const Ignore := Fetch_Base_Value(Op_Ctx, 
              Source_Addr    => Param_Addr,
              Source_Pos     => Source_Pos,
              Origin         => Code_Origin::(I, Which_Output => J))
         end if

         //  Store OID in output Param_Addr
         Store_OID(Op_Ctx, Param_Addr,
           New_OID => Output_OID,
           Source_Pos => Source_Pos,
           Origin => Code_Origin::(I, Which_Output => J))

         if P.Is_Operation_Output and then First_Ref_Addr not null then
            //  Get OID associated with first "ref" operand
            const First_Ref_Opnd_OID := Get_OID
              (Op_Ctx, First_Ref_Addr,
               Source_Pos, Code_Origin::(I, Which_Output => 0))

            //  Get address-VN for indexed component
            Indexed_Addr_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
              (Component_Addr_VN::
                (Base_Obj => First_Ref_Opnd_OID,
                 Selector => Indexed_Selector,
                 Comp_Type => null,
                 Comp_Might_Be_Null => Params[1].Is_Optional))
         end if

         if Num_Updated == 1 then
            //  Set new value of the single output
            if P.Is_Operation_Output and then P.Is_Passed_By_Ref then
               //  This is a "ref" output
               {Returns_A_Ref}
               //  TBD: The address should be a function of the
               //       addresses of the "ref" parameters and
               //       the value of (some or all) of the parameters.
               //       The value of the "ref" parameters is normally
               //       irrelevant.
               
               Store_OID_Value(Op_Ctx, Output_OID,
                 New_Val => Indexed_Addr_Val,
                 Source_Pos => Source_Pos)
            else
               //  This is a "normal" output, set OID and value number
               if Call_Val is null then
                  Println("*** Call_Val is null in Value_Number_Call, " |
                    "Instr#" | I |
                    ", Num_Updated = " | Num_Updated |
                    ", Returns_A_Ref = " | Returns_A_Ref |
                    ", Indexed_Addr_Val = " | Indexed_Addr_Val)
               else
                  Store_OID_Value(Op_Ctx, Output_OID,
                    New_Val => Call_Val,
                    Source_Pos => Source_Pos)
               end if
            end if
         else
            //  This is just one of multiple updatable parameters.
            if P.Is_Operation_Output and then P.Is_Passed_By_Ref then
               //  The "ref" output is treated the same even if
               //  there are other non-ref updatable parameters.
               {Returns_A_Ref}
               //  Should be only one "ref" output
               {(for all K in J+1 .. |Params| =>
                   not Params[K].Is_Operation_Output
                   or else not Params[K].Is_Passed_By_Ref)}
               Store_OID_Value(Op_Ctx, Output_OID,
                 New_Val => Indexed_Addr_Val,
                 Source_Pos => Source_Pos)
            else
               //  Create a component value and assign to param.
               {Call_Val not null}
               const Component_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
                 (Component_Value_VN::
                    (Type_Info => Params[J].Type_Info,
                     Might_Be_Null => Params[J].Is_Optional,
                     Base_Val => Call_Val,
                     Selector => Op_Ctx.VN_Data.Table.Get_Unique_Id
                       (Named_Selector_VN::(Offset => J-1))))
               Store_OID_Value(Op_Ctx, Output_OID,
                 New_Val => Component_Val,
                 Source_Pos => Source_Pos)
            end if
         end if
      end loop
   end func Value_Number_Call

   func Logical_Not(var Op_Ctx; Val_To_Complement : VN_Id) -> Result : VN_Id is
     //  Return logical complement of Val_To_Complement
     //  If Val_To_Complement is itself a Logical_Not, just return the
     //  underlying value.  Otherwise, add a Logical_Not_VN on top.
      case Op_Ctx.VN_Data.Table[Val_To_Complement] of
         [Log_Not : Logical_Not_VN] =>
            //  Two "not"s make a truth.
            Result := Log_Not.Tested_Val
         [..] =>
            Result := Op_Ctx.VN_Data.Table.Get_Unique_Id 
                     (Logical_Not_VN::(Tested_Val => Val_To_Complement))
      end case
      Op_Ctx.Boolean_VNs |= Result
   end func Logical_Not

   func Apply_Condition_Mask(var Op_Ctx;
     Tested_Val : VN_Id;
     Mask : Reflection::Instruction::Condition_Bit_Mask) -> Result : VN_Id is
      //  Apply mask to tested value to turn it into a boolean expression
      //  with value 0 or 1
      case Mask.To_Rep() of
       [1] =>
         //  This is logical complement
         Result := Logical_Not(Op_Ctx, Tested_Val)
       [2] =>
         //  This is the identity (aka X != 0)
         Result := Tested_Val
         if Tested_Val not in Op_Ctx.Boolean_VNs then
            //  See whether need to adjust result
            case Op_Ctx.VN_Data.Table[Tested_Val] of
               [Bool : Bool_Literal_VN] =>
                  null  //  OK as is
               [Not : Logical_Not_VN] =>
                  null  //  OK as is
               [And : Logical_And_VN] =>
                  null  //  OK as is
               [Or : Logical_Or_VN] =>
                  null  //  OK as is
               [Cond : Condition_Mask_VN] =>
                  null  //  OK as is
               [Int : Int_Literal_VN] =>
                  //  Convert to corresponding bool literal
                  Result :=
                    Op_Ctx.VN_Data.Table.Get_Bool_Literal_VN(Int.Value != 0)
               [..] =>
                  //  Not sure whether this is a good boolean value
                  if Debug then
                     Put_Warning("Non-boolean being added to Boolean_VNs: VN" |
                       Tested_Val | ":" | Op_Ctx.VN_Data.Table[Tested_Val])
                  end if
                  //  Use special operator for applying the mask
                  Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
                    (Condition_Mask_VN::(Tested_Val => Tested_Val,
                                         Mask => Mask))
            end case
         end if
       [..] =>
         //  Use special operator for applying the mask
         Result := Op_Ctx.VN_Data.Table.Get_Unique_Id
           (Condition_Mask_VN::(Tested_Val => Tested_Val,
                                Mask => Mask))
      end case
      if Debug_Verbose then
         Println("Apply_Condition_Mask: VN`(Tested_Val), Mask = `(Mask)" |
           " (`(Mask.To_Rep())) => VN`(Result):" |
           Op_Ctx.VN_Data.Table[Result])
      end if
      Op_Ctx.Boolean_VNs |= Result
   end func Apply_Condition_Mask

   func Value_Number_Start_Of_Block(var Op_Ctx) is
      //  Incorporate incoming-edge info into Addr_To_OID and OID_To_VN maps
      ref Cur_Node => Op_Ctx.CFG[Op_Ctx.Cur_Node_Id]
      const Num_Incoming := |Cur_Node.Incoming_Edges|
      case Num_Incoming of
         [0] =>
            //  This must be the start node of the whole operation
            //  The Input_VNs should have already been created.
            //  NOTE: We now have edges going to nested blocks from
            //        Start/Add_Parallel_Op's
            {Op_Ctx.Cur_Node_Id in Op_Ctx.CFG_Entry_Nodes}
         [1] =>
            //  Just use prior AO, OV, and OUV Maps
            const Only_In_Edge_Id :=
              Cur_Node.Incoming_Edges[1]
            const Only_Pred_Id :=
              Op_Ctx.CFG.Nth_Edge (Only_In_Edge_Id).From

            {Only_Pred_Id in Op_Ctx.OI_Data.Node_To_Id_Map}
               // Should have encountered single predecessor already.

            Op_Ctx.Addr_To_OID_Map :=
              Op_Ctx.OI_Data.Node_To_Id_Map[Only_Pred_Id]
            Op_Ctx.OID_To_VN_Map :=
              Op_Ctx.VN_Data.Node_To_Id_Map[Only_Pred_Id]
            if Only_Pred_Id in Op_Ctx.Node_To_OUV_Map then
               Op_Ctx.OID_To_UV_Map :=
                 Op_Ctx.Node_To_OUV_Map[Only_Pred_Id]
            else
               Op_Ctx.OID_To_UV_Map := []
            end if

         [..] =>
            //  With multiple incoming edges, we initialize
            //  OID_To_UV_Map to empty (UV's should have been frozen
            //  at end of predecessor block)
            ref DT => Op_Ctx.CFG.Get_Dominator_Tree()

            Op_Ctx.OID_To_UV_Map := []

            //  See which Addr-VNs have same OIDs and OIDs have same VNs
            //  in each predecessor.
            //  These preserve their OID/value into the new basic block.
            //  Others are removed, and may become phi's when ref'ed.
            for (each In_Edge_Id of Cur_Node.Incoming_Edges;
                 Count in 1 .. Num_Incoming forward)
            loop
               const Pred_Id := Op_Ctx.CFG.Nth_Edge(In_Edge_Id).From
               if Pred_Id not in Op_Ctx.OI_Data.Node_To_Id_Map then
                  // Haven't encountered this node yet.  Initialize
                  // it's entry in the Node_To_AV_Map.
                  {Pred_Id not in Op_Ctx.VN_Data.Node_To_Id_Map}
                  Op_Ctx.OI_Data.Node_To_Id_Map |= [Pred_Id => []]
                  Op_Ctx.VN_Data.Node_To_Id_Map |= [Pred_Id => []]
               end if
               ref Pred_AO_Map => Op_Ctx.OI_Data.Node_To_Id_Map[Pred_Id]
               ref Pred_OV_Map => Op_Ctx.VN_Data.Node_To_Id_Map[Pred_Id]
               if Count == 1 then
                  //  This is the first one; just copy maps
                  Op_Ctx.Addr_To_OID_Map := Pred_AO_Map
                  Op_Ctx.OID_To_VN_Map   := Pred_OV_Map
               else
                  //  This is not the first predecessor, incorporate matching
                  //  bindings only.
                  var Addrs_To_Remove : VN_Set := []

                  for each [Addr => Old_OID] of Op_Ctx.Addr_To_OID_Map loop
                     if Addr not in Pred_AO_Map
                       or else Pred_AO_Map[Addr] != Old_OID
                     then
                        //  OID different or missing,
                        //  remove addr/OID from AO/OV maps
                        Addrs_To_Remove |= Addr
                        Op_Ctx.OID_To_VN_Map -= Old_OID
                     end if
                  end loop

                  //  Remove the Addrs identified as having different OIDs
                  for Addr in Addrs_To_Remove loop
                     Op_Ctx.Addr_To_OID_Map -= Addr
                  end loop

                  var OIDs_To_Remove : Ordered_Set<OID> := []

                  for each [Old_OID => Old_VN] of Op_Ctx.OID_To_VN_Map loop
                     if Old_OID not in Pred_OV_Map
                       or else
                         Pred_OV_Map[Old_OID] != Old_VN
                     then
                        //  Values differ, remove OID from OV maps
                        OIDs_To_Remove |= Old_OID
                     end if
                  end loop

                  //  Remove OIDs identified as having different VNs
                  for Old_OID in OIDs_To_Remove loop
                     Op_Ctx.OID_To_VN_Map -= Old_OID
                  end loop
               end if
            end loop

            //  Now we over-write the Addr_To_OID and OID_To_Value maps
            //  with the set of Phi OIDs and VNs for the join point.

            if Op_Ctx.Cur_Node_Id in Op_Ctx.OI_Data.Node_Phi_Id_Maps then
               //  Scan the Phi OIDs for this node
               ref Phi_OIDs =>
                     Op_Ctx.OI_Data.Node_Phi_Id_Maps[Op_Ctx.Cur_Node_Id]

               for each Phi_OID of Phi_OIDs loop
                  case Op_Ctx.OI_Data.Table[Phi_OID] of
                     [Phi : Phi_Origin] =>
                        {Phi.Phi_Block == Op_Ctx.Cur_Node_Id}
                                            // Should be for this node

                        //  Init element of Addr_To_OID map
                        Op_Ctx.Addr_To_OID_Map[Phi.Phi_Addr] := Phi_OID

                     [..] =>
                        //  Should only contain Phi OIDs
                        {#false}
                  end case
               end loop
            end if

            if Op_Ctx.Cur_Node_Id in Op_Ctx.VN_Data.Node_Phi_Id_Maps then
               //  Scan the Phi VNs for this node
               ref Phi_VNs =>
                     Op_Ctx.VN_Data.Node_Phi_Id_Maps[Op_Ctx.Cur_Node_Id]

               for each Phi_VN_Id of Phi_VNs loop
                  case Op_Ctx.VN_Data.Table[Phi_VN_Id] of
                     [Phi : Phi_VN] =>
                        {Phi.Phi_Block == Op_Ctx.Cur_Node_Id}
                                            // Should be for this node

                        //  Init element of OID_To_VN map
                        Op_Ctx.OID_To_VN_Map[Phi.Phi_OID] := Phi_VN_Id
                     [..] =>
                        //  Should only contain Phi VNs
                        {#false}
                  end case
               end loop
            end if

      end case
      {Op_Ctx.Cur_Node_Id not null}
      {Op_Ctx.Addr_To_OID_Map not null}
      {Op_Ctx.OID_To_VN_Map not null}
      {Op_Ctx.OID_To_UV_Map not null}

      if Debug or Debug_Phis then
         if Num_Incoming != 1 then
            Println("At start of BB`(Op_Ctx.Cur_Node_Id) of " |
              Op_Ctx.Routine.Name())
            Dump_Addr_OID_Value_Maps(Op_Ctx)
         end if
      end if
   end func Value_Number_Start_Of_Block

   func Value_Number_End_Of_Block (var Op_Ctx) is
      //  End of current basic block

      {Op_Ctx.Addr_To_OID_Map not null}
      {Op_Ctx.OID_To_VN_Map not null}
      {Op_Ctx.OID_To_UV_Map not null}

      //  Dump the address-to-OID and OID-to-value maps
      if Debug or Debug_Phis then
         Println("After BB`(Op_Ctx.Cur_Node_Id) of " |
           Op_Ctx.Routine.Name())
         Dump_Addr_OID_Value_Maps(Op_Ctx)
      end if

      //  See if any successor has multiple incoming edges.
      //  If so, freeze all updated values
      ref Outgoing_Edges => Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Outgoing_Edges
      const Has_Multi_Input_Successor :=
        (for some Succ of Outgoing_Edges =>
           |Op_Ctx.CFG[Op_Ctx.CFG.Nth_Edge(Succ).To].Incoming_Edges| > 1)

      if Has_Multi_Input_Successor then
         //  Freeze the updated values
         const Index := Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last
         const Instr := Op_Ctx.Routine.Nth_Instr(Index)
         const Source_Pos := Source_Pos(Instr)

         //  Get set of OIDs to freeze before actually freezing any of them
         //  NOTE: We do this in two steps, because freezing one OID can
         //       have a ripple effect and freeze others, causing the
         //       iterator to fail trying to produce a mapping to "UV".
         //  TBD: Eventually we should detect this problem statically, though
         //       it is not easy to do that without a lot of false positives...
         //       We could skip items that are no longer in the map, but
         //       that adds overhead.  We could do a more "careful" iteration
         //       only if the map is potentially updated in the loop body;
         //       perhaps we need an "indexing" that returns null if the element
         //       is not present.  This would allow the caller to decide
         //       how to handle the error, rather than always raising an
         //       exception.  We need a way to test if a reference is null
         //       before dereferencing it.
         const OIDs_To_Freeze : Set<OID> :=
           [for each [O => UV] of Op_Ctx.OID_To_UV_Map => O]

         //  Freeze all of the OIDs that had Updated Values
         for O in OIDs_To_Freeze loop
            Op_Ctx.Freeze_Updated_Value (O, Source_Pos, Index)
         end loop

         Op_Ctx.OID_To_UV_Map := []

         //  Check to see if any outgoing edges are back edges.
         //  If so, check whether additional phis need to be created
         //  in the successor (which is necessarily a loop header).
         //  Also fill in the loop header phi inputs.
         ref DT => Op_Ctx.CFG.Get_Dominator_Tree()

         for each Out_Edge of Outgoing_Edges loop
            const Succ := Op_Ctx.CFG.Nth_Edge(Out_Edge).To

            if Succ in Op_Ctx.OI_Data.Node_Phi_Id_Maps then
               //  Success already has some Phi OIDs;
               //  fill in the appropriate slots in their input vectors.
               ref Succ_Phis => Op_Ctx.OI_Data.Node_Phi_Id_Maps[Succ]

               //  Fill in the input OID
               for each [In_Edge_Num => Incoming_Edge] of
                 Op_Ctx.CFG[Succ].Incoming_Edges {Incoming_Edge == Out_Edge}
               loop
                  for (each Succ_Phi of Succ_Phis;
                       I := Output_Index::Last() then I-1) loop
                     case Op_Ctx.OI_Data.Table[Succ_Phi] of
                        [Phi : Phi_Origin] =>
                           //  Fill in Phi's input vector slot
                           Op_Ctx.OI_Data.Phi_Id_Inputs
                             [Succ_Phi][In_Edge_Num] :=
                               Op_Ctx.Get_OID(Phi.Phi_Addr, Source_Pos,
                                 Code_Origin::(Index,
                                               Which_Output => I))
                        [..] =>
                           {#false}
                     end case

                  end loop
               end loop

            end if

            //  Now do the same thing for the loop-header VNs

            if Succ in Op_Ctx.VN_Data.Node_Phi_Id_Maps then
               //  Loop header already has some Phi VNs;
               //  fill in/update the appropriate slots in their input vectors.
               ref Succ_Phis => Op_Ctx.VN_Data.Node_Phi_Id_Maps[Succ]

               //  Fill in the input VN
               for each [In_Edge_Num => Incoming_Edge] of
                 Op_Ctx.CFG[Succ].Incoming_Edges {Incoming_Edge == Out_Edge}
               loop
                  for (each Succ_Phi of Succ_Phis; I := 20 then I+1) loop
                     case Op_Ctx.VN_Data.Table[Succ_Phi] of
                      [Phi_Val : Phi_VN] =>
                        //  Fill in Phi's input vector slot
                        var In_Edge_OID := Phi_Val.Phi_OID

                        //  If OID is of Phi_Origin, then get OID
                        //  for this edge.
                        case Op_Ctx.OI_Data.Table[Phi_Val.Phi_OID] of
                         [Phi : Phi_Origin] =>
                           In_Edge_OID := Op_Ctx.OI_Data.Phi_Id_Inputs
                                           [Phi_Val.Phi_OID][In_Edge_Num]
                         [..] =>
                           null  //  In_Edge_OID is OK as is
                        end case

                        const Input_Val :=
                          Op_Ctx.Fetch_OID_Value
                            (In_Edge_OID, Source_Pos, Index)
                        ref Prior_Input =>
                          Op_Ctx.VN_Data.Phi_Id_Inputs[Succ_Phi][In_Edge_Num]
                        if Input_Val != Prior_Input then
                           //  We have a new value for the phi input
                           if Debug_Phis then
                              Println("Filling input " | In_Edge_Num |
                                " of phi VN" |
                                Succ_Phi | ", was VN`(Prior_Input)," |
                                " now VN`(Input_Val), Cur_Node_Id = BB" |
                                Op_Ctx.Cur_Node_Id | ", Successor = BB" | Succ)
                           end if

                           Prior_Input := Input_Val

                        end if
                      [..] =>
                        {#false}
                     end case

                  end loop
               end loop

            end if

            if DT.Is_Back_Edge(Out_Edge) then
               //  This edge is a back edge
               const LH   := Succ
               const Back := Out_Edge
               var Old_To_New_OID_Map : Map<OID, OID> := []
                 //  Mapping from old OID to new "phi" OID as a result
                 //  of walking the Loop_Header_Id_Map

               {DT.Is_Loop_Header(LH)}  //  Target should be a loop header

               if LH in Op_Ctx.OI_Data.Loop_Header_Id_Map then
                  //  Check that each addr in AO_Map produces same OID as
                  //  it did on the forward edges into LH.
                  var Phi_Addrs_To_Remove : Set<Addr_VN_Id> := []

                  if Debug_Phis then
                     Println(" Checking OID Loop_Header_Id_Map for BB" | LH)
                  end if

                  for (each [Fetched_Addr => Forward_OID] of 
                         Op_Ctx.OI_Data.Loop_Header_Id_Map[LH];
                       I := 10 then I+1)
                  loop
                     const Back_OID :=
                       Op_Ctx.Get_OID(Fetched_Addr, Source_Pos,
                         Code_Origin::(Index, Which_Output => I))
                     if Debug_Phis then
                        Println
                          ("   [Addr-VN`(Fetched_Addr) => OID`(Forward_OID)],"|
                           " Back_OID" | Back_OID)
                     end if
                     if Back_OID != Forward_OID then
                        //  We need to create a new phi
                        //  because the back-edge OID
                        //  doesn't match the forward-edge OID
                        const Orig_Num_OIDs := |Op_Ctx.OI_Data.Table|

                        const New_Phi :=
                          Op_Ctx.OI_Data.Create_Phi_OID
                            (Op_Ctx.CFG, LH, Fetched_Addr, Forward_OID)

                        if |Op_Ctx.OI_Data.Table| > Orig_Num_OIDs then
                           //  We should re-run value numbering because
                           //  we created a phi "after the fact."
                           Op_Ctx.Rerun_Value_Numbering := #true

                           if Debug or Debug_Phis then
                              Println
                                ("Will rerun value numbering because Phi_OID" |
                                 New_Phi | " was created")
                           end if
                        end if

                        //  Fill in the back edge input OID
                        for each [Back_Edge_Num => Incoming_Edge] of
                          Op_Ctx.CFG[LH].Incoming_Edges {Incoming_Edge == Back}
                        loop
                           Op_Ctx.OI_Data.Phi_Id_Inputs
                             [New_Phi][Back_Edge_Num] := Back_OID
                        end loop

                        //  Keep track of addrs to remove from
                        //  Loop_Header_Id_Map
                        Phi_Addrs_To_Remove |= Fetched_Addr

                        //  Remember mapping from Forward_OID to New_Phi
                        Old_To_New_OID_Map[Forward_OID] := New_Phi
                     end if
                  end loop

                  //  Remove the phi addrs from loop header ID map
                  for Phi_Addr in Phi_Addrs_To_Remove loop
                     Op_Ctx.OI_Data.Loop_Header_Id_Map[LH] -= Phi_Addr
                  end loop
               end if

               //  Now do the same thing for the loop-header VNs

               if LH in Op_Ctx.VN_Data.Loop_Header_Id_Map then
                  //  Check that each OID in OV_Map produces same VN as
                  //  it did on the forward edges into LH.
                  var Phi_OIDs_To_Remove : Set<OID> := []

                  if Debug_Phis then
                     Println(" Checking VN Loop_Header_Id_Map for BB" | LH)
                  end if

                  for each [Fetched_OID => Forward_VN] of
                     Op_Ctx.VN_Data.Loop_Header_Id_Map[LH]
                  loop
                     var Source_Addr_To_Use : optional Addr_VN_Id := null

                     var OID_For_Phi_VN := Fetched_OID
                     if Fetched_OID in Old_To_New_OID_Map then
                        //  We have just created a Phi_OID; use that instead
                        OID_For_Phi_VN := Old_To_New_OID_Map[Fetched_OID]
                     end if

                     var OID_For_Back_VN := OID_For_Phi_VN

                     case Op_Ctx.OI_Data.Table[OID_For_Phi_VN] of
                        [Phi : Phi_Origin] =>
                           Source_Addr_To_Use := Phi.Phi_Addr

                           if Phi.Phi_Block == LH then
                              //  This is a phi for the same loop header.
                              //  Get input to Phi OID.
                              for each [Back_Edge_Num => Incoming_Edge] of
                                                  Op_Ctx.CFG[LH].Incoming_Edges
                                {Incoming_Edge == Back}
                              loop
                                 OID_For_Back_VN :=
                                   Op_Ctx.OI_Data.Phi_Id_Inputs[OID_For_Phi_VN]
                                     [Back_Edge_Num]
                              end loop

                           end if

                        [Input : Input_Origin] =>
                           Source_Addr_To_Use := Input.Input_Addr

                        [..] =>
                           //  Try to find the Source_Addr by looking through
                           //  Addr => OID map in this block and all dominators
                          *Dom_Check*
                           for (BB_To_Check := Op_Ctx.Cur_Node_Id;
                                AO_Map => Op_Ctx.Addr_To_OID_Map) loop
                              for each [Addr => OID_With_Addr] of
                                AO_Map forward loop
                                 if OID_With_Addr == OID_For_Phi_VN then
                                    //  Found the OID of interest
                                    Source_Addr_To_Use := Addr
                                    exit loop Dom_Check
                                 end if
                              end loop
                              const Dom := DT.Immediate_Dominator(BB_To_Check)
                              if Dom != BB_To_Check then
                                 //  Look in dominator
                                 continue loop Dom_Check with
                                   (BB_To_Check => Dom,
                                    AO_Map =>
                                      Op_Ctx.OI_Data.Node_To_Id_Map[Dom])
                              end if
                           end loop Dom_Check
                     end case

                     const Back_VN :=
                       Op_Ctx.Fetch_OID_Value(OID_For_Back_VN, Source_Pos,
                         Index, Source_Addr => Source_Addr_To_Use)

                     if Back_VN != Forward_VN then
                        //  We need to create a new phi because the
                        //  back-edge VN doesn't match the forward-edge VN
                        if Debug_Phis then
                           Println
                             ("   [OID`(OID_For_Phi_VN) => VN`(Forward_VN)]," |
                              " Back_VN" | Back_VN)
                        end if

                        const Orig_Num_VNs := |Op_Ctx.VN_Data.Table|

                        if Debug_Phis then
                            Println("Creating phi at end of block, " |
                              "Common_VN = VN" | Forward_VN |
                               (Source_Addr_To_Use is null? "" :
                                ", Source_Addr = VN" | Source_Addr_To_Use))
                        end if

                        const New_Phi :=
                          Op_Ctx.VN_Data.Create_Phi_VN
                            (Op_Ctx.CFG, Op_Ctx.OI_Data, LH, OID_For_Phi_VN,
                             Common_VN => Forward_VN,
                             Source_Addr => Source_Addr_To_Use)

                        if |Op_Ctx.VN_Data.Table| > Orig_Num_VNs then
                           //  We should re-run value numbering because
                           //  we created a phi "after the fact."
                           Op_Ctx.Rerun_Value_Numbering := #true

                           if Debug or Debug_Phis then
                              Println
                                ("Will rerun value numbering because Phi_VN" |
                                 New_Phi | " was created")
                           end if
                        end if

                        //  Fill in the back edge input VN
                        for each [Back_Edge_Num => Incoming_Edge] of
                          Op_Ctx.CFG[LH].Incoming_Edges {Incoming_Edge == Back}
                        loop
                           Op_Ctx.VN_Data.Phi_Id_Inputs
                             [New_Phi][Back_Edge_Num] := Back_VN
                        end loop

                        //  Keep track of OIDs to remove from
                        //  Loop_Header_Id_Map
                        Phi_OIDs_To_Remove |= Fetched_OID
                     end if
                  end loop

                  //  Remove the phi OIDs from loop header ID map
                  for Phi_OID in Phi_OIDs_To_Remove loop
                     Op_Ctx.VN_Data.Loop_Header_Id_Map[LH] -= Phi_OID
                  end loop
               end if

            end if  //  Outgoing edge is a back edge
         end loop  //  Over outgoing edges
      end if  //  Has_Multi_Input_Successor

      if |Op_Ctx.OID_To_UV_Map| > 0 then
         //  Remember the updated values in mapping
         Op_Ctx.Node_To_OUV_Map[Op_Ctx.Cur_Node_Id] <==
           Op_Ctx.OID_To_UV_Map
         //  Reinitialize the OUV map
         Op_Ctx.OID_To_UV_Map := []
      else
         //  Remove updated values from mapping if present
         Op_Ctx.Node_To_OUV_Map -= Op_Ctx.Cur_Node_Id
      end if

      //  Move current Addr-to-OID and OID-to-VN maps into overall mapping
      //  NOTE: Must freeze UVs first, since that updates OID-to-VN maps.
      //  TBD: Clean out unused OIDs first?
      Op_Ctx.OI_Data.Node_To_Id_Map[Op_Ctx.Cur_Node_Id] <==
        Op_Ctx.Addr_To_OID_Map
      Op_Ctx.VN_Data.Node_To_Id_Map[Op_Ctx.Cur_Node_Id] <==
        Op_Ctx.OID_To_VN_Map

      // and reinitialize the maps.
      Op_Ctx.Addr_To_OID_Map := []
      Op_Ctx.OID_To_VN_Map := []

      {Op_Ctx.Addr_To_OID_Map not null}
      {Op_Ctx.OID_To_VN_Map not null}
      {Op_Ctx.OID_To_UV_Map not null}

   end func Value_Number_End_Of_Block

   func Analyze_One_Instr(var Op_Ctx;
     Operation_Routine : Reflection::Routine; I : Code_Index) is
      //  Analyze one instruction.
      //  Op_Ctx.Pass determines what action to take.

      const Instr := Operation_Routine.Nth_Instr(I);
      const Source_Pos := Source_Pos(Instr)
      const Uses_Rgn := Operation_Routine.Uses_Stg_Rgn();
      var IO := IO::Get_IO()

      if Op_Ctx.Pass == #value_number then
         //  Initialize Addr_Fetch_VNs for this instruction
         Op_Ctx.Addr_Fetch_VNs := []

         //  Initialize temp mapping from locator to addr vn
         Op_Ctx.Locator_To_Addr := []
      end if

      if Op_Ctx.Pass != #find_basic_blocks
        and then I in Op_Ctx.Instr_To_Node_Map
      then
         //  Do the processing for the start of a basic block
         case Op_Ctx.Pass of
            [#build_cfg] =>
               //  Start of a basic block
               const Prev_Node_Id := Op_Ctx.Cur_Node_Id
               Op_Ctx.Cur_Node_Id := Op_Ctx.Instr_To_Node_Map[I]
               if Prev_Node_Id not null then
                  //  End the prior block if not already ended
                  ref Prev_Node => Op_Ctx.CFG[Prev_Node_Id]
                  if Prev_Node.Last is null then
                     // Prior block not yet ended; end it and add an edge
                     Prev_Node.Last := I - 1
                     const Ignore := Op_Ctx.CFG.Add_Edge(From => Prev_Node_Id,
                       To => Op_Ctx.Cur_Node_Id)
                  end if
               end if
               if Op_Ctx.Cur_Node_Id in Op_Ctx.CFG_Entry_Nodes then
                  //  This is the entry node of a CFG
                  Op_Ctx.Cur_Entry_Node := Op_Ctx.Cur_Node_Id
                  //  Identify the exit node
                  Op_Ctx.Cur_Exit_Node :=
                    Op_Ctx.Entry_Node_To_Exit_Node_Map[Op_Ctx.Cur_Entry_Node]
               end if
            [#value_number] =>
               //  Set the Cur_Node_Id
               Op_Ctx.Cur_Node_Id := Op_Ctx.Instr_To_Node_Map[I]

               //  Set the Cur_Out_Of_Line_Root/Level
               for N := Op_Ctx.Entry_Node_For_BB(Op_Ctx.Cur_Node_Id) loop
                  if N in Op_Ctx.CFG.Roots() then
                     //  Found a block that is an out-of-line root
                     Op_Ctx.Cur_Out_Of_Line_Root  := N
                     Op_Ctx.Cur_Out_Of_Line_Level := Op_Ctx.Level_Of_BB(N)
                  else
                     //  Go to enclosing block
                     continue loop
                       with N => Op_Ctx.Entry_Node_For_BB(N, Uplevel => 1)
                  end if
               end loop

               //  Incorporate incoming-edge info into the Addr_To_OID
               //  and OID_To_VN maps.
               Value_Number_Start_Of_Block(Op_Ctx)

               //  Do VN processing upon *returning* from a nested block
               if I > 1 then
                  const Prev_Instr := Operation_Routine.Nth_Instr(I-1)
                  case Opcode(Prev_Instr) of
                   [#Check_Nested_Block_Op] =>
                     //  Save value number of assertion
                     const Nested_Block_Start :=
                       I + Prev_Instr.Code_Block().Pc_Offset
                     const Nested_Block_Node_Id :=
                       Op_Ctx.Instr_To_Node_Map[Nested_Block_Start]
                     const Nested_Block_Level :=
                       Level_Of_BB(Op_Ctx, Nested_Block_Node_Id)
                     const Result_Addr := Op_Ctx.VN_Data.Table.Get_Unique_Id
                        (Param_Addr_VN::
                           (Level => Nested_Block_Level,
                            BB_Id => Nested_Block_Node_Id,
                            Offset => 0))
                     const Result_Val := Fetch_Value
                                (Op_Ctx, Result_Addr,
                                 Source_Pos,
                                 Origin =>
                                   Code_Origin::(I-1, Which_Output => 1))
                     Op_Ctx.Boolean_VNs |= Result_Val

                     //  Add result to vector of assertions associated with
                     //  "Exit_Op" of nested block
                     const Preds :=
                       Op_Ctx.CFG.Predecessors(Op_Ctx.Cur_Node_Id)
                     {|Preds| == 1}  // Should be only one predecessor

                     const Exit_Instr := Op_Ctx.CFG[Preds[1]].Last
                     {Operation_Routine.Nth_Instr(Exit_Instr).Opcode() ==
                        #Exit_Op}  //  Should be an Exit instruction

                     Op_Ctx.Instr_To_Assertions_Map[Exit_Instr] := [Result_Val]
                        // NOTE: we are putting it on the Exit_Op
                     if Debug_Value_Numbering then
                        Println("Adding assertion VN" | Result_Val |
                          " with Instr#" | Exit_Instr)
                     end if
                   [..] => null  //  TBD: Call_Nested_Block
                  end case
               end if // Special post-nested-block VN processing

            [..] => null
         end case
      end if

      if Debug_Value_Numbering and then Op_Ctx.Pass == #value_number then
         Print (" Value_Numbering Instr#`(I): ");
         Debugging::Dump_One_Instr(IO.Stdout, Instr, 0);
      end if

      //  Remember prior OID_To_VN_Map
      const Former_Addr_To_OID_Map := Op_Ctx.Addr_To_OID_Map
      const Former_OID_To_VN_Map := Op_Ctx.OID_To_VN_Map

      //  Take the appropriate action based on Pass and instruction opcode
      case Opcode(Instr) of
         [#Skip_Op] =>
            //  Skip_Count is in units of PSVM instructions
            case Op_Ctx.Pass of
               [#find_basic_blocks] =>
                  //  Keep track of where basic blocks start.
                  Op_Ctx.Node_Starts |= (I + Instr.Skip_Count() + 1)
               [#build_cfg] =>
                  //  Keep track of where basic block ends and
                  //  outgoing edges.
                  Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
                  const Ignore :=
                    Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                      To => Op_Ctx.Instr_To_Node_Map[I+Instr.Skip_Count()+1])
               [..] =>
                  null
            end case
         [#Call_Op] =>
            if Op_Ctx.Pass == #value_number then
               Value_Number_Call(Op_Ctx, Instr.Target_Index(),
                 Instr.Params(), I)
            end if
         [#Return_Op | #Exit_Op] =>
            case Op_Ctx.Pass of
               [#find_basic_blocks] =>
                  //  Remember last return/exit statement
                  Op_Ctx.Last_End_Instr := I
               [#build_cfg] =>
                  //  Cur basic block ends here
                  Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
                  if Op_Ctx.Cur_Node_Id != Op_Ctx.Cur_Exit_Node then
                     //  This is not the exit node, so we need to add an
                     //  edge to an exit node
                     const Ignore :=
                       Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                         To => Op_Ctx.Cur_Exit_Node)

                     //  This node should not be listed as an exit node
                     {Op_Ctx.Cur_Node_Id not in Op_Ctx.CFG_Exit_Nodes}
                  end if
               [..] => null
            end case
            //  TODO Return_Op postcondition proved
         [#Copy_Word_Op | #Assign_Word_Op | #Copy_Address_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Simple copy-word; copy OID from source to destination
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                   Which_Output => 5,
                   Might_Be_Null => Might_Be_Null(Instr))
               const Ignore_Source_Val :=  //  Used by Compiler
                 Fetch_Base_Value(Op_Ctx, Source_Addr,
                             Source_Pos, Origin => Code_Origin::(I, 4),
                             Might_Be_Null => Might_Be_Null(Instr))
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Which_Output => 3)
               const Source_OID := Get_OID
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 1))
               // Set new OID for destination
               Store_OID(Op_Ctx, Dest_Addr, New_OID => Source_OID,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 2))
            end if

         [#Make_Copy_In_Stg_Rgn_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Create copy of object; copy value from source to destination
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                   Which_Output => 6,
                   Might_Be_Null => Might_Be_Null(Instr))
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Which_Output => 3)
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 2),
                              Might_Be_Null => Might_Be_Null(Instr))

               //  Initialize VN table for existing obj
               //  in case compiler needs it
               const Existing_Obj_Addr :=
                 Value_Number_Locator
                   (Op_Ctx, Existing_Obj_In_Stg_Rgn(Instr), I,
                    Which_Output => 4)
               const Existing_Obj := Fetch_Base_Value
                                      (Op_Ctx, Existing_Obj_Addr,
                                       Source_Pos,
                                       Origin => Code_Origin::(I, 5))

               // Set new OID and value for destination
               Store_Value(Op_Ctx, Dest_Addr, Source_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1),
                 Make_Copy => #true)
            end if
         [#Store_Address_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Store address of source in destination
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                                      Which_Output => 3,
                                      Might_Be_Null => Might_Be_Null(Instr))
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                                      Which_Output => 2)
               //  NOTE: We do not need to freeze any updated value of the
               //        source here because we are preserving the mapping
               //        from address to OID, which will still be correct
               //        upon an indirection through the destination.

               // Set new value for destination
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Source_Addr,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))

               if not Might_Be_Null(Instr) then
                  //  Get the OID for the source now so we can remember
                  //  that it cannot be null.
                  const Ignore := Get_OID(Op_Ctx, Source_Addr,
                    Source_Pos => Source_Pos,
                    Origin => Code_Origin::(I, 2),
                    Might_Be_Null => #false)

                  //  Remember that deref of dest-addr is non-null
                  Op_Ctx.Deref_Non_Null |= Dest_Addr
                  if Debug_Value_Numbering then
                     Println(" deref of VN" | Dest_Addr |
                       " is addr of non-null obj")
                  end if
               end if
            end if
         [#Declare_Obj_Op] =>
            null;  //  TBD: Make use of this information somehow

         [#Create_Obj_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Create an Aggregate_VN with nothing filled in
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Aggr := Op_Ctx.VN_Data.Table.Get_Unique_Id
                 (Aggregate_VN::(Type_Info => Type_Info(Instr),
                                 Might_Be_Null => #false,
                                 Base_Val => null,
                                 Kind_Of_Selectors => #named,
                                 Components => []))
               const Source_Loc := Source(Instr)
               if Source_Loc.Base() != Zero_Base then
                  const Source_Addr :=
                    Value_Number_Locator(Op_Ctx, Source_Loc, I,
                                         Might_Be_Null => Might_Be_Null(Instr))
                  const Ignore_Source_Value :=
                          Fetch_Base_Value // Determines region
                            (Op_Ctx, Source_Addr, Source_Pos,
                             Origin => Code_Origin::(I, 2),
                             Might_Be_Null => Might_Be_Null(Instr))
               end if

               Store_Value(Op_Ctx, Dest_Addr, New_Val => Aggr,
                  Source_Pos => Source_Pos,
                  Origin => Code_Origin::(I, 1),
                  Make_Copy => #true)
            end if
         [#Swap_Obj_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Dest <=> Src
               //  Swap the OIDs, but no change in value tables
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                   Which_Output => 6, Might_Be_Null => Might_Be_Null(Instr))
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Which_Output => 5)
               const Source_OID := Get_OID
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 4))
               const Source_Val := Fetch_OID_Value
                                   (Op_Ctx, Source_OID, Source_Pos, I)
                                    // Get VN for Source_OID as that is needed
                                    // for all addrs that appear in UV.
               const Dest_OID := Get_OID
                             (Op_Ctx, Dest_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 3))
               const Dest_Val := Fetch_OID_Value
                                   (Op_Ctx, Dest_OID, Source_Pos, I)
                                    // Get VN for Dest_OID as that is needed
                                    // for all addrs that appear in UV.
               // Swap the OIDs
               Store_OID(Op_Ctx, Dest_Addr, New_OID => Source_OID,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 2))
               Store_OID(Op_Ctx, Source_Addr, New_OID => Dest_OID,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Move_Obj_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Dest => Src; null => Dest
               //  Move the OID, but no change in value tables
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                   Which_Output => 3, Might_Be_Null => Might_Be_Null(Instr))
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Which_Output => 2)
               const Source_OID := Get_OID
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 3))
               const Source_Val := Fetch_OID_Value
                                   (Op_Ctx, Source_OID, Source_Pos, I)
                                    // Get VN for Source_OID as that is needed
                                    // for all addrs that appear in UV.
               // Set new OID for destination
               Store_OID(Op_Ctx, Dest_Addr, New_OID => Source_OID,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 2))
               // Set Source to null
               const Null_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                (Null_Literal_VN::(Origin => I))
               Store_Value(Op_Ctx, Source_Addr, New_Val => Null_Val,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Local_Null_Op | #Store_Large_Local_Null_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                (Null_Literal_VN::(Origin => I))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Null_Of_Same_Stg_Rgn_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Which_Output => 4)
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                   Which_Output => 3, Might_Be_Null => Might_Be_Null(Instr))
               const Source_Base_Value := Fetch_Base_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 2),
                              Might_Be_Null => Might_Be_Null(Instr))
                                                  // Determines region
               //  TBD: Currently this causes Source to appear as might-be-null
               //       A later Get_OID with Source non-null needs
               //       to override this, or we need to change
               //       the generator of Store_Null_Of_Same_Stg_Rgn_Op
               //       to provide a meaningful Might_Be_Null flag.

               const Lit_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                (Null_Literal_VN::(Origin => I))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Is_Null_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                                      Might_Be_Null => Might_Be_Null(Instr))
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 2),
                              Might_Be_Null => Might_Be_Null(Instr))
               const Not_Null_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                (Not_Null_VN::(Tested_Val => Source_Value))
               const Is_Null_Val := Logical_Not (Op_Ctx, Not_Null_Val)
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Is_Null_Val,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
               Op_Ctx.Boolean_VNs |= Not_Null_Val
            end if
         [#Not_Null_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, Source(Instr), I,
                                      Might_Be_Null => Might_Be_Null(Instr))
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 2),
                              Might_Be_Null => Might_Be_Null(Instr))
               const Not_Null_Val := Op_Ctx.VN_Data.Table.Get_Unique_Id
                                (Not_Null_VN::(Tested_Val => Source_Value))
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Not_Null_Val,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))

               Op_Ctx.Boolean_VNs |= Not_Null_Val
            end if
         [#Store_Int_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value :=
                 Op_Ctx.VN_Data.Table.Get_Int_Literal_VN(Int_Value(Instr))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Real_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id
                   (Real_Literal_VN::(Value => Real_Value(Instr)))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Char_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id
                   (Char_Literal_VN::(Value => Char_Value(Instr)))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Enum_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Lit_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id
                   (Enum_Literal_VN::(Value => Enum_Value(Instr)))
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Str_Lit_Op] =>
            if Op_Ctx.Pass == #value_number then
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                    Which_Output => 4)
               if not Is_Null_Locator(Existing_Str_In_Stg_Rgn(Instr)) then
                  //  Fetch value of existing object so it is available
                  //  for VN optimizer.
                  const Existing_Obj_Addr :=
                    Value_Number_Locator
                      (Op_Ctx, Existing_Str_In_Stg_Rgn(Instr), I,
                       Which_Output => 3, Might_Be_Null => #true)
                  const Existing_Base_Value := Fetch_Base_Value
                             (Op_Ctx, Existing_Obj_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 2))
                                                  // Determines region
               end if
               const Str_Lit : String_Literal_VN :=
                 (Value => Str_Value(Instr))
               const Lit_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id(Str_Lit)
               //  Put lit value into map
               Store_Value(Op_Ctx, Dest_Addr, New_Val => Lit_Value,
                 Source_Pos => Source_Pos,
                 Origin => Code_Origin::(I, 1))
            end if
         [#Store_Operation_Desc_Op] =>
            //  ** TBD **
            Put_Error ("NYI: " | Opcode(Instr))
         [#Start_Parallel_Op | #Add_Parallel_Op] =>
            //  We treat a Start/Add_Parallel_Op, which is not associated with
            //  a concurrent "for" loop, as a jump to the start of the
            //  nested block, and a jump back from the end of the nested block
            //  to the next instruction, presuming the block executes
            //  immediately.
            //  This doesn't catch any race conditions, but those are detected
            //  before this stage of analysis.
            const Is_Out_Of_Line := (Num_In_Params(Instr) > 0)
                              //  Only out-of-line "for" loops have "in" params

            case Op_Ctx.Pass of
               [#find_basic_blocks] =>
                  //  Keep track of where basic blocks start.
                  const Nested_Block_Start :=
                    I + Instr.Parallel_Code_Block().Pc_Offset + 1;
                  Op_Ctx.Node_Starts |= Nested_Block_Start

                  if not Is_Out_Of_Line then
                     //  This Start/Add_Parallel_Op is treated as a jump/return
                     Op_Ctx.Node_Starts |= (I + 1)
                  end if
               [#build_cfg] =>
                  //  Get target nested block
                  const Nested_Block_Start :=
                    I + Instr.Parallel_Code_Block().Pc_Offset + 1;

                  const Nested_Block :=
                    Op_Ctx.Instr_To_Node_Map[Nested_Block_Start]

                  if Is_Out_Of_Line then
                     //  Mark this nested block as an out-of-line block
                     //  and hence a separate root of a CFG.
                     if Nested_Block not in Op_Ctx.CFG.Roots() then
                        Op_Ctx.CFG.Add_Root(Nested_Block)
                        //  Also remember the invoking block so can walk
                        //  up the chain.
                        Op_Ctx.Invoking_Block[Nested_Block] :=
                          Op_Ctx.Cur_Node_Id
                     end if
                  else
                     //  Block is treated via in-line expansion
                     //  Keep track of where basic block ends and
                     //  outgoing edges.
                     Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I

                     const Ignore :=
                       Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                         To => Nested_Block)  // Jump to nested block

                     if Nested_Block_Start > I then
                        //  This is a "forward" invocation, so create a jump
                        //  back to this point from end of nested block.
                        const Ignore2 :=
                          Op_Ctx.CFG.Add_Edge
                            (From =>
                              Op_Ctx.Entry_Node_To_Exit_Node_Map[Nested_Block],
                             To => Op_Ctx.Instr_To_Node_Map[I+1])

                        //  Also remember the location of the param area in
                        //  case it is referenced from inside the nested block.
                        if Instr.Num_In_Params() > 0
                          or else Instr.Num_Out_Params() > 0
                        then
                           Op_Ctx.Nested_Block_Param_Area[Nested_Block] :=
                             Instr.Parallel_Control().Offset() +
                               Reflection::Tcb_Size
                        end if
                     else
                        //  This is a "backward" invocation, so add a fall
                        //  through to next instruction to avoid having a
                        //  dead block.
                        //  TBD: Do we still need this if we treat for-loop
                        //       blocks as out-of-line calls?
                        const Ignore3 :=
                          Op_Ctx.CFG.Add_Edge
                            (From => Op_Ctx.Cur_Node_Id,
                             To => Op_Ctx.Instr_To_Node_Map[I+1])
                     end if
                  end if
               [#value_number] =>
                  //  TBD: What do we want to do here as far as uses/defs
                  //       of parameters if this is a for-loop?
                  //       Do we want to use Value_Number_Call?
                  //  Indicate that there is a possible up-level ref in this
                  //  basic block.
                  //  TBD: Could postpone this and provide a precise
                  //       indication of what up-level refs actually occur.
                  const Cur_Node := Op_Ctx.Cur_Node_Id;

                  Possible_Uplevel_Ref(Op_Ctx, Cur_Node)

               [..] => null
            end case
         [#Start_Parallel_Call_Op | #Add_Parallel_Call_Op] =>
            //  TODO: Precond Proved
            //  We treat a parallel call as though it takes no time
            //  at all, and is essentially equivalent to a regular call.
            //  This is not good for race detection, but works for most things.
            if Op_Ctx.Pass == #value_number then
               const Tcb_Locator := Instr.Parallel_Control()
               const Params : Object_Locator :=
                 Create(Tcb_Locator.Base(),
                        Tcb_Locator.Offset() + Reflection::Tcb_Size)

               Value_Number_Call(Op_Ctx, Instr.Parallel_Target_Index(),
                 Params, I)
            end if
         [#Prepare_To_Exit_Parallel_Op] =>
            null;
         [#Wait_For_Parallel_Op] =>
            //  Always a no-op in this model.
            null;
         [#Create_Lock_For_Obj_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Load the destination so value number is initialized
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I,
                   Might_Be_Null => #false)
               const Ignore_Dest_Val :=  //  Used by Compiler
                 Fetch_Base_Value(Op_Ctx, Dest_Addr,
                             Source_Pos, Origin => Code_Origin::(I, 1))
            end if;
            //  Create Lock uses Virtual addresses
         [#Create_Tcb_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Create an Aggregate_VN with nothing filled in,
               //  to represent the parameters to the nested block (loop body).
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Parallel_Control(Instr), I)
               const Aggr := Op_Ctx.VN_Data.Table.Get_Unique_Id
                 (Aggregate_VN::(Type_Info => null,  // TBD?
                                 Might_Be_Null => #false,
                                 Base_Val => null,
                                 Kind_Of_Selectors => #named,
                                 Components => []))

               Store_Value(Op_Ctx, Dest_Addr, New_Val => Aggr,
                  Source_Pos => Source_Pos,
                  Origin => Code_Origin::(I, 1),
                  Make_Copy => #true)
            end if
         [#Create_Polymorphic_Obj_Op] =>
            Put_Error ("NYI: " | Opcode(Instr))
            //  Get destination and type descriptor
            if Op_Ctx.Pass == #value_number then
               //  Create an Aggregate_VN with one component.
               const Dest_Addr :=
                 Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Aggr := Op_Ctx.VN_Data.Table.Get_Unique_Id
                 (Aggregate_VN::(Type_Info => null,  // TBD?
                                 Might_Be_Null => #false,
                                 Base_Val => null,
                                 Kind_Of_Selectors => #named,
                                 Components => []))  //  TBD

               Store_Value(Op_Ctx, Dest_Addr, New_Val => Aggr,
                  Source_Pos => Source_Pos,
                  Origin => Code_Origin::(I, 1),
                  Make_Copy => #true)
            end if
         [#Unwrap_Polymorphic_Obj_Op] =>
            null;  //  ** TBD **
            Put_Error ("NYI: " | Opcode(Instr))
         [#Select_Polymorphic_Ancestor_Part_Op |
          #Select_Ancestor_Part_Op] =>
            null;  //  ** TBD **
            Put_Error ("NYI: " | Opcode(Instr))
         [#If_Op] =>
            //  Two basic blocks as successors
            case Op_Ctx.Pass of
             [#find_basic_blocks] =>
               //  Keep track of where basic blocks start.
               Op_Ctx.Node_Starts |= (I + 1)
               Op_Ctx.Node_Starts |= (I + Instr.Skip_If_False() + 1)

             [#build_cfg] =>
               //  Keep track of where basic block ends and
               //  outgoing edges.
               Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
               const Ignore := Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                 To => Op_Ctx.Instr_To_Node_Map[I+1])
               const Ignore2 := Op_Ctx.CFG.Add_Edge(From => Op_Ctx.Cur_Node_Id,
                 To => Op_Ctx.Instr_To_Node_Map[I+Instr.Skip_If_False()+1])

             [#value_number] =>
               //  Determine the "path condition" for each outgoing edge
               const Source_Addr :=
                 Value_Number_Locator(Op_Ctx, If_Source(Instr), I)
               const Source_Value := Fetch_Value
                             (Op_Ctx, Source_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 1))
               const Val_Is_True :=
                 Apply_Condition_Mask
                   (Op_Ctx, Source_Value, If_Condition(Instr))
               const Val_Is_False := Logical_Not(Op_Ctx, Val_Is_True)
               const True_Edge :=
                 Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Outgoing_Edges[1]
               const False_Edge :=
                 Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Outgoing_Edges[2]
               Op_Ctx.Edge_Condition[True_Edge] := Val_Is_True
               Op_Ctx.Edge_Condition[False_Edge] := Val_Is_False
             [..] =>
               null
            end case
         [#Call_Nested_Block_Op] =>
            //  Call_Nested_Block not yet used. 
            null;
         [#Check_Nested_Block_Op] =>
            //  We assume that there is only one use of a given nested block
            //  as a check.
            case Op_Ctx.Pass of
               [#find_basic_blocks] => 
                  //  Basic block starts at next instruction
                  Op_Ctx.Node_Starts |= (I + 1)
               [#build_cfg] =>
                  //  Basic block ends here
                  Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last := I
                  //  Add edges to/from nested block
                  const Nested_Block_Start :=
                    I + Instr.Code_Block().Pc_Offset + 1
                  const Nested_Block_Node_Id :=
                    Op_Ctx.Instr_To_Node_Map[Nested_Block_Start]
                  const Nested_Block_End_Id :=
                    Op_Ctx.Entry_Node_To_Exit_Node_Map[Nested_Block_Node_Id]
                  //  Add edge to nested block
                  const Ignore := Op_Ctx.CFG.Add_Edge
                    (From => Op_Ctx.Cur_Node_Id,
                     To => Nested_Block_Node_Id)
                  //  Add edge back from end of nested block to next instr
                  const Ignore2 := Op_Ctx.CFG.Add_Edge
                    (From => Nested_Block_End_Id,
                     To => Op_Ctx.Instr_To_Node_Map[I+1])
               [#value_number] => null
                  //  NOTE: We do the value numbering of the result
                  //        of the nested block at the beginning of
                  //        the basic block that is a successor of the block.
               [..] => null
            end case
         [#Begin_Nested_Block_Op] =>
            case Op_Ctx.Pass of
               [#find_basic_blocks] => 
                  // Last exit/return is considered its own basic block
                  {Op_Ctx.Last_End_Instr not null}
                  Op_Ctx.Node_Starts |= Op_Ctx.Last_End_Instr
                  Op_Ctx.CFG_Ends |= Op_Ctx.Last_End_Instr
                  Op_Ctx.Last_End_Instr := null

                  //  Consider this the beginning of a basic block
                  Op_Ctx.Node_Starts |= I
                  //  Also remember this as the start of a nested block
                  Op_Ctx.Nested_Block_Starts |= I
               [#build_cfg] => null
               [..] => null
            end case
         [#Check_Not_Null_Op] =>
            if Op_Ctx.Pass == #value_number then
               //  Save value number of checked object
               const Dest_Addr :=
                  Value_Number_Locator(Op_Ctx, Destination(Instr), I)
               const Dest_Value := Fetch_Value
                             (Op_Ctx, Dest_Addr,
                              Source_Pos,
                              Origin => Code_Origin::(I, 1))

               //  Add assertion that Dest_Value is not null
               Op_Ctx.Assert_Non_Null(Dest_Value, I)
            end if
         [#Indirect_Call_Op] =>
            null;  //  ** TBD **
            Put_Error ("NYI: " | Opcode(Instr))
         [..] =>
            Put_Error
              ("Internal: Unrecognized PSVM Opcode " | Opcode(Instr),
               Source_Pos);
            {#false};
      end case

      //  Perform end-of-instruction processing to
      //  update Addr_Store_VNs table
      //  TBD: Don't output same VN more than once, or should we leave that to
      //       the compiler to worry about?
      //       Similarly, we need to actually load VNs that haven't been
      //       defined yet, but again, perhaps that is better done in the
      //       compiler?

      if Op_Ctx.Pass == #value_number then
         var Addr_Store_VNs :
           optional Map<Addr_VN_Id, VN_Id> for Op_Ctx := []
                             //  A map from Addr VN stored
                             //  to associated (content) VN

         
         func Check_For_Update(Addr : Addr_VN_Id) is
            //  If contents of given address changed during this instruction
            //  then add it to Addr_Store_VNs map.

            if Addr in Op_Ctx.Addr_To_OID_Map
              and then Addr not in Addr_Store_VNs
            then
               //  Something has been stored in address,
               //  but we haven't already recorded its new value.
               const Loc_OID := Op_Ctx.Addr_To_OID_Map[Addr]
               if Loc_OID in Op_Ctx.OID_To_VN_Map then
                  const Loc_Base_VN :=
                    Op_Ctx.Aggr_Base(Op_Ctx.OID_To_VN_Map[Loc_OID])

                  if Addr not in Former_Addr_To_OID_Map
                    or else Loc_OID != Former_Addr_To_OID_Map[Addr]
                    or else Loc_OID not in Former_OID_To_VN_Map
                    or else
                      Loc_Base_VN !=
                        Op_Ctx.Aggr_Base(Former_OID_To_VN_Map[Loc_OID])
                  then
                     //  Value at Locator has changed, add to set
                     Addr_Store_VNs |= [Addr => Loc_Base_VN]
                  end if
               end if
            end if
         end func Check_For_Update

         //  See whether contents of addrs produced by Value_Number_Locator
         //  have changed.
         for each Addr of Op_Ctx.Locator_To_Addr loop
            Check_For_Update(Addr)
         end loop

         //  See whether contents of addrs from which we fetched a value
         //  have changed.
         for each [Addr => Val] of Op_Ctx.Addr_Fetch_VNs loop
            Check_For_Update(Addr)
         end loop

         if Debug_VN_IL then
            if |Op_Ctx.Addr_Fetch_VNs| > 0 then
               Println("Addr_VN-Fetch to VN mapping for instr#" | I)
               for each [Loc => VN] of Op_Ctx.Addr_Fetch_VNs loop
                  Print(" Addr-VN`(Loc)=>VN" | VN)
               end loop
               Println("")
            end if
            if |Addr_Store_VNs| > 0 then
               Println("Addr_VN-Store to VN mapping for instr#" | I)
               for each [Loc => VN] of Addr_Store_VNs loop
                  Print(" Addr-VN`(Loc)=>VN" | VN)
               end loop
               Println("")
            end if
         end if

         //  Update map from instruction to set of fetches/stores
         Op_Ctx.Instr_To_Addr_Fetch_VNs[I] <== Op_Ctx.Addr_Fetch_VNs;
         Op_Ctx.Instr_To_Addr_Store_VNs[I] <== Addr_Store_VNs;

         //  Update map from instruction to locator->addr map
         Op_Ctx.Instr_To_Locator_Map[I] <== Op_Ctx.Locator_To_Addr
      end if

      //  Perform end-of-basic-block processing
      if Op_Ctx.Pass == #value_number then
         if I == Op_Ctx.CFG[Op_Ctx.Cur_Node_Id].Last then
            //  End of current basic block
            Value_Number_End_Of_Block(Op_Ctx)
         end if
      end if

   end func Analyze_One_Instr;

   func Propagate_Top_Down
     (Op_Ctx;
      Dest_BB : CFG::Node_Id;
      var VN_Values : VN_To_Value_Set_Map_Type;
      var VSet_Was_Null : VN_Set;
      Updated_VNs : VN_Set) -> VNs_To_Recompute : optional VN_Set is
      //  Propagate values of Updated_VNs to their children
      //  (and further descendants)
      //  Update VN_Values with new values of VNs;
      //  add to VSet_Was_Null for VNs computed to have a null value set;
      //  return set of VNs needing to be recomputed bottom-up.
      //  Return a null set if an empty set occurs, and don't update the
      //  value set.

      ref DT => Op_Ctx.CFG.Get_Dominator_Tree()

      var Phis_With_Reduced_Value_Set : VN_Set := []
        //  Set of Phis that shrink as part of this top-down propagation

      var Non_LH_Blocks_With_Reduced_Phis : Node_Set := []
        //  Set of non-loop-header blocks defining phis that shrink

      func Recursive_Top_Down (VNs_To_Prop : VN_Set)
        -> Parents_To_Recompute : optional VN_Set is
        //  Recursive version of Propagate_Top_Down

         if Is_Empty(VNs_To_Prop) then
            //  Nothing to do
            return []
         end if

         if Debug_Propagation then
            Println("Recursive_Top_Down:" |
              (for VN in VNs_To_Prop forward => <""> | " VN" | VN))
         end if

         //  Initialize Parents_To_Recompute with parents of VNs_To_Prop
         Parents_To_Recompute := (for VN in VNs_To_Prop => <[]> |
                                    Op_Ctx.VN_To_Parent_Set_Map[VN])

         for VN in VNs_To_Prop loop
            var Changed_Operands : VN_Set := []

            func Update_Val_Set(Opnd : VN_Id; New_Vals : Value_Set+)
              -> Result : How_Reduced is
              //  Update Opnd's value set unless would shrink to empty.
              //  Add to Changed_Operands if reduced to non-empty.
              //  Return How_Reduced to indicate effect of update.
               Result := #unchanged
               if Opnd not in VN_Values or else New_Vals != VN_Values[Opnd] then
                  //  Update Opnd's value set.
                  if Opnd not in VN_Values then
                     if Is_Empty(New_Vals) then
                        Result := #reduced_to_empty
                     else
                        //  Keep track of operands with new values.
                        Changed_Operands |= Opnd
                        VN_Values[Opnd] := New_Vals
                        Result := #reduced
                     end if
                  else
                     Result := Intersect_With_Vals(VN_Values[Opnd], New_Vals,
                       Restore_If_Empty => #true)
                     if Result == #reduced then
                        //  Keep track of operands with new values.
                        Changed_Operands |= Opnd
                     end if
                  end if
                  if Debug_Propagation then
                     Println(" TD: New value set for VN" | Opnd |
                       " is " | To_String(VN_Values[Opnd]) |
                       " (`(Result))")
                  end if
               end if
            end func Update_Val_Set

            ref Val_Num => Op_Ctx.VN_Data.Table[VN]
            ref Val_Set => VN_Values[VN]

            case Val_Num of
               [Phi : Phi_VN] =>
                  // Handle Phi_VNs specially -- if any Phi's vals shrink
                  // then copy the phi value sets into the value set for
                  // their input VNs in each edge value map, and then
                  // recombine the edge value maps and intersect them
                  // with the current value map.
                  Phis_With_Reduced_Value_Set |= VN
                  if not DT.Is_Loop_Header (Phi.Phi_Block) then
                     Non_LH_Blocks_With_Reduced_Phis |= Phi.Phi_Block
                  end if

               [..] => null
            end case

            const New_Opnd_Values :=
              Propagate_To_Operands
                (Val_Num, Val_Set, Op_Ctx.VN_Data.Table, VN_Values)

            if New_Opnd_Values is null then
               //  Top-down propagation failed
               if Debug_Propagation then
                  Println(" Propagate_To_Operands `(Val_Num) having " |
                    To_String(Val_Set) | " returned null")
               end if
               return null  // -- Top-down failure -- //
            end if

            for each [Opnd => New_Vals] of New_Opnd_Values loop
               //  Update value set of each operand affected by propagation
               if Update_Val_Set (Opnd, New_Vals) == #reduced_to_empty then
                  if Debug_Propagation then
                     Println(" Update_Val_Set on VN`(Opnd) with " |
                       To_String(Val_Set) | " produced the empty set")
                  end if
                  return null  // -- Top-down failure -- //
               end if
            end loop

            if not Is_Empty(Changed_Operands) then
               //  Recurse with changed operands, and include parents of
               //  changed operands but not the VN that caused the top-down prop.
               const Recursive_Changes :=
                 Recursive_Top_Down (VNs_To_Prop => Changed_Operands)

               if Recursive_Changes is null then
                  //  Some check failed
                  return null
               end if

               const Parents : VN_Set :=
                  (for Opnd in Changed_Operands => 
                    <[]> | Op_Ctx.VN_To_Parent_Set_Map[Opnd])

               Parents_To_Recompute |= (Recursive_Changes | Parents) - VN
            end if
         end loop
      end func Recursive_Top_Down

      //  Hand off to recursive function
      VNs_To_Recompute := Recursive_Top_Down (Updated_VNs)

      //  Now handle phis that have shrunk (unless the top-down prop fails)
      if VNs_To_Recompute not null
        and then not Is_Empty(Non_LH_Blocks_With_Reduced_Phis)
      then
         if Debug_Phis then
            Println("Propagate_Top_Down of BB`(Dest_BB) of " |
              Op_Ctx.Routine.Name() | ", Phis have shrunk:" |
              (for VN in Phis_With_Reduced_Value_Set forward =>
                 <""> | " VN" | VN))
            Println("  non-LH-Blocks with reduced phis:" |
              (for BB in Non_LH_Blocks_With_Reduced_Phis forward =>
                 <""> | " BB" | BB))
         end if

         //  Walk up the dominator tree, looking for join points
         //  that have "shrunken" phis.
         for Join_BB := Dest_BB then DT.Immediate_Dominator(Join_BB)
           while Join_BB not in DT.Roots()
                 and then not Is_Empty(Non_LH_Blocks_With_Reduced_Phis)
             {Join_BB in Non_LH_Blocks_With_Reduced_Phis}
           forward loop
            //  This is a join point with phis whose value set has shrunk.
            //  Look at each of the predecessors and merge it with the
            //  Dest_BB's VN_Values.
            //  NOTE: Currently we ignore loop headers.
            //       If loop header has one forward edge and one back edge,
            //       then if phi shrinks, that means that current block
            //       could not be entered on some particular iteration,
            //       or assertion would fail on a particular iteration.
            //       Not terribly useful to know.
            ref Join_Node => Op_Ctx.CFG[Join_BB]
            var New_VN_Vals : optional VN_To_Value_Set_Map_Type := null
            
            //  Remove this block from set so can know when done
            Non_LH_Blocks_With_Reduced_Phis -= Join_BB

            if Debug_Phis then
               Println("  propagating shrunken phis in BB" | Join_BB |
                 (Is_Empty(Non_LH_Blocks_With_Reduced_Phis)?
                    " [BB set now empty]" : ""))
            end if

            //  Iterate over incoming edges of join point
           *Edge_Loop*
            for each [Edge_Num => In_Edge] of Join_Node.Incoming_Edges
            loop
               {not DT.Is_Back_Edge(In_Edge)}
                  // Since we aren't allowing loop headers
               const Pred_BB := Op_Ctx.CFG.Nth_Edge(In_Edge).From
               var Reduced_Edge_Vals := Op_Ctx.Edge_Values[In_Edge]

               //  Intersect Edge value-map with cur-bb value-map
               var Reduced_VNs :=
                 Intersect_Value_Maps(Reduced_Edge_Vals, VN_Values)

               if Reduced_Edge_Vals is null then
                  //  Dest_BB cannot be reached from this edge
                  if Debug_Phis then
                     Println("Propagate_Top_Down: " |
                       "Intersect maps shows cannot reach BB" |
                       Dest_BB | " via edge BB" |
                       Pred_BB | "->BB" | Join_BB)
                  end if
               else
                  //  Could reach Dest_BB via this edge.
                  //  Shrink the phi inputs, and re-combine
                  if Join_BB in Op_Ctx.VN_Data.Node_Phi_Id_Maps then
                     for each Phi of Op_Ctx.VN_Data.Node_Phi_Id_Maps[Join_BB]
                     loop
                        const Phi_Input :=
                          Op_Ctx.VN_Data.Phi_Id_Inputs[Phi][Edge_Num]

                        if Debug_Phis then
                           if Phi not in VN_Values then
                              Println("Phi not in VN_Values, Phi = VN" | Phi);
                           end if
                        end if
                        //  Shrink Reduced_Edge_Vals for Phi_Input further by
                        //  intersecting with Phi's shrunken value set
                        if Phi in VN_Values  --  Phi has some restriction
                          and then
                            Intersect_With_Vals (Reduced_Edge_Vals[Phi_Input],
                              VN_Values[Phi]) != #unchanged
                        then
                           //  Remember that Phi_Input's value set shrunk
                           Reduced_VNs |= Phi_Input
                        end if

                        if Is_Empty(Reduced_Edge_Vals[Phi_Input]) then
                           //  Cannot reach Dest_BB via this edge
                           Reduced_Edge_Vals := null
                           //  Go to next edge
                           if Debug_Phis then
                              Println("Propagate_Top_Down: " |
                                "Shrinking Phi input VN" | Phi_Input |
                                " of Phi VN`(Phi) shows cannot reach BB" |
                                Dest_BB | " via edge BB" |
                                Pred_BB | "->BB" | Join_BB)
                           end if
                           continue loop Edge_Loop  // Try next edge //
                        end if

                        //  Copy back into Phi so Phi
                        //  ends up as union of inputs.
                        Reduced_Edge_Vals[Phi] := Reduced_Edge_Vals[Phi_Input]
                     end loop
                  end if

                  if not Is_Empty(Reduced_VNs) then
                     //  Recurse to propagate further down
                     var Edge_VSet_Was_Null : VN_Set := []
                     const Edge_VNs_To_Recompute :=
                       Propagate_Top_Down
                         (Op_Ctx, Pred_BB, Reduced_Edge_Vals,
                          Edge_VSet_Was_Null, Reduced_VNs)

                     //  Then propagate bottom up (from VN to its parents)
                     //  Propagate_Bottom_Up returns #false on failure
                     if Edge_VNs_To_Recompute is null
                       or else
                         not Propagate_Bottom_Up
                           (Op_Ctx, Reduced_Edge_Vals,
                            Edge_VSet_Was_Null, Edge_VNs_To_Recompute)
                     then
                        //  Cannot be reached from this edge
                        if Debug_Phis then
                           Println("Propagate_Top_Down: " |
                             "Propagation shows cannot reach BB" |
                             Dest_BB | " via edge BB" |
                             Pred_BB | "->BB" | Join_BB)
                        end if
                        continue loop Edge_Loop  // Try next edge //
                     end if
                  end if

                  if New_VN_Vals is null then
                     //  This is the first edge that can reach Dest_BB
                     New_VN_Vals := Reduced_Edge_Vals
                  else
                     //  Union values with other edges that can reach Dest_BB
                     Union_Value_Maps(New_VN_Vals, Reduced_Edge_Vals)
                  end if
               end if
            end loop Edge_Loop

            //  Replace VN_Values with the newly computed union
            const Changed_VNs := Intersect_Value_Maps(VN_Values, New_VN_Vals)

            //  See if any of the Changed_VNs are phis.  If their
            //  block dominates the Dest_BB, then we will see this block
            //  as we walk up the dominator tree.
            //  If phi's block does not dominate the Dest_BB, then we
            //  will have to recurse to deal with it.
            //  TBD: Handle this special case.

            //  Add Parents of each Changed_VN to VNs_To_Recompute
            for VN in Changed_VNs loop
               VNs_To_Recompute |= Op_Ctx.VN_To_Parent_Set_Map[VN]

               case Op_Ctx.VN_Data.Table[VN] of
                  [Phi : Phi_VN] =>
                     //  Add this VN to set of phis that have shrunk
                     Phis_With_Reduced_Value_Set |= VN
                     if not DT.Is_Loop_Header (Phi.Phi_Block) then
                        //  Add phi's block to set of blocks to process
                        Non_LH_Blocks_With_Reduced_Phis |= Phi.Phi_Block
                        if not DT.Dominates(Phi.Phi_Block, Dest_BB) then
                           //  Block not a dominator of dest block.
                           //  TBD: Handle this case with recursion
                           if Debug_Phis then
                              Println("Propagate_Top_Down: " |
                                "Phi VN" | VN |
                                " from non-dominating block BB" |
                                Phi.Phi_Block | " has shrunk.")
                           end if
                        end if
                     end if

                  [..] => null
               end case
            end loop

            //  Continue to dominator
         end loop
      end if

   end func Propagate_Top_Down

   func Compute_Phi_Value_Set
     (Op_Ctx;
      Phi : VN_Id;
      Phi_Block : CFG::Node_Id;
      VN_Values : VN_To_Value_Set_Map_Type) -> Result : optional Value_Set+ is
      //  Compute value set for Phi by combining values from each edge;
      //  return null if there is no representation for values.
      ref Inputs => Op_Ctx.VN_Data.Phi_Id_Inputs[Phi]
      ref In_Edges => Op_Ctx.CFG[Phi_Block].Incoming_Edges

      var Merged_VSet : optional Value_Set+ := null

      //  Iterate over the edges
      for each [Edge_Num => In_Edge_Id] of In_Edges forward loop
         const Input_VN := Inputs[Edge_Num]
         ref Edge_Vals => Op_Ctx.Edge_Values[In_Edge_Id]

         var Input_Vals : Value_Set+

         if Input_VN in Edge_Vals then
            Input_Vals := Edge_Vals[Input_VN]

            if Input_VN in VN_Values then
               //  See if we know anything more about this input now.
               const Ignore_Whether_Reduced :=
                 Intersect_With_Vals(Input_Vals, VN_Values[Input_VN])
               
               //  TBD: We could go further and combine the whole Edge map
               //       with all of VN_Values and do a full propagation.
               //       This would mimic the notion of a "Phi Input Context"
               //       as used in CodePeer.
            end if

         elsif Input_VN in VN_Values then
            //  We didn't know anything about this input originally,
            //  but now we do
            Input_Vals := VN_Values[Input_VN]
            
         else
            //  We know nothing about one of the inputs, so we know nothing
            //  about the combination.
            if Debug_Propagation then
               Println(" VN`(Input_VN), input " | Edge_Num |
                       " to VN`(Phi) has no value set")
            end if
            return null
         end if

         if Merged_VSet is null then
            //  This is the first edge, just copy it
            Merged_VSet <== Input_Vals
         else
            //  Combine this edge into the merged set
            Union_In_Vals(Merged_VSet, Input_Vals)
         end if
      end loop

      if Debug_Propagation then
         Println("Compute_Phi_Value_Set on VN`(Phi) is " |
           Merged_VSet)
      end if

      //  Return the combination
      return Merged_VSet
   end func Compute_Phi_Value_Set

   func Compute_Value_Set
     (Op_Ctx;
      VN_Values : VN_To_Value_Set_Map_Type;
      VN : VN_Id) -> Result : optional Value_Set+ is
      //  Compute value set for VN; return null if
      //  there is no representation for values.
      ref Val => Op_Ctx.VN_Data.Table[VN]
      var Might_Be_Null : Boolean := #true
      case Val of
         [Phi : Phi_VN] =>
            //  Handle phis specially
            Result := Op_Ctx.Compute_Phi_Value_Set
                        (VN, Phi.Phi_Block, VN_Values)
            Might_Be_Null := Phi.Might_Be_Null

         [Input : Input_VN] =>
            //  Check to see if Input_Addr in Non_Null_Inputs
            Might_Be_Null := Input.Might_Be_Null and then
              Input.Input_Addr not in Op_Ctx.Non_Null_Inputs
            Result := Compute_Value_Set(Input, Op_Ctx.VN_Data.Table, VN_Values)

         [TVN : Typed_VN+] =>
            Might_Be_Null := TVN.Might_Be_Null
            //  Handle with a dispatch
            Result := Compute_Value_Set (Val, Op_Ctx.VN_Data.Table, VN_Values)

         [..] =>
            //  Handle the rest with a dispatch
            Result := Compute_Value_Set (Val, Op_Ctx.VN_Data.Table, VN_Values)
      end case

      if not Might_Be_Null then
         //  Make sure Might_Be_Null of Result is false
         if Result is null then
            //  Nothing more to say than is non-null
            Result :=
              Object_Value_Set::
                (Might_Be_Null => #false, Might_Be_Non_Null => #true)
         else
            //  Remove null from value set
            Result.Might_Be_Null := #false
         end if
      end if

      if Debug_Propagation and then Result is null then
         //  Value set not representable
         Println(" Compute_Value_Set null for VN`(VN):" |
           Op_Ctx.VN_Data.Table[VN])
      end if
   end func Compute_Value_Set

   func Compute_Bottom_Up
     (Op_Ctx;
      VNs_To_Compute : VN_Set;
      var VN_Values : VN_To_Value_Set_Map_Type;
      var VSet_Was_Null : VN_Set) is
     //  Compute value sets for VNs_To_Compute if not already computed.
     //  Compute value sets for constituents first if they have not been
     //  computed.
     //  VN_Values is mapping from VNs to value sets.
     //  VSet_Was_Null is set of VNs whose value sets were computed to be null
     //  (i.e. unrestricted).
      var All_VNs_To_Compute : VN_Set := []

      if Debug_Propagation then
         Println("Compute_Bottom_Up:" |
           (for VN in VNs_To_Compute forward => <""> | " VN" | VN))
         if not Is_Empty(VSet_Was_Null) then
            Println("  VSet_Was_Null = " |
              (for VN in VSet_Was_Null forward => <""> | " VN" | VN))
         end if
      end if

      for VNs_To_Check := VNs_To_Compute - VSet_Was_Null
        while not Is_Empty(VNs_To_Check)
      loop
         var More_VNs_To_Check : VN_Set := []

         for VN in VNs_To_Check loop
            if VN not in VN_Values then
               //  This VN needs computing
               All_VNs_To_Compute |= VN

               //  Check the children
               const Children := Child_Vec(Op_Ctx.VN_Data.Table[VN]);
               if Children not null then
                  for each Child of Children loop
                     More_VNs_To_Check |= Child
                  end loop
               end if
            end if
         end loop

         continue loop with 
           VNs_To_Check => More_VNs_To_Check - VNs_To_Check
                               - VSet_Was_Null - All_VNs_To_Compute
      end loop

      if Debug_Propagation then
         Println("Compute_Bottom_Up, augmented VN set: " |
           (for VN in All_VNs_To_Compute forward => <""> | " VN" | VN))
      end if

      //  Now compute in forward order
      //  (that order is guaranteed to compute children of VN before VN)
      for VN in All_VNs_To_Compute forward loop
         const VSet := Compute_Value_Set(Op_Ctx, VN_Values, VN)
         if VSet is null then
            VSet_Was_Null |= VN
         else
            VSet_Was_Null -= VN
            VN_Values[VN] := VSet
         end if
      end loop
   end func Compute_Bottom_Up
   
   func Propagate_Bottom_Up
     (Op_Ctx;
      var VN_Values : VN_To_Value_Set_Map_Type;
      var VSet_Was_Null : VN_Set;
      VNs_To_Recompute : VN_Set) -> Boolean is
      //  Recompute values of VNs_To_Recompute, and their ancestors.
      //  Ignore VNs that are not already either in VN_Values or VSet_Was_Null.
      //  Update VN_Values with new values of VNs.
      //  Add to VSet_Was_Null for VNs computed to have a null value set.
      //  Return #false if we hit a failure during propagation.
      //  NOTE: Going "forward" here is important, as we keep adding to
      //        VNs_Not_Yet_Recomputed.
      var VNs_Not_Yet_Computed := VNs_To_Recompute

      //  NOTE 2: This is essentially identical to the expansion for:
      //            "for Ancestor_VN in VNs_Not_Yet_Computed forward loop ..."
      //          but the set is being updated during the iteration, which
      //          is not allowed with the "for ... in ... forward loop ..."
      //          construct.  We could instead build up a new set and then
      //          restart the iteration with that new set.
      //  NOTE 3: Assuming that the VNs are numbered in topological order
      //          may break down if we have VNs like CodePeer's Aliased_Kappa,
      //          where the predicate for can be filled in after the Kappa VN
      //          already exists.
      for Ancestor_VN := Remove_First(VNs_Not_Yet_Computed)
        then Remove_First(VNs_Not_Yet_Computed)
        while Ancestor_VN not null
        {Ancestor_VN in VN_Values or else Ancestor_VN in VSet_Was_Null}
      loop
         //  (Re)compute value set for this Ancestor_VN
         if Debug_Propagation then
            Println("Propagate_Bottom_Up: VN" | Ancestor_VN)
         end if
         var New_Vals for VN_Values :=
           Compute_Value_Set(Op_Ctx, VN_Values, Ancestor_VN)

         if New_Vals is null then
            //  Value set not representable
            if Ancestor_VN not in VN_Values then
               //  Keep track of VNs that produced a null value set
               VSet_Was_Null |= Ancestor_VN
            end if
            continue loop
         end if

         var Update_Vals : Boolean := #false

         var Intersection_Result : How_Reduced := #unchanged

         if Is_Empty(New_Vals) then
            // Failure
            return #false
         elsif Ancestor_VN in VN_Values then
            //  Intersect the prior values with the newly computed values
            Intersection_Result := Intersect_With_Vals
                             (VN_Values[Ancestor_VN], New_Vals,
                              Restore_If_Empty => #true)

            if Intersection_Result == #reduced_to_empty then
               //  We hit a failure; caller will report the problem.
               return #false
            end if
         else
            //  Update stored values
            Intersection_Result := #reduced
            VN_Values[Ancestor_VN] := New_Vals
         end if

         if Debug_Propagation then
            Println("  result is " | VN_Values[Ancestor_VN] |
              " (`(Intersection_Result))")
         end if

         if Intersection_Result != #unchanged then
            //  Add parents of this VN to list of VNs still to be recomputed
            VNs_Not_Yet_Computed |= Op_Ctx.VN_To_Parent_Set_Map[Ancestor_VN]

            //  We should always be going forward
            {Is_Empty(VNs_Not_Yet_Computed) or else
               First(VNs_Not_Yet_Computed) > Ancestor_VN}
         end if
      end loop

      //  No failures during bottom-up propagation
      return #true
   end func Propagate_Bottom_Up

   func Propagate_Values
     (var Op_Ctx;
      BB : CFG::Node_Id;
      var Predecessor_Changed : Node_Set;
      No_Changes_Expected : Boolean := #false) is
     //  Propagate value sets within the basic block identified by BB.
     //  If an outgoing edge of BB has a change in its vn-to-value-set map,
     //  add the successor to the Predecessor_Changed node set.
     //  Remove BB from the Predecessor_Changed set when starting.
     //  If No_Changes_Expected is #true, then no changes are expected
     //  in the outgoing edge maps, and if any are detected, debug output
     //  is produced.

      if Debug then
         Println("Propagate_Values: BB" | BB)
      end if

      Predecessor_Changed -= BB  //  Might be added back below

      const Assert_Is_True : Value_Set+ :=
        Boolean_Value_Set::(Might_Be_Null  => #false,
                            Might_Be_True  => #true,
                            Might_Be_False => #false)

      var VN_Values : VN_To_Value_Set_Map_Type
        // Value set for each VN that is restricted

      var VSet_Was_Null : VN_Set := []
        // Set of VNs whose value set has been computed, but which
        // produced a "null" (i.e. unrestriced) set.

      ref DT => Op_Ctx.CFG.Get_Dominator_Tree()

      ref BB_Node => Op_Ctx.CFG[BB]

      //  Merge information from the incoming edges
      ref In_Edges => BB_Node.Incoming_Edges

      case |In_Edges| of
         [0] =>
            // Must be the entry block.
            // Just start out at the empty set.
            VN_Values := []
         [1] =>
            // Initialize from only incoming edge
            VN_Values := Op_Ctx.Edge_Values[In_Edges[1]]
         [..] =>
            // Merge incoming edge value mappings
            VN_Values := []

            {not DT.Is_Back_Edge(In_Edges[1])}
              // First edge should not be a back edge

           *Merge_VN_Values*
            for each [V => VSet] of Op_Ctx.Edge_Values[In_Edges[1]] loop
               var Merged_VSet := VSet
               for Edge_Index in 2 .. |In_Edges| loop
                  const This_Edge := In_Edges[Edge_Index]

                  if DT.Is_Back_Edge(This_Edge) then
                     //  Ignore back edges, as they can't contribute
                     //  any new values.
                     continue loop
                  end if

                  ref This_Edge_Vals =>
                    Op_Ctx.Edge_Values[This_Edge]

                  if V not in This_Edge_Vals then
                     // VN missing from this edge, so that means no restriction
                     continue loop Merge_VN_Values
                  end if

                  //  Union in the values from this edge
                  Union_In_Vals(Merged_VSet, This_Edge_Vals[V]);

               end loop

               // Store the merged set
               VN_Values[V] := Merged_VSet
            end loop Merge_VN_Values
      end case

      if Debug_Propagation then
         Println(" Initial Value_Map for BB" | BB)
         for each [VN => VSet] of VN_Values forward loop
            Println("  VN`(VN) => " | VSet)
         end loop
      end if

      //  Propagate values

      var IO := IO::Get_IO();

      //  Walk instructions of basic block looking for assertions
      for I in BB_Node.First .. BB_Node.Last forward loop
         if I in Op_Ctx.Instr_To_Assertions_Map then
            ref Assertions => Op_Ctx.Instr_To_Assertions_Map[I]
            var Updated_VNs : VN_Set := []

            const Instr := Op_Ctx.Routine.Nth_Instr(I)

            if Debug and then |Assertions| > 0 then
               Print (" Asserting conditions for Instr#`(I): ");
               Debugging::Dump_One_Instr(IO.Stdout, Instr, 0);
            end if

            //  "and" each of the assertions into its associated
            //  value set.
            for each Asrt of Assertions forward loop
               var Val : optional Value_Set+ for VN_Values := Assert_Is_True

               if Debug_Propagation then
                  Println(" Asserting: VN`(Asrt):" |
                    Op_Ctx.VN_Data.Table[Asrt] | " is True")
               end if

               if Asrt not in VN_Values and then Asrt not in VSet_Was_Null then
                  //  Do initial computation of Asrt
                  Compute_Bottom_Up(Op_Ctx, [Asrt], VN_Values, VSet_Was_Null)
               end if

               const Bool_Vals : optional Value_Set+ :=
                 Asrt not in VN_Values? null : Boolean_Vals(VN_Values[Asrt])

               if Asrt in VN_Values then
                  Val and= Bool_Vals
                  if Is_Empty(Val) then
                     //  Empty set means that the check is certain to fail.
                     //  Report that fact.
                     if Debug then
                        Println(" Certain to fail: New value set for VN" |
                          Asrt | " is empty.")
                     end if
                     //  NOTE: A no-op if not in error-generating phase.
                     Report_Failure(Op_Ctx, I, Asrt,
                       Certain_To_Fail => #true,
                       Source_Pos => Source_Pos(Instr));

                     //  Don't update the entry in VN_Values
                     Val := null  //  Recover space -- TBD: shouldn't be needed
                     continue loop
                  end if
               end if

               if Asrt not in VN_Values
                 or else Val != Bool_Vals
               then
                  //  Value is changed, add Asrt to Updated_VNs
                  if Debug then
                     Println(" Possible failure: Expected: " |
                       To_String(Val) | ", VN`(Asrt) (" |
                       Op_Ctx.VN_Data.Table[Asrt] | ") is " |
                       (Asrt in VN_Values? To_String(VN_Values[Asrt]):
                         "completely unknown"))
                  end if
                  VN_Values[Asrt] <== Val
                  Updated_VNs |= Asrt

                  //  Report possible failure
                  //  NOTE: This is a no-op if not in error-generating phase.
                  Report_Failure(Op_Ctx, I, Asrt,
                    Certain_To_Fail => #false,
                    Source_Pos => Source_Pos(Instr));
               else
                  Val := null  //  Recover space -- TBD: shouldn't be needed
               end if

            end loop

            if not Is_Empty(Updated_VNs) then
               //  Propagate to other VNs
               //  First propagate top down (from VN to its children)
               const VNs_To_Recompute :=
                 Propagate_Top_Down
                   (Op_Ctx, BB, VN_Values, VSet_Was_Null, Updated_VNs)

               //  Then propagate bottom up (from VN to its parents)
               //  Propagate_Bottom_Up returns #false on failure
               if VNs_To_Recompute is null
                 or else not Propagate_Bottom_Up
                        (Op_Ctx, VN_Values, VSet_Was_Null, VNs_To_Recompute)
               then
                  //  Report a failure and then go to next instruction.
                  //  TBD: Picking the first of Updated_VNs is arbitrary.
                  Report_Failure(Op_Ctx, I, First(Updated_VNs),
                    Certain_To_Fail => #true,
                    Source_Pos => Source_Pos(Instr));
                  continue loop
               end if

            end if
         end if
      end loop

      //  Assert edge condition on each outgoing edge and then
      //  create a new VN-to-value-set map, and if different from
      //  prior one, add successor to Predecessor_Changed
      ref Out_Edges => BB_Node.Outgoing_Edges

      for each E of Out_Edges forward loop
         const To_Node_Id := Op_Ctx.CFG.Nth_Edge(E).To
         ref To_Node => Op_Ctx.CFG[To_Node_Id]
         const First_Instr := To_Node.First
         const Only_Incoming_Edge := |To_Node.Incoming_Edges| == 1
         var New_Edge_Values for Op_Ctx.Edge_Values := VN_Values
         var Edge_VSet_Was_Null := VSet_Was_Null

         if To_Node_Id in Op_Ctx.VN_Data.Node_Phi_Id_Maps then
            //  Target node has some Phi_VNs
            //  Find out the input VNs for each Target Phi
            var Phi_Inputs : VN_Set := []

            for each [In_Edge_Num => In_Edge_Id] of To_Node.Incoming_Edges
              {In_Edge_Id == E}
            loop
               for each Phi of Op_Ctx.VN_Data.Node_Phi_Id_Maps[To_Node_Id] loop
                  //  For each phi, add the input VN to set of Phi_Inputs
                  Phi_Inputs |= Op_Ctx.VN_Data.Phi_Id_Inputs[Phi][In_Edge_Num]
               end loop
            end loop

            //  Compute the value set for each of these phi inputs
            Compute_Bottom_Up(Op_Ctx,
              Phi_Inputs, New_Edge_Values, Edge_VSet_Was_Null)
         end if

         if E in Op_Ctx.Edge_Condition
           and then (E not in Op_Ctx.Dead_Edges or else No_Changes_Expected)
         then
            ref Cond_VN => Op_Ctx.Edge_Condition[E]
            const Cond_Is_True : Value_Set+ for New_Edge_Values :=
              Assert_Is_True

            if Debug_Propagation then
               Println("Doing outgoing edge: " | E |
                " (BB`(BB)->BB`(To_Node_Id))")
               Println(" Asserting on edge: VN" | Cond_VN | ":" |
                 Op_Ctx.VN_Data.Table[Cond_VN] | " is True")
            end if

            //  Compute the condition VN
            Compute_Bottom_Up(Op_Ctx,
              [Cond_VN], New_Edge_Values, Edge_VSet_Was_Null)

            if Cond_VN in New_Edge_Values then
               //  "And" in the new condition
               const Orig_Vals : Value_Set+ :=
                 Boolean_Vals(New_Edge_Values, Cond_VN)

               if Orig_Vals != New_Edge_Values[Cond_VN] then
                  // Prior value set was not Boolean
                  New_Edge_Values[Cond_VN] := Orig_Vals
               end if

               New_Edge_Values[Cond_VN] and= Cond_Is_True

               if Debug_Propagation
                 and then Orig_Vals != New_Edge_Values[Cond_VN]
               then
                  Println(" New value set for VN" | Cond_VN |
                          " is " | To_String(New_Edge_Values[Cond_VN]))
               end if

               //  Give a warning if this makes the edge dead
               if Is_Empty(New_Edge_Values[Cond_VN]) then
                  if E not in Op_Ctx.Dead_Edges then
                     //  Remember that edge is dead (if not already flagged)
                     Op_Ctx.Dead_Edges |= E
                     if Cond_VN not in Op_Ctx.CTK_VNs then
                        //  Put out warning unless Cond_VN is C.T.K.
                        Put_Warning("Edge `(E) is dead" |
                          (Only_Incoming_Edge? "; cannot reach here": ""),
                          Source_Pos =>
                            Op_Ctx.Routine.Nth_Instr(First_Instr).Source_Pos())
                     end if
                  end if
               end if
            else
               if Debug_Propagation then
                  Println(" New value set for VN" | Cond_VN |
                          " is " | To_String(Cond_Is_True))
               end if
               New_Edge_Values[Cond_VN] := Cond_Is_True
            end if
            if E not in Op_Ctx.Dead_Edges
              and then
                (Cond_VN not in VN_Values
                 or else New_Edge_Values[Cond_VN] != VN_Values[Cond_VN])
            then
               //  Propagate to other VNs
               const VNs_To_Recompute :=
                 Propagate_Top_Down
                   (Op_Ctx, To_Node_Id,
                    New_Edge_Values, Edge_VSet_Was_Null, [Cond_VN])

               if VNs_To_Recompute is null
                 or else
                   not Propagate_Bottom_Up
                     (Op_Ctx, New_Edge_Values, Edge_VSet_Was_Null,
                      VNs_To_Recompute)
               then
                  //  Edge is dead, detected either on top-down or bottom-up
                  //  propagation.
                  Op_Ctx.Dead_Edges |= E
                  Put_Warning("Edge `(E) is dead" |
                    (Only_Incoming_Edge? "; cannot reach here": ""),
                    Source_Pos =>
                      Op_Ctx.Routine.Nth_Instr(First_Instr).Source_Pos())
               end if
            end if
         end if

         if not Is_Equal(New_Edge_Values, Op_Ctx.Edge_Values[E]) then
            //  Edge values have changed, update saved edge values
            if Debug_Propagation or else No_Changes_Expected then
               const Msg := " New Edge_Values for outgoing edge BB" | BB |
                            "->BB" | To_Node_Id
               var Msg_Printed := Debug_Propagation
               if Debug_Propagation then
                  Println(Msg)
               end if
               for each [VN => VSet] of New_Edge_Values forward loop
                  if Debug_Propagation
                    or else VN not in Op_Ctx.Edge_Values[E]
                    or else VSet != Op_Ctx.Edge_Values[E][VN]
                  then
                     if not Msg_Printed then
                        Println(Msg)
                        Msg_Printed := #true
                     end if

                     Println("  VN`(VN) => " | VSet)
                  end if
               end loop
               Msg_Printed := #false
               for each [VN => VSet] of Op_Ctx.Edge_Values[E]
                 {VN not in New_Edge_Values}
               loop
                  if not Msg_Printed then
                     Msg_Printed := #true
                     Println(" Lost Edge_Values for outgoing edge BB" | BB |
                         "->BB" | To_Node_Id)
                  end if
                  Println("  VN`(VN) => " | VSet)
               end loop
            end if
            Op_Ctx.Edge_Values[E] <== New_Edge_Values
            //  Remember that predecessor changed
            Predecessor_Changed |= To_Node_Id

         else
            //  Recover space (TBD: Should not be necessary)
            New_Edge_Values := null
         end if
      end loop
      
   end func Propagate_Values

   func Compute_Live_Ranges_For_Addr_Content_Pairs(var Op_Ctx) is
      //  Initialize Addr_VNs_Live_Ranges by walking the
      //  Instr_To_Addr_Fetch_VNs[I] and Instr_To_Addr_Store_VNs[I]
      //  information.
      const Debug_Liveness : Boolean := #false

      var Live_In_Set : Map<CFG::Node_Id, Addr_VN_To_VN_Ref> := []
        //  Set of addrs with a "live" value at start of block,
        //  with the last instruction where the value is fetched.

      var Last_Kill_In_Block : Map<CFG::Node_Id, Addr_VN_To_VN_Ref> := []
        //  Last "def" of an address in given block

      Op_Ctx.Addr_VN_Live_Ranges := []

      //  Initialize Live_In_Set and Last_Kill_In_Block by walking
      //  Instr_To_Addr_Fetch_VNs[I] and Instr_To_Addr_Store_VNs[I]

      //  Walk all basic blocks
      for BB_Id in CFG::First_Node_Id .. Op_Ctx.CFG.Last_Node_Id() loop
         ref BB => Op_Ctx.CFG[BB_Id]

         Live_In_Set[BB_Id] := []
         Last_Kill_In_Block[BB_Id] := []
         ref Live_In => Live_In_Set[BB_Id]
         ref Last_Kill => Last_Kill_In_Block[BB_Id]

         //   Pretend there is a "store" into each phi VN at start of BB
         if BB_Id in Op_Ctx.VN_Data.Node_Phi_Id_Maps then
            ref Phi_VNs  => Op_Ctx.VN_Data.Node_Phi_Id_Maps[BB_Id]

            for each Phi_Val of Phi_VNs loop
               case Op_Ctx.VN_Data.Table[Phi_Val] of
                [Phi : Phi_VN] =>
                  {Phi.Phi_Block == BB_Id}  //  Should be for this BB

                  var Loc := Phi.Phi_Addr

                  if Loc is null then
                     //  Look at OID for Phi_Addr
                     case Op_Ctx.OI_Data.Table[Phi.Phi_OID] of
                        [Phi_OID : Phi_Origin] =>
                           {Phi_OID.Phi_Block == BB_Id}
                                               // Hopefully is for this BB

                           Loc := Phi_OID.Phi_Addr
                           
                        [..] =>
                           //  TBD: For now we ignore if not based on a Phi_OID
                           {#false}
                     end case
                  end if

                  if Loc not null then
                     //  Pretend we have a store
                     Last_Kill[Loc] := (Phi_Val, Place => BB.First-1)
                  end if

                [..] =>
                  //  Should only contain Phi VNs
                  {#false}
               end case
            end loop

         end if

         //  Iterate over instructions of basic block
         for I in BB.First .. BB.Last forward loop
            ref Fetch_VNs => Op_Ctx.Instr_To_Addr_Fetch_VNs[I]
            ref Store_VNs => Op_Ctx.Instr_To_Addr_Store_VNs[I]

            //  Scan the fetches to look for live-in's and/or initialize
            //  live range for addr-VN/content-VN pair.
            for each [Loc => VN] of Fetch_VNs loop
               if Loc in Last_Kill then
                  //  Init/Update live range associated with addr-VN/content-VN
                  {VN == Last_Kill[Loc].VN}
                  if Loc not in Op_Ctx.Addr_VN_Live_Ranges then
                     Op_Ctx.Addr_VN_Live_Ranges[Loc] := []
                  end if
                  Op_Ctx.Addr_VN_Live_Ranges[Loc][VN] :=
                    Last_Kill[Loc].Place <.. I  //  TBD: Should be an "or"?
               else
                  //  Remember instruction where live-in fetch occurs
                  Live_In[Loc] := (VN, Place => I)
               end if
            end loop

            //  Update Last_Kill_In_BLock
            for each [Loc => VN] of Store_VNs loop
               Last_Kill[Loc] := (VN, Place => I)
            end loop
         end loop

         //  Pretend there is a "fetch" at end of BB for each phi input
         //  NOTE: We need to apply "Aggr_Base" to value so it corresponds
         //        to values used in Addr_Fetch_VNs and Addr_Store_VNs.
         for each [Out_Edge_Num => Out_Edge] of BB.Outgoing_Edges
           {Op_Ctx.CFG.Nth_Edge(Out_Edge).To in
                                        Op_Ctx.VN_Data.Node_Phi_Id_Maps}
         loop
            const Succ := Op_Ctx.CFG.Nth_Edge(Out_Edge).To
            ref Succ_BB => Op_Ctx.CFG[Succ]
            {|Succ_BB.Incoming_Edges| > 1}  // successor must be a join point
            ref Phi_VNs  => Op_Ctx.VN_Data.Node_Phi_Id_Maps[Succ]

            for each [In_Edge_Num => In_Edge] of Succ_BB.Incoming_Edges
              {In_Edge == Out_Edge}  //  Find matching incoming edge
            loop
               for each Phi_Val of Phi_VNs loop
                  case Op_Ctx.VN_Data.Table[Phi_Val] of
                   [Phi : Phi_VN] =>
                     {Phi.Phi_Block == Succ}  //  Should be for this successor

                     var Loc := Phi.Phi_Addr

                     if Loc is null then
                        //  Look at OID to get Addr
                        case Op_Ctx.OI_Data.Table[Phi.Phi_OID] of
                           [Phi_OID : Phi_Origin] =>
                              {Phi_OID.Phi_Block == Succ}
                                         // Hopefully is for this successor

                              Loc := Phi_OID.Phi_Addr // Get Addr_VN for Phi

                           [..] =>
                              //  TBD: For now ignore if not based on a Phi_OID
                              {#false}
                        end case
                     end if

                     if Loc not null then
                        const Phi_Input := Op_Ctx.Aggr_Base
                          (Op_Ctx.VN_Data.Phi_Id_Inputs
                             [Phi_Val][In_Edge_Num])
                           //  NOTE: We apply Aggr_Base so consistent
                           //        with Addr_Fetch_VNs and Addr_Store_VNs.

                        if Loc in Last_Kill then
                           //  Init/Update live range associated
                           //  with addr-VN/content-VN
                           if Phi_Input != Last_Kill[Loc].VN then
                              Println("** In " |
                                Op_Ctx.Routine.Name() | " BB" | BB_Id |
                                " successor BB`(Succ), Phi VN" |
                                Phi_Val | " input VN" | Phi_Input |
                                " != Last_Kill[VN`(Loc)].VN (VN" |
                                Last_Kill[Loc].VN | ")")
                           end if
                           {Phi_Input == Last_Kill[Loc].VN}
                           if Loc not in
                             Op_Ctx.Addr_VN_Live_Ranges
                           then
                              Op_Ctx.Addr_VN_Live_Ranges[Loc] := []
                           end if
                           Op_Ctx.Addr_VN_Live_Ranges[Loc][Phi_Input] :=
                             Last_Kill[Loc].Place <.. BB.Last
                               //  TBD: Should be an "or"?
                        else
                           //  Remember instruction where live-in
                           //  fetch occurs
                           Live_In[Loc] := (Phi_Input, Place => BB.Last)
                        end if
                     end if

                   [..] =>
                     //  Should only contain Phi VNs
                     {#false}
                  end case
               end loop
            end loop
         end loop
         
      end loop

      ref DT => Op_Ctx.CFG.Get_Dominator_Tree()

      //  Iterate over the CFG until Live_In_Set stabilizes
      for To_Be_Processed : Node_Set :=
          CFG::First_Node_Id .. Op_Ctx.CFG.Last_Node_Id()
        while not Is_Empty(To_Be_Processed)
      loop
         var Successor_Changed : Node_Set := []
         //  Set of nodes whose successors have changed

         //  Walk nodes in postorder, since this should reduce num iterations
         //  Only process those with a changed successor.
         for N => DT.Postorder() then N.Next while N not null
           {N.Id in To_Be_Processed or else N.Id in Successor_Changed}
         loop
            var Live_Out_Set : Map<Addr_VN_Id, VN_Id> := []
            var Live_In_Changed : Boolean := #false
            ref Last_Kill => Last_Kill_In_Block[N.Id]
            ref Live_In => Live_In_Set[N.Id]
            ref BB => Op_Ctx.CFG[N.Id]

            if Debug_Liveness then
               Println(" Global Liveness for BB" | N.Id)
            end if

            Successor_Changed -= N.Id
            //  Compute Live_Out_Set from Live_In_Sets of successors
            for each Succ of Op_Ctx.CFG.Successors(N.Id) loop
               for each [Loc => Init_Place] of Live_In_Set[Succ] loop
                  if Debug_Liveness then
                     Println("  [VN`(Loc) => (VN`(Init_Place.VN), " |
                       Init_Place.Place | ")] for succ BB" | Succ)
                  end if
                  if Loc in Live_Out_Set then
                     if Live_Out_Set[Loc] != Init_Place.VN then
                        Println(" Expected Live_Out_Set[`(Loc)] == VN" |
                          Init_Place.VN | ", Actually == VN" |
                          Live_Out_Set[Loc])
                     end if
                     {Live_Out_Set[Loc] == Init_Place.VN}
                  else
                     Live_Out_Set[Loc] := Init_Place.VN
                  end if
               end loop
            end loop

            if Debug_Liveness then
               Println("  Live_Out_Set =" |
                 (for each [Loc => VN] of Live_Out_Set =>
                   <""> | " [VN`(Loc)=>VN`(VN)]"))
            end if

            //  See whether Live_Out_Set flows through to Live_In_Set
            for each [Loc => VN] of Live_Out_Set loop
               const Is_Component : Boolean :=
                                     (case Op_Ctx.VN_Data.Table[Loc] of
                                       [Comp : Component_Addr_VN] => #true;
                                       [..] => #false)

               if Loc in Last_Kill then
                  //  Fill in live ranges for last-kill of block
                  if VN != Last_Kill[Loc].VN then
                     //  Mismatch; not surprising if Loc is a component addr
                     if Is_Component then
                        if Debug_Liveness then
                           Println(" Component Addr VN" | Loc |
                             " with value VN" | VN |
                             " has different value in predecessor (VN" |
                             Last_Kill[Loc].VN | ")")
                        end if
                     else
                        Println(" Expecting Last_Kill[" | Loc |
                          "].VN == VN" | VN)
                        Println("** Live_Out_Set contains " |
                          "[VN`(Loc) => VN`(VN)], Last_Kill[VN`(Loc)].VN" |
                          " == VN`(Last_Kill[Loc].VN), BB`(N.Id)" |
                          "(`(BB.First)..`(BB.Last))")
                        {VN == Last_Kill[Loc].VN}
                     end if
                  else
                     //  Matches Last_Kill -- update its live range
                     if Loc not in Op_Ctx.Addr_VN_Live_Ranges then
                        Op_Ctx.Addr_VN_Live_Ranges[Loc] := []
                     end if
                     Op_Ctx.Addr_VN_Live_Ranges[Loc][VN] :=
                       Last_Kill[Loc].Place <.. BB.Last
                                          //  TBD: should be an "or"?
                  end if
               elsif Loc not in Live_In
                 or else Live_In[Loc].Place < BB.Last
               then
                  //  Live-out flows through to live-in
                  if Loc in Live_In then
                     if Live_In[Loc].VN != VN then
                        if Is_Component then
                           if Debug_Liveness then
                              Println(" Component Addr VN" | Loc |
                                " with value VN" | VN |
                                " has different value in pred's live-in (VN" |
                                Live_In[Loc].VN | ")")
                           end if
                        else
                           Println("Expected Live_In[`(Loc)].VN == VN" |
                             VN | ", Actually = VN" | Live_In[Loc].VN)
                           {Live_In[Loc].VN == VN}
                        end if
                     else
                        Live_In[Loc] := (VN, Place => BB.Last)
                        Live_In_Changed := #true
                     end if
                  elsif not Is_Component then
                     Live_In[Loc] := (VN, Place => BB.Last)
                     Live_In_Changed := #true
                  end if

               else
                  //  Live-in info should already match
                  {Live_In[Loc].VN == VN or else Is_Component;
                   Live_In[Loc].Place == BB.Last}
               end if
            end loop

            if Live_In_Changed then
               //  Indicate that all predecessors of this block
               //  need to be reprocessed.
               for each Pred of Op_Ctx.CFG.Predecessors(N.Id) loop
                  Successor_Changed |= Pred
               end loop
            end if
         end loop

         continue loop with Successor_Changed
      end loop

      //  Finish initializing Addr_VN_Live_Ranges by including
      //  ranges from Live_In_Sets
      for BB_Id in CFG::First_Node_Id .. Op_Ctx.CFG.Last_Node_Id() loop
         ref BB => Op_Ctx.CFG[BB_Id]

         for each [Loc => Init_Place] of Live_In_Set[BB_Id] loop
            //  "Or" this Init_Place into Addr_VN_Live_Ranges for this
            //  Addr-VN
            const VN := Init_Place.VN

            if Loc not in Op_Ctx.Addr_VN_Live_Ranges then
               Op_Ctx.Addr_VN_Live_Ranges[Loc] := []
            end if
            if VN not in Op_Ctx.Addr_VN_Live_Ranges[Loc] then
               Op_Ctx.Addr_VN_Live_Ranges[Loc][VN] := []
            end if
            Op_Ctx.Addr_VN_Live_Ranges[Loc][VN] |=
              BB.First .. Init_Place.Place
         end loop
      end loop
      
   end func Compute_Live_Ranges_For_Addr_Content_Pairs

 exports

   func Addr_VN_For_Locator(var Op_Ctx; Locator : Object_Locator;
     I : Code_Index) -> optional Addr_VN_Id is
      //  Return an addr value number for given object locator, if pre-computed

      if I in Op_Ctx.Instr_To_Locator_Map
        and then Locator in Op_Ctx.Instr_To_Locator_Map[I]
      then
         return Op_Ctx.Instr_To_Locator_Map[I][Locator];
      else
         //  Wasn't precomputed
         return null;
      end if
   end func Addr_VN_For_Locator

   func Analyze_Operation (Item : Reflection::Decl;
                           var Op_Ctx : PSC::Analysis::Op_Ctx) is
      //  Analyze one operation, given an operation context

      const Routine := Op_Ctx.Routine

      const Instr_Indices : Countable_Range<Code_Index> :=
        1 .. Routine.Num_Instrs()  //  Range of indices for current operation

      // Compute name
      const Module_Name := Reflection::Routine::Module_Name(Routine);
      var Op_Name := Id(Item);

      var Full_Name := Op_Name;
      if Module_Name not null and then Module_Name != "" then
         Full_Name := Module_Name | "::" | Op_Name;
      end if

      //  For overloading
      const Homonyms := Num_Prior_Homonyms(Item);
      if Homonyms > 0 then
         Full_Name |= "#" | (Homonyms+1)
      end if

      //  First instruction starts a node
      Op_Ctx.Node_Starts |= Instr_Indices.First

      //  Analyze intructions in this routine, first pass (find basic blocks)
      Op_Ctx.Pass := #find_basic_blocks

      for I in Instr_Indices forward loop
         Analyze_One_Instr(Op_Ctx, Routine, I);
      end loop

      //  Last exit/return of operation/nested block becomes an exit node
      Op_Ctx.Node_Starts |= Op_Ctx.Last_End_Instr
      Op_Ctx.CFG_Ends |= Op_Ctx.Last_End_Instr

      //  Build up CFG
      Op_Ctx.Pass := #build_cfg

      Op_Ctx.Cur_Entry_Node := null
      for I in Op_Ctx.Node_Starts forward loop
         //  Create node and fill in "First" instr and add to instr->node map
         const New_Node_Id := Op_Ctx.CFG.Add_Node()
         Op_Ctx.CFG[New_Node_Id].First := I
         Op_Ctx.Instr_To_Node_Map |= [I => New_Node_Id]

         if Op_Ctx.Cur_Entry_Node is null then
            //  This is an entry node
            Op_Ctx.Cur_Entry_Node := New_Node_Id
            Op_Ctx.CFG_Entry_Nodes |= New_Node_Id
         end if

         if I in Op_Ctx.CFG_Ends then
            //  This is an exit node
            Op_Ctx.CFG_Exit_Nodes |= New_Node_Id
            Op_Ctx.Entry_Node_To_Exit_Node_Map |=
              [Op_Ctx.Cur_Entry_Node => New_Node_Id]
            Op_Ctx.Cur_Entry_Node := null
         end if
      end loop

      //  Each CFG should have reached an exit node,
      //  so Cur_Entry_Node should now be null.
      {Op_Ctx.Cur_Entry_Node is null}

      //  Analyze intructions in this routine, second pass (build cfg)
      for I in Instr_Indices forward loop
         Analyze_One_Instr(Op_Ctx, Routine, I);
      end loop

      {|Op_Ctx.CFG| > 0}

      var Num_Disconnected_Nodes := 0

      for N in Op_Ctx.CFG.All_Nodes() loop
         ref N_Node => Op_Ctx.CFG[N]
         if |N_Node.Incoming_Edges| == 0
           and then N != CFG::First_Node_Id
           and then N not in Op_Ctx.CFG.Roots()
         then
            Println("NOTE: Will ignore node `(N) " |
              "(instrs `(N_Node.First)-`(N_Node.Last))" |
              " because it has no incoming edges")
            Num_Disconnected_Nodes += 1
         end if
      end loop

      if Debug then
         const RPO_Order := Reverse_Postorder(Op_Ctx.CFG)
         Print("Full Reverse Post-order of CFG:")
         for N => RPO_Order then N.Next while N not null loop
            Print(" " | N.Id)
         end loop
         Print('\n')
         if Num_Disconnected_Nodes > 0 then
            const Connected_RPO_Order :=
              Reverse_Postorder(Op_Ctx.CFG, Connected_Nodes_Only => #true)
            Print("Reverse Post-order of connected nodes of CFG:")
            for N => RPO_Order then N.Next while N not null loop
               Print(" " | N.Id)
            end loop
            Print('\n')
         end if
      end if

      Compute_Dominator_Tree(Op_Ctx.CFG)

      ref DT => Get_Dominator_Tree(Op_Ctx.CFG)

      var IO := IO::Get_IO()

      if Dump_CFG then
         //  Display control flow graph and dominator info
         const Graph_File_Name :=
           "cfg_`(Full_Name.Replace("::", With => ".")).gv"
         Println("Dumping graph `(Graph_File_Name) for " | Full_Name)
         var File : File_Output_Stream := IO.Create(Graph_File_Name)
         var Edge_Attrib_Map : Map<CFG::Edge_Id, Univ_String> := []
         //  Use "dashed" "forestgreen" lines for invocations of nested blocks
         //  Use "dotted" "red" lines for exit from nested blocks
         for E in Op_Ctx.CFG.All_Edges() loop
            ref Edge => Op_Ctx.CFG.Nth_Edge(E)
            if Edge.To in Op_Ctx.CFG_Entry_Nodes then
               Edge_Attrib_Map |= [E => "style=dashed,color=forestgreen"]
            end if
            if Edge.From in Op_Ctx.CFG_Exit_Nodes then
               Edge_Attrib_Map |= [E => "style=dotted,color=red"]
            end if
         end loop

         var Node_Attrib_Map : Map<CFG::Node_Id, Univ_String> := []
         //  Make headers of nested blocks "plum" color
         for N in Op_Ctx.CFG_Entry_Nodes loop
            if |Op_Ctx.CFG[N].Incoming_Edges| > 0 then
               //  An entry node that is not *the* entry node
               Node_Attrib_Map |= [N => "style=filled,fillcolor=plum"]
            end if
         end loop

         //  Dump the CFG with dominator tree and dominance frontier
         File.Dump_Graph(Op_Ctx.CFG, Routine, Full_Name,
           Node_Attrib_Map, Edge_Attrib_Map, DT => DT)
         File.Close()
      end if

      //  Value number the subprogram:
      //  For each distinct address value-number, we might have a distinct
      //  value in a given basic block.
      //  We need to know whether two objects with different address
      //  value-numbers might be aliased.  This is equivalent to asking
      //  whether their address value-numbers might be equal at run-time.
      //  This will generally come down to equality checks between indices.
      //  Note that operations that return "ref"s are the way that address
      //  value numbers are produced.
      //  
      //  Rather than creating "phi"s it would be nice to create phi-as-kappas
      //  directly.  This means having path conditions for each incoming
      //  edge of a join point, relative to the dominator of the join point.
      //  This implies maintaining in every basic block the path condition,
      //  organized by dominator.
      //
      //  Most value numbers will represent the result of a call.
      //  Class aggregates are one exception to this; these are best modeled
      //  as a series of assignments to selected components.
      //  If a call has exactly one output, or no outputs and one "var" param,
      //  then it makes sense to represent it directly by the call info.
      //  If it has multiple outputs, then it is probably worth creating
      //  a node that represents the set of outputs, and then selectors
      //  from that set on top.
      //  Selection is another exception to this; selection produces an
      //  address value number, then the "fetch" produces a derived value
      //  if the enclosing object has a new value number.

      Op_Ctx.VN_Data.Table := []
      const Null_Lit := Null_Literal_VN::(Origin => null)
      Op_Ctx.Null_VN := Op_Ctx.VN_Data.Table.Get_Unique_Id(Null_Lit)

      func Init_Input_VNs() is
      //  Initialize the Input_VNs:
      //    NOTE: Nested blocks will be walked as part of enclosing routine.
      //    For each Input parameter, create an Input_VN for its value.
      //    Enter this Input_VN into the mapping from Addr_VN to value.

         for each [P => Info] of Parameters(Routine) forward loop
            // Create an Input_VN if an input or an inited output
            const Source_Pos := Source_Pos (Op_Ctx.Routine.Nth_Instr(1));
            var Input_Addr := Op_Ctx.VN_Data.Table.Get_Unique_Id
               (Param_Addr_VN::
                  (Level => Level_Of_BB(Op_Ctx, DT.Primary_Root()),
                   BB_Id => Entry_Node_For_BB(Op_Ctx, DT.Primary_Root()),
                   Offset => P-1))
            if Info.Is_Passed_By_Ref then
               // Level of indirection

               if Info.Is_Operation_Output then
                  //  By-ref outputs are not initialized to null
                  continue loop
               end if

               const Deref_Of_Param := Op_Ctx.VN_Data.Table.Get_Unique_Id
                  (Input_VN::(Type_Info => null,
                              Might_Be_Null => #false,
                              Input_Addr => Input_Addr))

               Store_Value(Op_Ctx, Input_Addr, New_Val => Deref_Of_Param,
                 Source_Pos => Source_Pos,
                 Origin => Input_Origin::(Input_Addr => Input_Addr))

               // Now use Deref_Of_Param as address
               Input_Addr := Deref_Of_Param
            end if

            if Info.Is_Operation_Output
              and then
                not Info.Is_Optional
              and then
                Info.Type_Info.Base() == Zero_Base
              and then
                Type_Desc_At_Locator(Info.Type_Info).Is_Small()
            then
               //  This output is not necessarily initialized to null
               continue loop
            end if

            const Input_Value := Op_Ctx.VN_Data.Table.Get_Unique_Id
               (Input_VN::(Type_Info => Info.Type_Info,
                           Might_Be_Null =>
                             Info.Is_Optional or Info.Is_Operation_Output,
                           Input_Addr => Input_Addr))
            if Input_Addr in Op_Ctx.Deref_Non_Null then
               //  Deref of Input_Addr is address of non-null object
               Op_Ctx.Non_Null_Inputs |= Input_Value
               if Debug_Value_Numbering then
                  Println(" deref-non-null true for VN" | Input_Addr |
                    " implies VN`(Input_Value) non null")
               end if
            end if

            Store_Value(Op_Ctx, Input_Addr, New_Val => Input_Value,
              Source_Pos => Source_Pos,
              Origin => Input_Origin::(Input_Addr => Input_Addr))

            if not Info.Is_Optional and not Info.Is_Operation_Output then
               //  Remember that contents of Input_Addr cannot be null
               Op_Ctx.Non_Null_Inputs |= Input_Addr
            end if
         end loop
      end func Init_Input_VNs

      loop
         //  Keep repeating value numbering until things stabilize
         Op_Ctx.Rerun_Value_Numbering := #false

         if Debug or Debug_Phis then
            //  Announce that we are (re)starting value numbering.
            Println("Before (re)value numbering " | Full_Name)
         end if

         Op_Ctx.Addr_To_OID_Map := []
         Op_Ctx.OID_To_VN_Map := []
         Op_Ctx.Non_Null_Inputs := []  //  TBD: Do at each out-of-line root?
         Op_Ctx.Deref_Non_Null := []  //  TBD: Should be saved/re-established
                                      //       for each OOL root?

         //  Re-initialize the assertions map
         Op_Ctx.Instr_To_Assertions_Map := []

         //  Analyze intructions in this routine, third pass (value number).
         //  Walk basic blocks in reverse postorder, so blocks will follow
         //  their non-back-edge predecessors.
         Op_Ctx.Pass := #value_number

         for N => DT.Reverse_Postorder() then N.Next while N not null loop
            ref BB => Op_Ctx.CFG[N.Id]

            if N.Id == DT.Primary_Root() then
               //  Doing the primary root of the CFG.
               //  Init the input VNs for the routine as a whole.
               Init_Input_VNs()
            end if

            for I in BB.First .. BB.Last forward loop
               Analyze_One_Instr(Op_Ctx, Routine, I);
            end loop
         end loop

         if not Op_Ctx.Rerun_Value_Numbering then
            //  All done
            exit loop
         end if

         if Debug or Debug_Phis then
            Println("Rerunning Value Numbering, total # of OIDs now " |
              |Op_Ctx.OI_Data.Table| | " and # of VNs now " |
              |Op_Ctx.VN_Data.Table|);
         end if
      end loop

      //  Initialize Addr_VN_Live_Ranges by walking the
      //  Instr_To_Addr_Fetch_VNs[I] and Instr_To_Addr_Store_VNs[I]
      //  information.
      Compute_Live_Ranges_For_Addr_Content_Pairs(Op_Ctx);
     
      //  Determine which VNs are compile-time-known.
      //  NOTE: We are taking advantage of the fact that the children
      //        of a VN have lower numbers than the VN, so a "forward" loop
      //        here does things in the right order.
      for each [Id => VN] of Op_Ctx.VN_Data.Table forward loop
         // Check if can be compile-time known
         case VN of
            [Param : Param_Addr_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Input : Input_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Local : Local_Addr_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Component : Component_Addr_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Unknown : Unknown_VN] =>
               //  Cannot be compile-time known
               continue loop
            [Phi : Phi_VN] =>
               //  Cannot be compile-time known
               //  TBD: This might change some day
               continue loop
            [..] =>
               null
         end case

         const Children := Child_Vec(VN)
         if Is_Literal_VN(Op_Ctx.VN_Data.Table, Id)
           or else Children is null
           or else (for all C of Children => C in Op_Ctx.CTK_VNs)
         then
            
            Op_Ctx.CTK_VNs |= Id
         end if
      end loop

      if Debug then
         //  Dump the address-to-oid-to-value maps
         Println("After value numbering " | Full_Name)
         Dump_Addr_OID_Value_Maps(Op_Ctx)
      end if

      if Debug then
         //  Indicate which instructions have assertions to be proved
         var Max_VN : optional VN_Id := null

         Println("Assertions associated with instructions:")
         for each [I => Assertions_Set] of Op_Ctx.Instr_To_Assertions_Map
           forward loop
            Debugging::Dump_One_Instr
              (IO.Stdout, Routine.Nth_Instr(I), Indent => 1)
            for each Assert of Assertions_Set forward loop
               //  Remember max VN seen in an assertion
               Println("  Assert: VN" | Assert)
               Max_VN := Max(Max_VN, Assert)
            end loop
         end loop
         Println("Conditions associated with edges:")
         for each [E => V] of Op_Ctx.Edge_Condition forward loop
            Println(" Edge: `(E) => VN" | V)
            Max_VN := Max(Max_VN, V)
         end loop
         Dump_VNT(Op_Ctx, Max_VN)
      end if

      //  Now begin value-set propagation to produce a map
      //  of value-number to value-set for each edge in the graph.
      //  Then we will produce warnings for any checks that are not
      //  certain to pass given the saved value-set maps for the edges.

      //  Initialize mapping of VNs to Value-sets for each edge
      Op_Ctx.Edge_Values := Create(Op_Ctx.CFG.All_Edges(), [])

      //  Initialize mapping of VNs to the set of their immediate parent VNs
      Op_Ctx.VN_To_Parent_Set_Map := Create(Op_Ctx.VN_Data.Table.All_Ids(), [])
      for each [Id => VN] of Op_Ctx.VN_Data.Table loop
         //  Add Id to parent set of each child of VN
         const Children := VN.Child_Vec()

         if Children not null then
            for each C of Children {C not null} loop
               Op_Ctx.VN_To_Parent_Set_Map[C] |= Id
            end loop
         end if
      end loop

      //  Indicate we are in the middle of value propagation
      Op_Ctx.Propagating_Values := #true

      //  Initialize indicator of whether errors are found
      Op_Ctx.Error_Found_During_Propagation := #false

      //  Iterate over basic blocks, in each iteration we walk in reverse
      //  post-order those blocks with changed predecessors.
      for To_Be_Processed : Node_Set :=
          CFG::First_Node_Id .. Op_Ctx.CFG.Last_Node_Id()
        while not Is_Empty(To_Be_Processed)
      loop
         var Predecessor_Changed : Node_Set := []
         //  Set of nodes whose predecessors have changed

         //  Walk nodes in reverse postorder, propagating value sets.
         //  Only process those with a changed predecessor.
         for N => DT.Reverse_Postorder() then N.Next while N not null loop
            if N.Id in To_Be_Processed or else N.Id in Predecessor_Changed then
               Propagate_Values(Op_Ctx, N.Id, Predecessor_Changed)
            end if
         end loop

         continue loop with Predecessor_Changed
      end loop

      //  Done with value propagation
      Op_Ctx.Propagating_Values := #false

      //  Now check to see if any errors were found during propagation
      if Op_Ctx.Error_Found_During_Propagation then
         //  Reset indicator
         Op_Ctx.Error_Found_During_Propagation := #false

         //  Now make one more pass, and this time actually display the
         //  error messages.

         var Predecessor_Changed : Node_Set := []
         //  Set of nodes whose predecessors have changed

         //  Walk nodes in reverse postorder, propagating value sets,
         //  producing error messages this time.
         for N => DT.Reverse_Postorder() then N.Next while N not null loop
            Propagate_Values(Op_Ctx, N.Id, Predecessor_Changed,
                             No_Changes_Expected => #true)
         end loop

         if not Is_Empty(Predecessor_Changed) then
            Put_Warning("Value propagation not stable after final pass on: " |
              Op_Ctx.Routine.Name_With_Overloading_Index() |
              ", inputs changed for BBs:" |
              (for N in Predecessor_Changed forward => <""> | " " | N))
         end if

      end if

   end func Analyze_Operation
end class PSC::Analysis::ParaScope

func Analyze(Files : Basic_Array<Univ_String>) is
   var Sequential : Boolean := #false;
   var IO := IO::Get_IO()

   if PSC::Analysis::Msg_File_Name not null then
      //  Initialize the message file
      var Msg_File :=
        File_Output_Stream::Create(IO, PSC::Analysis::Msg_File_Name)
      if Msg_File is null then
         IO.Stderr.Println("Cannot create message file \"" |
           PSC::Analysis::Msg_File_Name | '"')
      else
         Msg_File.Close()
      end if
   end if

   for each F of Files loop
      if F[1] == '-' then
         if F == "--forward" then
            Sequential := #true
         else
            IO.Stderr.Println(F | ": unrecognized switch");
            return;
         end if;
      end if;
   end loop

   if Sequential then
      //  Process files in sequence
      for each F of Files forward loop
         if F[1] == '-' then
            continue loop;
         end if

         //if Analysis::Debug then
         Println("Analyzing " | F);
         //end if
         PSC::Analysis::Analyze(F)
         Println("Done with " | F);
      end loop
   else
      //  Process files concurrently
      for each F of Files concurrent loop
         if F[1] == '-' then
            continue loop;
         end if

         //if Analysis::Debug then
         Println("Analyzing " | F);
         //end if
         PSC::Analysis::Analyze(F)
         Println("Done with " | F);
      end loop
   end if;
end func Analyze
