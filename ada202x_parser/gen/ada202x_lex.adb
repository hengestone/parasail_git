
package body Ada202x_lex is

  --  Indicates whether outdenting should expect a perfect col-count match
  Col_Match_Expected : Boolean := True;

  Max_Depth : constant := 100;
  Indent_Stack : array(Positive range 1 .. Max_Depth) of Natural :=
    (others => 0);
  Bracketing_Token_Stack : array(Positive range 1 .. Max_Depth) of Token :=
    (others => Error);

  procedure ECHO_L(YYT : String := yytext) is
  --
  -- Local version of the  define string.
  -- 
  begin
     Echo_Token (YYT);
     --  We normally expect an exact match
     Col_Match_Expected := True;
  end ECHO_L;

  function Create_Token(Text : String := yytext) return YYSType is
     Src_Pos : Source_Position := Cur_Source_Pos;
  begin
     --  Point to beginning of token
     Src_Pos.Col := Column_Number'Max (1, Src_Pos.Col - Text'Length + 1);
     --  TBD: "gcc" prefers column count rather than character count

     if Debug_Indent and then Expecting_Indent then
        Text_IO.Put (" [CT: indent off] ");
     end if;
     Expecting_Indent := False;

     --  Create a token for the parser.
     return (One_Token, Src_Pos, String_Lookup(Text));
  end Create_Token;
     
function YYLex return Token is
subtype short is integer range -32768..32767;
    yy_act : integer;
    yy_c : short;

-- returned upon end-of-file
YY_END_TOK : constant integer := 0;
YY_END_OF_BUFFER : constant := 185;
subtype yy_state_type is integer;
yy_current_state : yy_state_type;
INITIAL : constant := 0;
TICK : constant := 1;
CHARLIT : constant := 2;
AFTER_IMPLEMENTS : constant := 3;
OUTDENTING : constant := 4;
RESCANNING : constant := 5;
yy_accept : constant array(0..703) of short :=
    (   0,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
        0,    0,  185,  183,  173,  182,  183,  183,  183,  159,
      139,  140,  149,  150,  151,  152,  153,  154,  164,  164,
      156,  157,  143,  161,  144,  160,  162,  141,  142,  162,
      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
      145,  158,  147,    6,  162,  162,  162,  162,  162,  162,
      162,  162,  162,  162,  162,  162,  158,  138,  183,    6,
      179,  184,  179,  179,  179,  179,  179,  184,  184,  184,
      184,  184,  184,  184,  184,  184,  184,  184,  184,  184,

      173,  182,    0,  107,    0,  171,  171,    0,  163,  130,
      111,  126,  137,  124,  172,  125,  120,  137,  115,  127,
        0,    0,  164,    0,    0,    0,    0,    0,  155,  137,
        0,  112,    0,  110,  109,    0,  148,  106,  119,  105,
      108,    0,  162,  162,  162,  162,  162,  162,  162,  162,
      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
      162,  162,  162,   58,  162,   61,   63,  162,  162,  162,
      162,  162,  162,  162,   73,   74,   77,  162,  162,  162,
      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
      162,  162,  162,  162,  146,  129,  123,    6,    0,    0,

        0,    0,    0,    0,  162,  162,  162,  162,  162,  162,
      162,  162,   61,  162,    6,  162,  162,  162,  162,  162,
      123,    0,    0,    6,    0,  178,    0,    0,    0,  177,
        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
       22,    0,    0,    0,    0,    0,  122,  163,  128,  172,
      118,    0,  165,  169,    0,  164,  168,    0,  117,  135,
      113,  114,  131,  121,  136,   23,   25,   26,  162,  162,
      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
      162,   47,  162,  162,  162,   52,  162,  162,  162,  162,
      162,  162,  162,  162,  162,   68,   70,   71,  162,   75,

      133,  162,  162,  162,  162,  162,  162,  162,  162,   88,
       89,  162,  162,  162,  162,  162,  162,  162,  162,   99,
      100,  162,  162,  162,  104,    4,    0,    0,    0,    0,
        0,   23,  162,  162,    6,  162,  162,  162,  162,  162,
       70,  162,  162,  162,    6,  162,    3,  170,    0,    0,
        0,    0,    0,    0,    0,   12,    0,    0,    0,    0,
        0,   69,    0,    0,    0,   19,    0,  166,    0,    0,
        0,  165,    0,    0,  169,    0,  164,    0,  168,    0,
        0,  116,  162,  132,  162,  162,  162,   30,   31,  162,
      162,  162,  162,  162,  162,  162,   40,   43,   41,  162,

      162,   48,  162,  162,  162,   55,  162,  162,  162,  162,
      162,  162,  162,  162,   67,   72,  162,  162,  162,  162,
      162,   83,  162,  162,  162,  162,  162,  162,   92,  162,
      162,   96,   97,  162,  101,  162,  103,  134,    0,    1,
        0,  162,  162,  162,  162,    6,  162,  162,  162,  162,
        6,  162,   96,    6,    0,    0,  176,    0,    0,    0,
        0,    0,   14,    0,    0,    0,    0,   16,    0,   95,
       18,    0,    0,    0,  165,  162,  162,   28,   29,   32,
      162,   34,  162,  162,   38,  162,    0,  162,   45,   46,
      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,

      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
       86,  162,  162,  162,  162,  162,   98,  102,    0,  162,
        6,  162,  162,  162,  162,  162,  162,  162,  162,  162,
        5,    0,  174,    0,    8,    0,    0,    0,    0,    0,
        0,    0,    0,    0,    0,  166,  167,    0,    0,  165,
        0,  162,   27,  162,  162,  162,  162,   39,    0,   42,
      162,  162,  162,  162,  162,   57,  162,   60,  162,   64,
      162,   66,  162,   78,  162,  162,  162,  162,  162,   85,
       87,   90,  162,  162,   94,    0,  162,  162,  162,  162,
      162,    6,  162,  162,  162,  162,    0,    0,    0,    0,

        0,    0,   17,    0,    0,    0,    0,  166,    0,    0,
      162,  162,  162,  162,   37,   44,   50,   51,   53,  162,
       56,  162,  162,   65,  162,   79,  162,   81,  162,  162,
       91,   93,    0,  162,  162,   50,  162,    6,  162,    6,
      162,  162,    0,    0,    0,   49,    0,   10,    0,   21,
        0,    0,    0,  167,   24,  162,   35,   36,   54,  162,
      162,   76,   80,  162,  162,    0,    6,  162,    2,    6,
      162,  162,  162,    0,    7,    0,   13,    0,    0,    0,
      167,    0,  162,  162,   62,   82,   84,  162,    6,    6,
        6,    0,    0,   20,   15,   11,   33,   59,    6,    0,

        9,  175,    0
    ) ;

yy_ec : constant array(ASCII.NUL..Character'Last) of short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    2,    2,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    4,    5,    6,    7,    1,    1,    8,    9,   10,
       11,   12,   13,   14,   15,   16,   17,   18,   19,   19,
       19,   19,   19,   19,   19,   19,   19,   20,   21,   22,
       23,   24,   25,    1,   26,   27,   26,   26,   28,   26,
       29,   29,   29,   29,   29,   29,   29,   29,   29,   29,
       29,   29,   29,   29,   29,   29,   29,   30,   29,   29,
       31,   32,   33,    1,   34,    1,   35,   36,   37,   38,

       39,   40,   41,   42,   43,   29,   44,   45,   46,   47,
       48,   49,   50,   51,   52,   53,   54,   55,   56,   57,
       58,   29,   59,   60,   61,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    ) ;

yy_meta : constant array(0..61) of short :=
    (   0,
        1,    1,    2,    1,    1,    1,    3,    1,    1,    1,
        1,    4,    1,    1,    1,    5,    1,    6,    6,    1,
        1,    1,    4,    1,    1,    7,    7,    7,    8,    8,
        1,    1,    1,    9,    7,    7,    7,    7,    7,    7,
        8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
        8,    8,    8,    8,    8,    8,    8,    8,    1,    1,
        1
    ) ;

yy_base : constant array(0..720) of short :=
    (   0,
        0,   60,  959,  958,  957,  956,  955,   61,   68,   76,
        0,  102,  963,  969,   70,  969,  939,   72,    0,  938,
      969,  969,   54,   66,  969,   68,   68,  937,  156,  160,
      131,  969,   71,   44,   82,  969,    0,  969,  969,  112,
       79,   77,   59,  146,   42,  108,  158,  117,  911,  148,
      166,   75,  904,  131,  123,  165,  121,  922,  166,  908,
      931,  162,  969,  222,  184,  166,  183,  173,  193,  195,
      200,  204,  198,  208,  199,  216,  229,  969,  922,  258,
      969,  969,    0,  907,  913,  909,  890,  913,  219,   83,
      894,  908,  224,  907,  896,  221,  902,  891,  899,  881,

      275,  969,  925,  969,  270,  969,  933,  935,    0,  969,
      914,  969,  969,  969,    0,  969,  969,  920,  913,  969,
        0,  262,  267,  269,  278,    0,  281,  301,  969,  914,
      918,  969,  916,  908,  284,  907,  969,  905,  969,  969,
      969,  905,    0,  875,  881,  887,  872,  882,  874,  883,
      868,  884,  871,  124,  876,  879,  137,  877,  266,  863,
      866,  865,  863,    0,  861,  856,    0,  862,  861,  273,
      868,  849,  851,  858,    0,  849,  878,  858,  274,  220,
      860,  851,  277,  851,  860,  854,  855,  844,  839,  852,
      839,  173,  836,  837,  969,  969,  969,    0,    0,  830,

      834,  846,  842,  823,  830,  846,  833,  841,  269,  831,
      830,  827,  822,  818,  820,  276,  281,  833,  832,  817,
      331,  860,  865,    0,  819,  969,  817,  809,  825,  969,
      811,  827,  814,  822,  810,  811,  810,  807,  802,  798,
      969,  816,  804,  812,  811,  796,  969,    0,  969,    0,
      969,  321,  320,  322,  324,  326,  814,  844,  824,  969,
      969,  969,  969,  969,  969,  792,    0,  821,  804,  799,
      804,  782,  800,  786,  294,  792,  783,  792,  792,  793,
      310,  789,  778,  782,  790,  772,  790,  787,  789,  313,
      785,  787,  779,  777,  771,    0,    0,    0,  774,  775,

      969,  778,  772,  780,  759,  283,  759,  771,  763,    0,
        0,  756,  770,  769,  754,  765,  758,  765,  760,    0,
        0,  755,  756,  758,  776,  969,  749,  348,  741,  757,
      360,  742,  742,  320,  750,  744,  754,  751,  320,  750,
      367,  744,  329,  740,    0,  744,  969,  969,  734,  739,
      372,  736,  729,  729,  743,  969,  731,  741,  738,  728,
      736,  969,  730,  330,  726,  969,  730,  349,    0,  371,
      373,  367,  378,  380,  384,  390,  392,  394,  737,  736,
      766,  969,  717,  969,  716,  719,  721,    0,    0,  712,
      709,  709,  718,  725,  724,  705,    0,    0,  241,  717,

      716,    0,  704,  707,  718,  699,  700,  715,  710,  697,
      696,  708,  692,  705,    0,    0,  695,  691,  706,  695,
      704,  699,  698,  697,  696,  683,  682,  681,    0,  673,
      691,    0,    0,  684,    0,  689,    0,  969,  679,  969,
      679,  674,  672,  669,  671,  668,  669,  668,  667,  682,
      677,  676,  412,    0,  417,  675,  969,  420,  662,  660,
      657,  659,  656,  657,  656,  655,  670,  665,  664,  969,
      969,  412,  383,  410,  414,  667,  648,    0,    0,    0,
      649,  664,  651,  646,    0,  644,  652,  654,    0,    0,
      640,  654,  640,  647,  646,  643,  641,  633,  645,  649,

      644,  644,  634,  628,  638,  633,  624,  638,  638,  636,
        0,  635,  625,  619,  621,  631,    0,    0,  617,  632,
        0,  615,  612,  621,  620,  609,  621,  619,  621,  621,
      969,  611,  969,  621,  969,  604,  601,  610,  609,  598,
      610,  608,  610,  610,  416,  418,  353,  431,  432,  422,
      424,  609,    0,  594,  597,  589,  603,    0,  601,    0,
      588,  587,  600,  589,  599,    0,  596,    0,  599,    0,
      595,    0,  597,    0,  592,  591,  590,  574,  574,    0,
        0,    0,  587,  586,    0,  571,  586,  571,  569,  572,
      582,    0,  583,  578,  562,  562,  575,  576,  561,  559,

      562,  572,  969,  573,  568,  552,  552,  426,  428,  436,
      551,  564,  549,  562,    0,  969,    0,    0,    0,  553,
        0,  552,  561,    0,  552,    0,  551,    0,  544,  555,
        0,    0,  541,  538,  549,  455,  540,    0,  536,    0,
      518,  526,  511,  490,  493,  969,  438,  969,  447,  969,
      432,  443,  443,  445,    0,  434,    0,    0,    0,  427,
      439,    0,    0,  438,  415,  465,    0,  403,  969,    0,
      365,  361,  356,  331,  969,  332,  969,  287,  255,  254,
      452,  454,  144,  130,    0,    0,    0,   85,    0,    0,
        0,   65,   23,  969,  969,  969,    0,    0,    0,  472,

      969,  969,  969,  486,  495,  504,  507,  510,  519,  528,
      532,  541,  545,  547,  554,  561,  565,  574,  578,  583
    ) ;

yy_def : constant array(0..720) of short :=
    (   0,
      703,    1,    1,    2,    1,    2,    1,    2,  704,  704,
      705,  705,  703,  703,  703,  703,  703,  706,  707,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  708,  703,  703,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      703,  703,  703,  703,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  703,  703,  709,   64,
      703,  703,  710,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,

      703,  703,  703,  703,  706,  703,  703,  706,  711,  703,
      703,  703,  703,  703,  712,  703,  703,  703,  703,  703,
      713,  703,  703,  703,  703,  714,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  703,  703,  703,   64,  715,  703,

      703,  703,  703,  703,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      703,  703,  709,   80,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  711,  703,  712,
      703,  716,  703,  703,  703,  703,  717,  718,  703,  703,
      703,  703,  703,  703,  703,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,

      703,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  703,  703,  703,  703,  703,
      703,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  719,  716,
      716,  703,  703,  703,  703,  703,  703,  703,  717,  717,
      718,  703,  708,  703,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,

      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  703,  703,  703,
      703,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  720,  703,  703,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  703,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,

      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  703,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  720,  720,  703,
      703,  708,  708,  708,  708,  708,  708,  708,  703,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  703,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  703,  703,  703,  703,

      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      708,  708,  708,  708,  708,  703,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  703,  708,  708,  708,  708,  708,  708,  708,
      708,  708,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  708,  708,  708,  708,  708,  708,
      708,  708,  708,  708,  708,  703,  708,  708,  703,  708,
      708,  708,  708,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  708,  708,  708,  708,  708,  708,  708,  708,
      708,  703,  703,  703,  703,  703,  708,  708,  708,  703,

      703,  703,    0,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703
    ) ;

yy_nxt : constant array(0..1030) of short :=
    (   0,
       14,   15,   16,   15,   17,   18,   19,   20,   14,   21,
       22,   23,   24,   25,   26,   27,   28,   29,   30,   31,
       32,   33,   34,   35,   36,   37,   37,   37,   37,   37,
       38,   14,   39,   14,   40,   41,   42,   43,   44,   45,
       46,   37,   47,   37,   48,   49,   50,   51,   52,   53,
       54,   55,   56,   57,   58,   59,   60,   37,   61,   62,
       63,   64,   80,   64,   80,  111,  138,  139,  140,   79,
       82,  101,  102,  101,  106,  701,  112,  107,   82,   83,
      118,  113,  115,  119,  103,  113,  133,   83,  114,  160,
      116,  117,  134,  135,   65,  161,   66,  154,   67,   68,

       69,  155,   70,  108,  141,  142,   71,   72,   73,  179,
       84,  151,   74,   75,   85,   76,  700,  148,   84,   77,
       86,  152,   85,  149,  153,  180,  150,   87,   86,  234,
      136,  137,  128,  129,  128,   87,   88,  699,   89,  235,
       90,   91,   92,  130,   93,  131,  162,  144,   94,   95,
       96,  168,  163,  132,   97,   98,  145,   99,  146,  169,
      276,  100,  121,  147,  170,  182,  121,  189,  277,  183,
      184,  122,  190,  123,  123,  122,  185,  123,  123,  280,
      156,  698,  124,  125,  196,  126,  172,  125,  281,  127,
      157,  124,  158,  127,  125,  173,  697,  164,  125,  186,

      151,  174,  159,  165,  166,  175,  187,  192,  193,  167,
      206,  322,  126,  207,  176,  323,  177,  156,  178,  205,
      160,  197,  188,  198,  102,  198,  210,  157,  145,  208,
      146,  211,  216,  199,  164,  147,  103,  163,  214,  209,
      212,  213,  186,  175,  487,  189,  167,  173,  217,  218,
      219,  196,  215,  174,  177,  242,  178,  192,  220,  224,
      200,  224,  305,  232,  201,  188,  233,  306,  202,  238,
      239,  243,  106,  121,  203,  107,  101,  102,  101,  253,
      253,  204,  122,  488,  123,  123,  254,  254,  221,  103,
      255,  696,  255,  695,  125,  256,  256,  225,  123,  123,

      127,  108,  128,  129,  128,  125,  261,  262,  283,  294,
      303,  283,  342,  309,  284,  131,  310,  336,  285,  422,
      295,  285,  311,  305,  304,  694,  304,  368,  343,  312,
      391,  313,  347,  347,  347,  423,  369,  372,  372,  375,
      375,  256,  256,  377,  377,  392,  393,  373,  399,  440,
      440,  440,  400,  374,  371,  376,  444,  409,  373,  378,
      410,  347,  347,  347,  409,  451,  468,  448,  347,  347,
      347,  392,  393,  457,  457,  457,  472,  368,  693,  703,
      610,  452,  469,  692,  372,  372,  369,  472,  703,  547,
      474,  610,  474,  691,  373,  475,  475,  372,  372,  690,

      374,  375,  375,  689,  371,  373,  703,  375,  375,  377,
      377,  377,  377,  347,  347,  347,  549,  376,  531,  531,
      531,  533,  533,  533,  545,  378,  545,  475,  475,  546,
      546,  550,  550,  546,  546,  608,  608,  547,  703,  550,
      550,  550,  550,  608,  608,  608,  608,  551,  653,  688,
      653,  609,  687,  654,  654,  551,  669,  669,  669,  609,
      654,  654,  681,  681,  549,  703,  669,  669,  669,  681,
      681,  681,  681,  702,  702,  702,  686,  685,  682,  684,
      683,  680,  679,  678,  677,  682,   81,   81,   81,   81,
       81,   81,   81,   81,   81,   82,   82,   82,   82,   82,

       82,   82,   82,   82,  105,  105,  105,  105,  105,  105,
      105,  105,  105,  109,  109,  143,  143,  143,  143,  222,
      222,  222,  222,  222,  222,  222,  222,  222,  226,  226,
      226,  676,  226,  226,  226,  226,  226,  248,  248,  248,
      248,  250,  675,  250,  250,  250,  250,  250,  250,  250,
      252,  252,  257,  257,  326,  326,  326,  674,  326,  326,
      326,  326,  326,  370,  673,  370,  370,  370,  672,  370,
      379,  379,  671,  379,  381,  381,  381,  381,  381,  381,
      381,  381,  381,  473,  473,  548,  670,  668,  548,  548,
      667,  548,  666,  665,  664,  663,  662,  661,  660,  659,

      658,  657,  656,  655,  652,  651,  650,  649,  648,  647,
      646,  645,  644,  643,  642,  641,  640,  639,  638,  637,
      636,  635,  634,  633,  632,  631,  630,  629,  628,  627,
      626,  625,  624,  623,  622,  621,  620,  619,  618,  617,
      616,  615,  614,  613,  612,  611,  607,  606,  605,  604,
      603,  602,  601,  600,  599,  598,  597,  596,  595,  594,
      593,  592,  591,  590,  589,  588,  587,  586,  585,  584,
      583,  582,  581,  580,  579,  578,  577,  576,  575,  574,
      573,  572,  571,  570,  569,  568,  567,  566,  565,  564,
      563,  562,  561,  560,  559,  558,  557,  556,  555,  554,

      553,  552,  544,  543,  542,  541,  540,  539,  538,  537,
      536,  535,  534,  532,  530,  529,  528,  527,  526,  525,
      524,  523,  522,  521,  520,  331,  519,  518,  517,  516,
      515,  514,  513,  512,  511,  510,  509,  508,  507,  506,
      505,  504,  503,  502,  501,  500,  499,  498,  497,  496,
      495,  494,  493,  492,  491,  490,  489,  486,  485,  484,
      483,  482,  481,  480,  479,  478,  477,  476,  129,  703,
      380,  471,  470,  467,  466,  465,  464,  463,  462,  461,
      460,  459,  458,  456,  455,  454,  453,  450,  449,  447,
      446,  445,  401,  443,  442,  441,  331,  439,  438,  437,

      436,  435,  434,  433,  432,  431,  430,  429,  428,  427,
      426,  425,  424,  421,  420,  419,  418,  417,  416,  415,
      414,  413,  412,  411,  408,  407,  406,  405,  404,  403,
      402,  401,  398,  397,  396,  395,  394,  390,  389,  388,
      387,  386,  385,  384,  383,  382,  129,  380,  367,  366,
      365,  364,  363,  362,  361,  360,  359,  358,  357,  356,
      355,  354,  353,  352,  351,  350,  349,  703,  348,  346,
      345,  344,  300,  341,  340,  339,  338,  337,  335,  334,
      333,  332,  331,  330,  329,  328,  327,  325,  324,  321,
      320,  319,  318,  317,  316,  315,  314,  308,  307,  302,

      301,  300,  299,  298,  297,  296,  293,  292,  291,  290,
      289,  288,  287,  286,  282,  279,  278,  275,  274,  273,
      272,  271,  270,  269,  268,  267,  266,  265,  264,  263,
      260,  259,  258,  113,  251,  113,  249,  703,  105,  115,
      247,  246,  245,  244,  241,  240,  237,  236,  231,  230,
      229,  228,  227,  223,  195,  194,  191,  181,  171,  120,
      110,  104,  703,   79,   79,   79,   78,   78,   13,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,

      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703
    ) ;

yy_chk : constant array(0..1030) of short :=
    (   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    8,    2,    8,   23,   34,   34,   34,    8,
        9,   15,   15,   15,   18,  693,   23,   18,   10,    9,
       27,   24,   26,   27,   15,   24,   33,   10,   24,   45,
       26,   26,   33,   33,    2,   45,    2,   43,    2,    2,

        2,   43,    2,   18,   35,   35,    2,    2,    2,   52,
        9,   42,    2,    2,    9,    2,  692,   41,   10,    2,
        9,   42,   10,   41,   42,   52,   41,    9,   10,   90,
       33,   33,   31,   31,   31,   10,   12,  688,   12,   90,
       12,   12,   12,   31,   12,   31,   46,   40,   12,   12,
       12,   48,   46,   31,   12,   12,   40,   12,   40,   48,
      154,   12,   29,   40,   48,   54,   30,   57,  154,   54,
       55,   29,   57,   29,   29,   30,   55,   30,   30,  157,
       44,  684,   29,   29,   62,   29,   50,   30,  157,   29,
       44,   29,   44,   30,   29,   50,  683,   47,   30,   56,

       66,   50,   44,   47,   47,   51,   56,   59,   59,   47,
       66,  192,   29,   66,   51,  192,   51,   67,   51,   65,
       68,   62,   56,   64,   64,   64,   68,   67,   65,   67,
       65,   69,   73,   64,   70,   65,   64,   69,   71,   67,
       70,   70,   74,   72,  399,   75,   70,   71,   73,   74,
       75,   77,   72,   71,   72,   96,   72,   76,   76,   80,
       64,   80,  180,   89,   64,   74,   89,  180,   64,   93,
       93,   96,  105,  123,   64,  105,  101,  101,  101,  122,
      122,   64,  123,  399,  123,  123,  124,  124,   77,  101,
      125,  680,  125,  679,  123,  125,  125,   80,  127,  127,

      123,  105,  128,  128,  128,  123,  135,  135,  159,  170,
      179,  209,  216,  183,  159,  128,  183,  209,  159,  306,
      170,  209,  183,  217,  179,  678,  216,  252,  217,  183,
      275,  183,  221,  221,  221,  306,  252,  253,  253,  254,
      254,  255,  255,  256,  256,  275,  275,  253,  281,  328,
      328,  328,  281,  253,  252,  254,  334,  290,  253,  256,
      290,  331,  331,  331,  339,  343,  364,  339,  341,  341,
      341,  334,  334,  351,  351,  351,  368,  370,  676,  371,
      547,  343,  364,  674,  372,  372,  370,  368,  371,  473,
      373,  547,  373,  673,  372,  373,  373,  374,  374,  672,

      372,  375,  375,  671,  370,  372,  371,  376,  376,  377,
      377,  378,  378,  453,  453,  453,  473,  375,  455,  455,
      455,  458,  458,  458,  472,  377,  472,  474,  474,  472,
      472,  475,  475,  545,  545,  546,  546,  548,  549,  550,
      550,  551,  551,  608,  608,  609,  609,  475,  610,  668,
      610,  546,  665,  610,  610,  550,  636,  636,  636,  608,
      653,  653,  654,  654,  548,  549,  666,  666,  666,  681,
      681,  682,  682,  700,  700,  700,  664,  661,  654,  660,
      656,  652,  651,  649,  647,  681,  704,  704,  704,  704,
      704,  704,  704,  704,  704,  705,  705,  705,  705,  705,

      705,  705,  705,  705,  706,  706,  706,  706,  706,  706,
      706,  706,  706,  707,  707,  708,  708,  708,  708,  709,
      709,  709,  709,  709,  709,  709,  709,  709,  710,  710,
      710,  645,  710,  710,  710,  710,  710,  711,  711,  711,
      711,  712,  644,  712,  712,  712,  712,  712,  712,  712,
      713,  713,  714,  714,  715,  715,  715,  643,  715,  715,
      715,  715,  715,  716,  642,  716,  716,  716,  641,  716,
      717,  717,  639,  717,  718,  718,  718,  718,  718,  718,
      718,  718,  718,  719,  719,  720,  637,  635,  720,  720,
      634,  720,  633,  630,  629,  627,  625,  623,  622,  620,

      614,  613,  612,  611,  607,  606,  605,  604,  602,  601,
      600,  599,  598,  597,  596,  595,  594,  593,  591,  590,
      589,  588,  587,  586,  584,  583,  579,  578,  577,  576,
      575,  573,  571,  569,  567,  565,  564,  563,  562,  561,
      559,  557,  556,  555,  554,  552,  544,  543,  542,  541,
      540,  539,  538,  537,  536,  534,  532,  530,  529,  528,
      527,  526,  525,  524,  523,  522,  520,  519,  516,  515,
      514,  513,  512,  510,  509,  508,  507,  506,  505,  504,
      503,  502,  501,  500,  499,  498,  497,  496,  495,  494,
      493,  492,  491,  488,  487,  486,  484,  483,  482,  481,

      477,  476,  469,  468,  467,  466,  465,  464,  463,  462,
      461,  460,  459,  456,  452,  451,  450,  449,  448,  447,
      446,  445,  444,  443,  442,  441,  439,  436,  434,  431,
      430,  428,  427,  426,  425,  424,  423,  422,  421,  420,
      419,  418,  417,  414,  413,  412,  411,  410,  409,  408,
      407,  406,  405,  404,  403,  401,  400,  396,  395,  394,
      393,  392,  391,  390,  387,  386,  385,  383,  381,  380,
      379,  367,  365,  363,  361,  360,  359,  358,  357,  355,
      354,  353,  352,  350,  349,  346,  344,  342,  340,  338,
      337,  336,  335,  333,  332,  330,  329,  327,  325,  324,

      323,  322,  319,  318,  317,  316,  315,  314,  313,  312,
      309,  308,  307,  305,  304,  303,  302,  300,  299,  295,
      294,  293,  292,  291,  289,  288,  287,  286,  285,  284,
      283,  282,  280,  279,  278,  277,  276,  274,  273,  272,
      271,  270,  269,  268,  266,  259,  258,  257,  246,  245,
      244,  243,  242,  240,  239,  238,  237,  236,  235,  234,
      233,  232,  231,  229,  228,  227,  225,  223,  222,  220,
      219,  218,  215,  214,  213,  212,  211,  210,  208,  207,
      206,  205,  204,  203,  202,  201,  200,  194,  193,  191,
      190,  189,  188,  187,  186,  185,  184,  182,  181,  178,

      177,  176,  174,  173,  172,  171,  169,  168,  166,  165,
      163,  162,  161,  160,  158,  156,  155,  153,  152,  151,
      150,  149,  148,  147,  146,  145,  144,  142,  138,  136,
      134,  133,  131,  130,  119,  118,  111,  108,  107,  103,
      100,   99,   98,   97,   95,   94,   92,   91,   88,   87,
       86,   85,   84,   79,   61,   60,   58,   53,   49,   28,
       20,   17,   13,    7,    6,    5,    4,    3,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,

      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703,
      703,  703,  703,  703,  703,  703,  703,  703,  703,  703
    ) ;


-- copy whatever the last rule matched to the standard output

procedure ECHO is
begin
   if (text_io.is_open(user_output_file)) then
     text_io.put( user_output_file, yytext );
   else
     text_io.put( yytext );
   end if;
end ECHO;

-- enter a start condition.
-- Using procedure requires a () after the ENTER, but makes everything
-- much neater.

procedure ENTER( state : integer ) is
begin
     yy_start := 1 + 2 * state;
end ENTER;

-- action number for EOF rule of a given start state
function YY_STATE_EOF(state : integer) return integer is
begin
     return YY_END_OF_BUFFER + state + 1;
end YY_STATE_EOF;

-- return all but the first 'n' matched characters back to the input stream
procedure yyless(n : integer) is
begin
        yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
        yy_cp := yy_bp + n;
        yy_c_buf_p := yy_cp;
        YY_DO_BEFORE_ACTION; -- set up yytext again
end yyless;

-- redefine this if you have something you want each time.
procedure YY_USER_ACTION is
begin
        null;
end;

-- yy_get_previous_state - get the state just before the EOB char was reached

function yy_get_previous_state return yy_state_type is
    yy_current_state : yy_state_type;
    yy_c : short;
    yy_bp : integer := yytext_ptr;
begin
    yy_current_state := yy_start;
    if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	yy_current_state := yy_current_state + 1;
    end if;

    for yy_cp in yytext_ptr..yy_c_buf_p - 1 loop
	yy_c := yy_ec(yy_ch_buf(yy_cp));
	if ( yy_accept(yy_current_state) /= 0 ) then
	    yy_last_accepting_state := yy_current_state;
	    yy_last_accepting_cpos := yy_cp;
	end if;
	while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
	    yy_current_state := yy_def(yy_current_state);
	    if ( yy_current_state >= 704 ) then
		yy_c := yy_meta(yy_c);
	    end if;
	end loop;
	yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
    end loop;

    return yy_current_state;
end yy_get_previous_state;

procedure yyrestart( input_file : file_type ) is
begin
   open_input(text_io.name(input_file));
end yyrestart;

begin -- of YYLex
<<new_file>>
        -- this is where we enter upon encountering an end-of-file and
        -- yywrap() indicating that we should continue processing

    if ( yy_init ) then
        if ( yy_start = 0 ) then
            yy_start := 1;      -- first start state
        end if;

        -- we put in the '\n' and start reading from [1] so that an
        -- initial match-at-newline will be true.

        yy_ch_buf(0) := ASCII.LF;
        yy_n_chars := 1;

        -- we always need two end-of-buffer characters.  The first causes
        -- a transition to the end-of-buffer state.  The second causes
        -- a jam in that state.

        yy_ch_buf(yy_n_chars) := YY_END_OF_BUFFER_CHAR;
        yy_ch_buf(yy_n_chars + 1) := YY_END_OF_BUFFER_CHAR;

        yy_eof_has_been_seen := false;

        yytext_ptr := 1;
        yy_c_buf_p := yytext_ptr;
        yy_hold_char := yy_ch_buf(yy_c_buf_p);
        yy_init := false;
    end if; -- yy_init

    loop                -- loops until end-of-file is reached


        yy_cp := yy_c_buf_p;

        -- support of yytext
        yy_ch_buf(yy_cp) := yy_hold_char;

        -- yy_bp points to the position in yy_ch_buf of the start of the
        -- current run.
	yy_bp := yy_cp;
	yy_current_state := yy_start;
	if ( yy_ch_buf(yy_bp-1) = ASCII.LF ) then
	    yy_current_state := yy_current_state + 1;
	end if;
	loop
		yy_c := yy_ec(yy_ch_buf(yy_cp));
		if ( yy_accept(yy_current_state) /= 0 ) then
		    yy_last_accepting_state := yy_current_state;
		    yy_last_accepting_cpos := yy_cp;
		end if;
		while ( yy_chk(yy_base(yy_current_state) + yy_c) /= yy_current_state ) loop
		    yy_current_state := yy_def(yy_current_state);
		    if ( yy_current_state >= 704 ) then
			yy_c := yy_meta(yy_c);
		    end if;
		end loop;
		yy_current_state := yy_nxt(yy_base(yy_current_state) + yy_c);
	    yy_cp := yy_cp + 1;
if ( yy_current_state = 703 ) then
    exit;
end if;
	end loop;
	yy_cp := yy_last_accepting_cpos;
	yy_current_state := yy_last_accepting_state;

<<next_action>>
	    yy_act := yy_accept(yy_current_state);
            YY_DO_BEFORE_ACTION;
            YY_USER_ACTION;

        if aflex_debug then  -- output acceptance info. for (-d) debug mode
            text_io.put( Standard_Error, "--accepting rule #" );
            text_io.put( Standard_Error, INTEGER'IMAGE(yy_act) );
            text_io.put_line( Standard_Error, "(""" & yytext & """)");
        end if;


<<do_action>>   -- this label is used only to access EOF actions
            case yy_act is
		when 0 => -- must backtrack
		-- undo the effects of YY_DO_BEFORE_ACTION
		yy_ch_buf(yy_cp) := yy_hold_char;
		yy_cp := yy_last_accepting_cpos;
		yy_current_state := yy_last_accepting_state;
		goto next_action;



-- ^[ \r\t\f]+/"queued"[ \r\t\f\n] {
--         -- ignore "queued" at start of line as far as indenting
--         ECHO_L; 
--         if Debug_Indent and then Expecting_Indent then
--            Text_IO.Put(" [queued: indent off] ");
--         end if;
--         Expecting_Indent := False;  -- "then" will turn it back on
-- }
when 1 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 3;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 50 "ada202x_lex.l"

        -- ignore "is" at start of line as far as indenting
        ECHO_L; 


when 2 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 55 "ada202x_lex.l"

        -- this keyword when used at the beginning of a line
        -- is expected to be "outdented" relative to the preceding and
        -- following construct.  We want to treat it as though it
        -- it is the same indent as the prior construct that is just slightly
        -- more indented than this keyword.
        -- However, if we are expecting an *indent* then we don't look
        -- at the stack, and just return an INDENT, while preserving
        -- the "expecting indent" flag.
        -- If not expecting an indent, then we generate zero or more
        -- OUTDENTs and one NEWLINE if it is outdented relative to
        -- the top of the indent stack.  If not outdented relative to
        -- the top of the indent stack, we don't produce anything extra.

    declare
        YYT : constant String := yytext;
        Exports_Length : constant := 7; --  "exports"'Length
    begin
        pragma Assert (Col_Count = 0);

        --  Start of line, determine indent
        ECHO_L(YYT(YYT'First .. YYT'Last - Exports_Length)); 

        --  Put "exports" back
        for I in reverse YYT'Last - Exports_Length + 1 .. YYT'Last loop
           unput(YYT(I));
        end loop;

        if Col_Count = 0 then
           ENTER(RESCANNING);
        end if;

        --  At this point, Col_Count is indent level

        if Expecting_Indent then
           yylval := Create_Token(Text => "");
           if Debug_Indent then
              Text_IO.Put_Line(" [returning INDENT] ");
              Text_IO.Flush;
           end if;
           --  Preserve indent expectation
           Expecting_Indent := True;
           return INDENT;
        elsif Top = 0 then
           --  No indents on stack yet
           --  This shouldn't happen.
           yyerror("Source file cannot start with this token");
        elsif Col_Count >= Indent_Stack(Top) then
           --  Indenting relative to remembered stack
           --  Do nothing
           null;
        elsif Top = 1 then
           --  This is unexpected; should be at least two
           --  Do nothing
           null;
        elsif Col_Count >= Indent_Stack(Top-1) then
           --  See where we stand relative to the next indent level.
           --  We are not more outdented than next level, so return NEWLINE
           yylval := Create_Token(Text => "");
           if Debug_Indent then
              Text_IO.Put_Line(" [returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           return NEWLINE;
        else
           --  Outdenting relative to remembered indent;
           --  we will set Col_Match_Expected to False so we
           --  won't complain about a col-count mismatch.
           pragma Assert (Col_Count < Indent_Stack (Top-1));

           Col_Match_Expected := False;

           if Debug_Indent then
              Text_IO.Put_Line(" [entering OUTDENTING; returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           ENTER(OUTDENTING);
           return NEWLINE;
        end if;
        if Debug_Indent and then Expecting_Indent then
           Text_IO.Put(" [NL: indent off] ");
        end if;
        Expecting_Indent := False;
    end;


when 3 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 141 "ada202x_lex.l"

        -- ignore "new", "then", "||" at start of line as far as indenting
        -- but return a NEWLINE if not expecting an INDENT
    declare
        YYT : constant String := yytext;
    begin

        pragma Assert (Col_Count = 0);

        for I in reverse YYT'Range loop
           if YYT(I) <= ' ' then
              --  Echo the spaces at the front of the line
              ECHO_L(YYT(YYT'First .. I));
              exit;
           end if;
           --  Unput the non-space characters
           unput(YYT(I));
        end loop;

        if Col_Count = 0 then
           --  Next time, return the token
           ENTER(RESCANNING);
        end if;

        if not Expecting_Indent then
           return NEWLINE;
        end if;
    end;


when 4 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 2;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 171 "ada202x_lex.l"

        -- Remember Expecting_Indent state, and return INDENT
        -- if expecting indent, but don't push new indent level on stack;
        -- return NEWLINE if not expecting an indent.
        Expecting_Indent_At_Label := Expecting_Indent;
        ECHO_L; 
        if Expecting_Indent then
            yylval := Create_Token(Text => "");
            if Debug_Indent then
               Text_IO.Put_Line(" [label: returning INDENT] "); Text_IO.Flush;
            end if;
            Expecting_Indent := True;
            return INDENT;
        else
            return NEWLINE;
        end if;


when 5 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
yy_cp := yy_cp - 4;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 189 "ada202x_lex.l"

        -- ignore "for" after "implements" at start of line as far as indenting
        ECHO_L; 
        ENTER(CHARLIT);


when 6 => 
--# line 195 "ada202x_lex.l"

    declare
        -- ignore spaces,Carriage returns,tabs,form feeds
        -- 
        -- determine indent (expanding tabs appropriately)
        -- compare to top of indent "stack"
        -- if less, emit OUTDENTs while popping from stack until find match
        --   (except ignore such a line if it starts with 
        --     "then"/"new"/"implements"/"exports"/"||"/"*XXX*")
        --   * complain if new level does not match one already on stack
        -- if same, emit NEWLINE; leave stack as is.
        -- if indent is more than top of stack:
        --   * if prior line ends with ":", push indent on stack and emit INDENT
        --   * if prior line does *not* end with ":" do not push indent on stack

        YYT : constant String := yytext;
    begin

        pragma Assert (Col_Count = 0);

        if YYT(YYT'First) in 'a'..'z' then
           --  Indent is zero; put back characters
           for I in reverse YYT'Range loop
              unput(YYT(I));
           end loop;
           --  Next time, return the token
           ENTER(RESCANNING);
        else
           --  Start of line, determine indent
           ECHO_L; 
        end if;

        --  At this point, Col_Count is indent level

        if Top = 0 then
           --  No indents on stack yet
           Top := Top + 1;
           Indent_Stack(Top) := Col_Count;
           Bracketing_Token_Stack(Top) := Error;
           if Debug_Indent then
              Text_IO.Put_Line(" [pushing" & Integer'Image(Col_Count) &
                " at bottom of Indent_Stack] ");
              Text_IO.Flush;
           end if;
        elsif Col_Count > Indent_Stack(Top) then
           --  Indenting relative to remembered stack
           if Expecting_Indent then
              --  Indenting is only significant if
              --  preceded by ':'/is/of/then/else/loop
              Top := Top + 1;
              Indent_Stack(Top) := Col_Count;
              Bracketing_Token_Stack(Top) := Bracketing_Token;
              if Debug_Indent then
                 Text_IO.Put_Line(" [pushing" & Integer'Image(Col_Count) &
                   " on Indent_Stack] "); Text_IO.Flush;
              end if;
              yylval := Create_Token(Text => "");
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning INDENT] "); Text_IO.Flush;
              end if;
              return INDENT;
           end if;
        elsif Col_Count = Indent_Stack(Top) then
           --  Same indent, this is a "significant" newline
           yylval := Create_Token(Text => "");
           if Debug_Indent then
              Text_IO.Put_Line(" [returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           return NEWLINE;
        else
           --  Outdenting relative to remembered indent;
           --  we will pop indent-stack until we get a match
           pragma Assert (Col_Count < Indent_Stack (Top));

           --  tbd: convert last OUTDENT into a NEWLINE: Top := Top - 1;
           if Debug_Indent then
              Text_IO.Put_Line(" [entering OUTDENTING; returning NEWLINE] ");
              Text_IO.Flush;
           end if;
           ENTER(OUTDENTING);
           return NEWLINE;
        end if;
        if Debug_Indent and then Expecting_Indent then
           Text_IO.Put(" [NL: indent off] ");
        end if;
        Expecting_Indent := False;
    end;


when 7 => 
--# line 285 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ABSTRACT_kw);


when 8 => 
--# line 291 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CLASS_kw);


when 9 => 
--# line 297 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONCURRENT_kw);


when 10 => 
--# line 303 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (GENERIC_kw);


when 11 => 
--# line 309 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROTECTED_kw);


when 12 => 
--# line 315 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (END_kw);


when 13 => 
--# line 321 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 14 => 
--# line 327 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 15 => 
--# line 333 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 16 => 
--# line 339 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 17 => 
--# line 345 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IMPORT_kw);


when 18 => 
--# line 351 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WITH_kw);


when 19 => 
--# line 357 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (USE_kw);


when 20 => 
--# line 363 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (INTERFACE_kw);


when 21 => 
--# line 369 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PACKAGE_kw);


when 22 => 
--# line 375 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OP_kw);


  -- Ada202x reserved words
when 23 => 
--# line 382 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ABS_kw);


when 24 => 
--# line 387 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ABSTRACT_kw);


when 25 => 
--# line 392 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ALL_kw);


when 26 => 
--# line 397 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (AND_kw);


when 27 => 
--# line 402 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ASSERT_kw);


when 28 => 
--# line 407 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (BEGIN_kw);


when 29 => 
--# line 412 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := BLOCK_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (BLOCK_kw);


when 30 => 
--# line 422 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (BODY_kw);


when 31 => 
--# line 427 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CASE_kw);


when 32 => 
--# line 432 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CLASS_kw);


when 33 => 
--# line 437 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONCURRENT_kw);


when 34 => 
--# line 442 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONST_kw);


when 35 => 
--# line 447 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONSTANT_kw);


when 36 => 
--# line 452 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (CONTINUE_kw);


when 37 => 
--# line 457 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (DECLARE_kw);


when 38 => 
--# line 462 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (DELTA_kw);


when 39 => 
--# line 467 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (DIGITS_kw);


when 40 => 
--# line 472 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EACH_kw);


when 41 => 
--# line 477 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := ELSE_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (ELSE_kw);


when 42 => 
--# line 487 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        yylval := Create_Token("elsif");
	yyerror("Use ""elsif"" rather than ""elseif""");
	return (ELSIF_kw);


when 43 => 
--# line 493 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        yylval := Create_Token("elsif");
        --  Allow "elif" as an alias for "elsif" for Python-like syntax
	return (ELSIF_kw);


when 44 => 
--# line 499 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        yylval := Create_Token("elsif");
	yyerror("Use ""elsif"" rather than ""else if""");
	return (ELSIF_kw);


when 45 => 
--# line 505 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (ELSIF_kw);


when 46 => 
--# line 510 "ada202x_lex.l"

        unput('f'); unput('i');
	ECHO_L("end"); ENTER(CHARLIT); 
        yylval := Create_Token("end");
	yyerror("Use ""end if"" rather than ""endif""");
	return (END_kw);


when 47 => 
--# line 517 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (END_kw);


when 48 => 
--# line 522 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EXIT_kw);


when 49 => 
--# line 527 "ada202x_lex.l"

        declare
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (EXPORTS_kw);
        end;


when 50 => 
--# line 540 "ada202x_lex.l"

        declare
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (EXPORTS_kw);
        end;


when 51 => 
--# line 553 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (EXTENDS_kw);


when 52 => 
--# line 558 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FOR_kw);


when 53 => 
--# line 563 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FORWARD_kw);


when 54 => 
--# line 568 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 55 => 
--# line 573 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (FUNC_kw);


when 56 => 
--# line 578 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (GENERIC_kw);


when 57 => 
--# line 583 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (GLOBAL_kw);


when 58 => 
--# line 588 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IF_kw);


when 59 => 
--# line 593 "ada202x_lex.l"

	ECHO_L; ENTER(AFTER_IMPLEMENTS); 
        --  TBD: We might want to return a NEWLINE first.
	yylval := Create_Token;
	return (IMPLEMENTS_kw);


when 60 => 
--# line 599 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IMPORT_kw);


when 61 => 
--# line 604 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (IN_kw);


when 62 => 
--# line 609 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (INTERFACE_kw);


when 63 => 
--# line 614 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := IS_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (IS_kw);


when 64 => 
--# line 624 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (LAMBDA_kw);


when 65 => 
--# line 629 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (LIMITED_kw);


when 66 => 
--# line 634 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (LOCKED_kw);


when 67 => 
--# line 639 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := LOOP_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (LOOP_kw);


when 68 => 
--# line 649 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (MOD_kw);


when 69 => 
--# line 654 "ada202x_lex.l"

        declare
           --  Preserve "Expecting_Indent" across "new"
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (NEW_kw);
        end;


when 70 => 
--# line 668 "ada202x_lex.l"

        declare
           --  Preserve "Expecting_Indent" across "new"
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           Expecting_Indent := Old_Indent;
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [indent on] ");
           end if;
	   return (NEW_kw);
        end;


when 71 => 
--# line 682 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (NOT_kw);


when 72 => 
--# line 687 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (NULL_kw);


when 73 => 
--# line 692 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := OF_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (OF_kw);


when 74 => 
--# line 702 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OP_kw);


when 75 => 
--# line 707 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OPT_kw);


when 76 => 
--# line 712 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OPTIONAL_kw);


when 77 => 
--# line 717 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OR_kw);


when 78 => 
--# line 722 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (OTHERS_kw);


when 79 => 
--# line 727 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PACKAGE_kw);


when 80 => 
--# line 732 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PARALLEL_kw);


when 81 => 
--# line 737 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PRIVATE_kw);


when 82 => 
--# line 742 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 83 => 
--# line 747 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROC_kw);


when 84 => 
--# line 752 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (PROTECTED_kw);


when 85 => 
--# line 757 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (QUEUED_kw);


when 86 => 
--# line 762 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (RANGE_kw);


when 87 => 
--# line 767 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := RECORD_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (RECORD_kw);


when 88 => 
--# line 777 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (REF_kw);


when 89 => 
--# line 782 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (REM_kw);


when 90 => 
--# line 787 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (RETURN_kw);


when 91 => 
--# line 792 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (REVERSE_kw);


when 92 => 
--# line 797 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (SOME_kw);


when 93 => 
--# line 802 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (SUBTYPE_kw);


when 94 => 
--# line 807 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (TAGGED_kw);


when 95 => 
--# line 812 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := THEN_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (THEN_kw);


when 96 => 
--# line 822 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
        Bracketing_Token := THEN_kw;
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return (THEN_kw);


when 97 => 
--# line 832 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (TYPE_kw);


when 98 => 
--# line 837 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (UNTIL_kw);


when 99 => 
--# line 842 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (USE_kw);


when 100 => 
--# line 847 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (VAR_kw);


when 101 => 
--# line 852 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WHEN_kw);


when 102 => 
--# line 857 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WHILE_kw);


when 103 => 
--# line 862 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (WITH_kw);


when 104 => 
--# line 867 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return (XOR_kw);


  -- Match all the compound Ada202x delimiters. 
when 105 => 
--# line 874 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(COMPARE);


when 106 => 
--# line 879 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(EQ);


when 107 => 
--# line 884 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(NEQ);


when 108 => 
--# line 889 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(GEQ);


when 109 => 
--# line 894 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(LEQ);


when 110 => 
--# line 899 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(LSHIFT);


when 111 => 
--# line 904 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(POWER);


when 112 => 
--# line 909 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(ASSIGN);


when 113 => 
--# line 914 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(MOVE);


when 114 => 
--# line 919 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(SWAP);


when 115 => 
--# line 924 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(DOT_DOT);


when 116 => 
--# line 929 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(OPEN_INTERVAL);


when 117 => 
--# line 934 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(OPEN_CLOSED_INTERVAL);


when 118 => 
--# line 939 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(CLOSED_OPEN_INTERVAL);


when 119 => 
--# line 944 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(REFERS_TO);


when 120 => 
--# line 949 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(GIVES);


when 121 => 
--# line 954 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(IMPLIES);


when 122 => 
--# line 959 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PARALLEL);


when 123 => 
--# line 964 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PARALLEL);


when 124 => 
--# line 969 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PLUS_ASSIGN);


when 125 => 
--# line 974 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(MINUS_ASSIGN);


when 126 => 
--# line 979 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(TIMES_ASSIGN);


when 127 => 
--# line 984 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(DIVIDE_ASSIGN);


when 128 => 
--# line 989 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(POWER_ASSIGN);


when 129 => 
--# line 994 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(COMBINE_ASSIGN);


when 130 => 
--# line 999 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(AMPERSAND_ASSIGN);


when 131 => 
--# line 1004 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(COMBINE_MOVE);


when 132 => 
--# line 1009 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(AND_ASSIGN);


when 133 => 
--# line 1014 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(OR_ASSIGN);


when 134 => 
--# line 1019 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(XOR_ASSIGN);


when 135 => 
--# line 1024 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(LSHIFT_ASSIGN);


when 136 => 
--# line 1029 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(RSHIFT_ASSIGN);


when 137 => 
--# line 1034 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(PLUS_BASED_OP);


  -- Match all the Ada202x single-character delimiters.
when 138 => 
--# line 1041 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(PRIME);


when 139 => 
--# line 1046 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('(');


when 140 => 
--# line 1051 "ada202x_lex.l"

	ECHO_L; ENTER(TICK); 
	yylval := Create_Token;
	return(')');


when 141 => 
--# line 1056 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('[');


when 142 => 
--# line 1061 "ada202x_lex.l"

	ECHO_L; ENTER(TICK); 
	yylval := Create_Token;
	return(']');


when 143 => 
--# line 1066 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('<');


when 144 => 
--# line 1071 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('>');


when 145 => 
--# line 1076 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(L_ASSERT);  --  or L_SET in PARython mode


when 146 => 
--# line 1081 "ada202x_lex.l"
  --  Allow > ... < so PARython can use  ...  for sets/maps
	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(L_ASSERT);


when 147 => 
--# line 1086 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(R_ASSERT);  --  or R_SET in PARython mode


when 148 => 
--# line 1091 "ada202x_lex.l"
  --  Allow > ... < so PARython can use  ...  for sets/maps
	ECHO_L; ENTER(CHARLIT);	  
	yylval := Create_Token;
	return(R_ASSERT);


when 149 => 
--# line 1096 "ada202x_lex.l"

        declare
           --  Remember Expecting_Indent
           Old_Indent : constant Boolean := Expecting_Indent;
        begin
	   ECHO_L; ENTER(CHARLIT); 
	   yylval := Create_Token;
           if Expecting_Indent_At_Label then
              if not Old_Indent then
                 --  Seen '*' twice; set Expecting_Indent back on
                 Expecting_Indent_At_Label := False;
                 Expecting_Indent := True;
                 if Debug_Indent then
                    Text_IO.Put(" [indent on] ");
                 end if;
              end if;
           end if;
	   return ('*');
        end;


when 150 => 
--# line 1116 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('+');


when 151 => 
--# line 1121 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(',');


when 152 => 
--# line 1126 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('-');


when 153 => 
--# line 1131 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('.');


when 154 => 
--# line 1136 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('/');


when 155 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1141 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
        Bracketing_Token := ':';
        Expecting_Indent := True;
        if Debug_Indent then
           Text_IO.Put(" [indent on] ");
        end if;
	return(EOL_COLON);


when 156 => 
--# line 1151 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(':');


when 157 => 
--# line 1156 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return(';');


when 158 => 
--# line 1161 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('|');


when 159 => 
--# line 1166 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('&');


when 160 => 
--# line 1171 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('?');


when 161 => 
--# line 1176 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT);     
	yylval := Create_Token;
	return('=');


  -- The following is used to match all valid Ada202x identifiers
  -- except reserved words. Note that leading digits and underscores
  -- are not allowed and that double underscores are not allowed.
when 162 => 
--# line 1186 "ada202x_lex.l"

	ECHO_L; ENTER(TICK);
	yylval := Create_Token;
	return(Identifier);


  -- Enumeration literals
when 163 => 
--# line 1193 "ada202x_lex.l"

	ECHO_L; ENTER(TICK);
	yylval := Create_Token;
	return(Enum_Literal);


  -- Decimal numeric literals
when 164 => 
--# line 1200 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(Integer_Literal);


when 165 => 
--# line 1206 "ada202x_lex.l"

      ECHO_L; ENTER(CHARLIT);
      yylval := Create_Token;
      return(Real_Literal);


  -- Based numeric literals.
when 166 => 
--# line 1214 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(Integer_Literal);


when 167 => 
--# line 1220 "ada202x_lex.l"

      ECHO_L; ENTER(CHARLIT);
      yylval := Create_Token;
      return(Real_Literal);


when 168 => 
--# line 1226 "ada202x_lex.l"

      ECHO_L; ENTER(CHARLIT); 
      yylval := Create_Token;
      return(Integer_Literal);


when 169 => 
--# line 1232 "ada202x_lex.l"

      ECHO_L; ENTER(CHARLIT); 
      yylval := Create_Token;
      return(Integer_Literal);


  -- Match all valid character literals.  See Ada LRM 2.6.
when 170 => 
--# line 1240 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
	yylval := Create_Token;
	return(Char_Literal);


  -- Match all valid string literals.  See Ada LRM 2.6.
when 171 => 
--# line 1248 "ada202x_lex.l"

	ECHO_L; ENTER(CHARLIT); 
        declare
           Tok : constant String := yytext;
           Quote : constant String := """";
        begin
           yylval := Create_Token (Tok);
           if Tok (Tok'Last) /= Quote(1) then
              yyerror ("unterminated string", At_Token => yylval);
           end if;
           return(String_Literal);
        end;


  -- Handle white space --
when 172 => 
--# line 1264 "ada202x_lex.l"
ECHO_L; -- ignore white space and comments to end-of-line

when 173 => 
--# line 1266 "ada202x_lex.l"

        --  Not start of line (or whole line); no need to keep track
        pragma Assert (Col_Count > 0);
        ECHO_L;


when 174 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1273 "ada202x_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 175 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1283 "ada202x_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 176 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1293 "ada202x_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 177 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1303 "ada202x_lex.l"

        --  Ignore outdent for these "divider" constructs
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 178 => 
yy_ch_buf(yy_cp) := yy_hold_char; -- undo effects of setting up yytext
 yy_cp := yy_bp + 1;
yy_c_buf_p := yy_cp;
YY_DO_BEFORE_ACTION; -- set up yytext again
--# line 1313 "ada202x_lex.l"

        --  Ignore outdent for label
        unput(yytext(1));
        if Debug_Indent then
           Text_IO.Put_Line(" [exiting OUTDENTING] ");
           Text_IO.Flush;
        end if;
        ENTER(CHARLIT);


when 179 => 
--# line 1323 "ada202x_lex.l"

        --  Return another OUTDENT
        declare
           Do_Match_Check : Boolean := True;
        begin
           unput(yytext(1));
           if Top > 1 and then Col_Count < Indent_Stack(Top)
             and then (Col_Match_Expected
               or else Col_Count < Indent_Stack(Top-1))
           then
              --  Not yet reached a matching indent;
              --  Pop the stack
              if Debug_Indent then
                 Text_IO.Put_Line(" [popping" &
                   Integer'Image(Indent_Stack(Top)) &
                   " from Indent_Stack] ");
                 Text_IO.Flush;
              end if;
              Top := Top - 1;
              if Col_Count >= Indent_Stack(Top)
                or else not Col_Match_Expected
                or else Bracketing_Token_Stack(Top + 1) = ':'
                or else Bracketing_Token_Stack(Top + 1) = REFERS_TO
              then
                 --  Don't check for indent match this time;
                 --  wait til next time since only one outdent occurring,
                 --  or ":" or "=>" used at end of line (which allows multiple
                 --  outdents at a time).
                 Do_Match_Check := False;
              end if;
           end if;

           if Do_Match_Check then
              --  Found (nearly) matching indent
              if Debug_Indent then
                 Text_IO.Put_Line(" [exiting OUTDENTING] ");
                 Text_IO.Flush;
              end if;
              if Col_Count = 0 then
                 --  Return the token at the beginning of the line
                 ENTER(RESCANNING);
              else
                 ENTER(CHARLIT);
              end if;
              if Col_Count /= Indent_Stack(Top)
                and then Col_Match_Expected
              then
                 --  Not quite matching
                 Parser_Warning("indent mismatch; expected indent of" &
                   Integer'Image(Indent_Stack(Top)) & ", found" &
                   Integer'Image(Col_Count));

                 --  Force a match
                 --  TBD: Not sure this is the right choice
                 if Top = 1 then
                    Top := Top + 1;
                    if Debug_Indent then
                       Text_IO.Put_Line(" [pushing" &
                         Integer'Image(Col_Count) &
                         " on Indent_Stack to force a match] ");
                       Text_IO.Flush;
                    end if;
                 else
                    if Debug_Indent then
                       Text_IO.Put_Line(" [setting top of Indent_Stack to" &
                         Integer'Image(Col_Count) & "] "); Text_IO.Flush;
                    end if;
                 end if;
                 Indent_Stack(Top) := Col_Count;
              end if;
           end if;
           yylval := Create_Token(Text => "");
           if Do_Match_Check then
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning NEWLINE after OUTDENTs] ");
                 Text_IO.Flush;
              end if;
              return NEWLINE;
           else
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning OUTDENT] ");
                 Text_IO.Flush;
              end if;
              return OUTDENT;
           end if;
        end;


when YY_END_OF_BUFFER +CHARLIT + 1 
 |
YY_END_OF_BUFFER +TICK + 1 
 |
YY_END_OF_BUFFER +AFTER_IMPLEMENTS + 1 
 |
YY_END_OF_BUFFER +INITIAL + 1 
 =>
--# line 1411 "ada202x_lex.l"

        if Top = 0 then
           if Debug_Indent and then Expecting_Indent then
              Text_IO.Put(" [EOF: indent off] "); Text_IO.Flush;
           end if;
           Expecting_Indent := False;
           if Debug_Indent then
              Text_IO.Put(" [returning EOF] "); Text_IO.Flush;
           end if;
           return End_Of_Input;
        else
           unput(YY_END_OF_BUFFER_CHAR);
           Col_Count := Indent_Stack(1);
           if Debug_Indent then
              Text_IO.Put_Line(" [popping" & Integer'Image(Indent_Stack(Top)) &
                " from Indent_Stack] ");
              Text_IO.Flush;
           end if;
           Top := Top - 1;
           if Top > 0 then
              if Debug_Indent then
                 Text_IO.Put_Line(" [entering EOF OUTDENTING] ");
                 Text_IO.Flush;
              end if;
              ENTER(OUTDENTING);
           else
              --  This is a significant NEWLINE
              if Debug_Indent then
                 Text_IO.Put_Line(" [returning NEWLINE] ");
                 Text_IO.Flush;
              end if;
              yylval := Create_Token(Text => "");
              return NEWLINE;
           end if;
        end if;


when YY_END_OF_BUFFER +OUTDENTING + 1 
 =>
--# line 1448 "ada202x_lex.l"

        --  Return another OUTDENT
        unput(YY_END_OF_BUFFER_CHAR);
        if Debug_Indent then
           Text_IO.Put_Line(" [popping" & Integer'Image(Indent_Stack(Top)) &
             " from Indent_Stack] ");
           Text_IO.Flush;
        end if;
        Top := Top - 1;
        if Top = 0 then
           --  All done
           if Debug_Indent then
              Text_IO.Put_Line(" [exiting EOF OUTDENTING] ");
              Text_IO.Flush;
           end if;
           ENTER(CHARLIT);
        end if;

        yylval := Create_Token(Text => "");
        if Debug_Indent then
           Text_IO.Put_Line(" [returning EOF OUTDENT] ");
           Text_IO.Flush;
        end if;
        return OUTDENT;


  -- The following matches all new lines (and the preceding white space).
when 182 => 
--# line 1477 "ada202x_lex.l"

        --  TBD: Should we return NEWLINE if this line is entirely blank?
        if Echo_Input then
           text_io.new_line;
        end if;
        Display_Linenum;


  -- The following matches everything else and prints an error message
  -- indicating that something unexpected was found.
when 183 => 
--# line 1488 "ada202x_lex.l"
ECHO_L; 
	    yyerror("lexical error: '" &
	      Ada202x_lex_dfa.yytext & "'");


when 184 => 
--# line 1493 "ada202x_lex.l"
raise AFLEX_SCANNER_JAMMED;
when YY_END_OF_BUFFER + RESCANNING + 1 => 
    return End_Of_Input;
                when YY_END_OF_BUFFER =>
                    -- undo the effects of YY_DO_BEFORE_ACTION
                    yy_ch_buf(yy_cp) := yy_hold_char;

                    yytext_ptr := yy_bp;

                    case yy_get_next_buffer is
                        when EOB_ACT_END_OF_FILE =>
                            begin
                            if ( yywrap ) then
                                -- note: because we've taken care in
                                -- yy_get_next_buffer() to have set up yytext,
                                -- we can now set up yy_c_buf_p so that if some
                                -- total hoser (like aflex itself) wants
                                -- to call the scanner after we return the
                                -- End_Of_Input, it'll still work - another
                                -- End_Of_Input will get returned.

                                yy_c_buf_p := yytext_ptr;

                                yy_act := YY_STATE_EOF((yy_start - 1) / 2);

                                goto do_action;
                            else
                                --  start processing a new file
                                yy_init := true;
                                goto new_file;
                            end if;
                            end;
                        when EOB_ACT_RESTART_SCAN =>
                            yy_c_buf_p := yytext_ptr;
                            yy_hold_char := yy_ch_buf(yy_c_buf_p);
                        when EOB_ACT_LAST_MATCH =>
                            yy_c_buf_p := yy_n_chars;
                            yy_current_state := yy_get_previous_state;

                            yy_cp := yy_c_buf_p;
                            yy_bp := yytext_ptr;
                            goto next_action;
                        when others => null;
                        end case; -- case yy_get_next_buffer()
                when others =>
                    text_io.put( "action # " );
                    text_io.put( INTEGER'IMAGE(yy_act) );
                    text_io.new_line;
                    raise AFLEX_INTERNAL_ERROR;
            end case; -- case (yy_act)
        end loop; -- end of loop waiting for end of file
end YYLex;
--# line 1493 "ada202x_lex.l"

end Ada202x_lex;


